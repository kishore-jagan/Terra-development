import { IgPoint } from "igniteui-angular-core";
import { IgxAxisComponent } from "./igx-axis-component";
import { IgxSeriesComponent } from "./igx-series-component";
import { ValueOverlay } from "./ValueOverlay";
import * as i0 from "@angular/core";
/**
 * Represents the class of the value overlay. The value overlay is a line or circle representing a value on an axis.
*/
export declare class IgxValueOverlayComponent extends IgxSeriesComponent {
    protected createImplementation(): ValueOverlay;
    /**
                                 * @hidden
                                 */
    get i(): ValueOverlay;
    constructor();
    /**
     * Gets or sets the axis used by the value overlay.
    */
    get axis(): IgxAxisComponent;
    set axis(v: IgxAxisComponent);
    /**
     * Gets or sets the value of the overlay.
    */
    get value(): number;
    set value(v: number);
    static ngAcceptInputType_value: number | string;
    /**
     * Gets or sets whether to draw annotations over the axes where the crosshair meets with them.
    */
    get isAxisAnnotationEnabled(): boolean;
    set isAxisAnnotationEnabled(v: boolean);
    static ngAcceptInputType_isAxisAnnotationEnabled: boolean | string;
    /**
     * Sets or gets a function which takes an object that produces a formatted label for the axis annotation.
    */
    get axisAnnotationFormatLabel(): (item: any) => string;
    set axisAnnotationFormatLabel(v: (item: any) => string);
    /**
     * Gets or sets the color to use for the axis annotation text. Leave unset for an automatic value.
    */
    get axisAnnotationTextColor(): string;
    set axisAnnotationTextColor(v: string);
    /**
     * Gets or sets the color to use for the axis annotation backing. Leave unset for an automatic value.
    */
    get axisAnnotationBackground(): string;
    set axisAnnotationBackground(v: string);
    /**
     * Gets or sets the corner radius to use for the axis annotation backing. Leave unset for an automatic value.
    */
    get axisAnnotationBackgroundCornerRadius(): number;
    set axisAnnotationBackgroundCornerRadius(v: number);
    static ngAcceptInputType_axisAnnotationBackgroundCornerRadius: number | string;
    /**
     * Gets or sets the precision to use displaying values for interpolated positions.
    */
    get axisAnnotationInterpolatedValuePrecision(): number;
    set axisAnnotationInterpolatedValuePrecision(v: number);
    static ngAcceptInputType_axisAnnotationInterpolatedValuePrecision: number | string;
    /**
     * Gets or sets the color to use for the axis annotation outline. Leave unset for an automatic value.
    */
    get axisAnnotationOutline(): string;
    set axisAnnotationOutline(v: string);
    /**
     * Gets or sets the padding to use withing the axis annotation callout. Leaving this NaN will use an automatic value related to the axis label margins.
    */
    get axisAnnotationPaddingLeft(): number;
    set axisAnnotationPaddingLeft(v: number);
    static ngAcceptInputType_axisAnnotationPaddingLeft: number | string;
    /**
     * Gets or sets the padding to use withing the axis annotation callout. Leaving this NaN will use an automatic value related to the axis label margins.
    */
    get axisAnnotationPaddingTop(): number;
    set axisAnnotationPaddingTop(v: number);
    static ngAcceptInputType_axisAnnotationPaddingTop: number | string;
    /**
     * Gets or sets the padding to use withing the axis annotation callout. Leaving this NaN will use an automatic value related to the axis label margins.
    */
    get axisAnnotationPaddingRight(): number;
    set axisAnnotationPaddingRight(v: number);
    static ngAcceptInputType_axisAnnotationPaddingRight: number | string;
    /**
     * Gets or sets the padding to use withing the axis annotation callout. Leaving this NaN will use an automatic value related to the axis label margins.
    */
    get axisAnnotationPaddingBottom(): number;
    set axisAnnotationPaddingBottom(v: number);
    static ngAcceptInputType_axisAnnotationPaddingBottom: number | string;
    /**
     * Gets or sets the stroke thickness for the axis annotation backing. Leave unset for an automatic value.
    */
    get axisAnnotationStrokeThickness(): number;
    set axisAnnotationStrokeThickness(v: number);
    static ngAcceptInputType_axisAnnotationStrokeThickness: number | string;
    /**
     * Gets whether the series is a value overlay.
    */
    get isValueOverlay(): boolean;
    static ngAcceptInputType_isValueOverlay: boolean | string;
    get labelResolved(): string;
    findByName(name: string): any;
    protected _styling(container: any, component: any, parent?: any): void;
    getSeriesValue(world: IgPoint, useInterpolation: boolean, skipUnknowns: boolean): number;
    getSeriesValuePosition(world: IgPoint, useInterpolation: boolean, skipUnknowns: boolean): IgPoint;
    /**
     * Gets the item index associated with the specified world position
    
    * @param world
    */
    getItemIndex(world: IgPoint): number;
    /**
     * Gets the item that is the best match for the specified world coordinates.
    
    * @param world  * The world coordinates to use.
    */
    getItem(world: IgPoint): any;
    /**
     * Requests that the provided item should be brought into view if possible.
    
    * @param item  * The item to attempt to bring into view.
    */
    scrollIntoView(item: any): boolean;
    /**
     * Gets the label for a data item.
    
    * @param value  * The unscaled value to get a label for.
    */
    getLabel(value: number): string;
    static ɵfac: i0.ɵɵFactoryDeclaration<IgxValueOverlayComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IgxValueOverlayComponent, "igx-value-overlay", never, { "axis": "axis"; "value": "value"; "isAxisAnnotationEnabled": "isAxisAnnotationEnabled"; "axisAnnotationFormatLabel": "axisAnnotationFormatLabel"; "axisAnnotationTextColor": "axisAnnotationTextColor"; "axisAnnotationBackground": "axisAnnotationBackground"; "axisAnnotationBackgroundCornerRadius": "axisAnnotationBackgroundCornerRadius"; "axisAnnotationInterpolatedValuePrecision": "axisAnnotationInterpolatedValuePrecision"; "axisAnnotationOutline": "axisAnnotationOutline"; "axisAnnotationPaddingLeft": "axisAnnotationPaddingLeft"; "axisAnnotationPaddingTop": "axisAnnotationPaddingTop"; "axisAnnotationPaddingRight": "axisAnnotationPaddingRight"; "axisAnnotationPaddingBottom": "axisAnnotationPaddingBottom"; "axisAnnotationStrokeThickness": "axisAnnotationStrokeThickness"; }, {}, never, never>;
}
