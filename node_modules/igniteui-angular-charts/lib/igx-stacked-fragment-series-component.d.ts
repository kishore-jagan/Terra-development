import { EventEmitter, OnInit } from '@angular/core';
import { IgRect } from "igniteui-angular-core";
import { IgPoint } from "igniteui-angular-core";
import { IgDataTemplate } from "igniteui-angular-core";
import { PenLineCap } from "igniteui-angular-core";
import { Visibility } from "igniteui-angular-core";
import { LegendItemBadgeShape } from "igniteui-angular-core";
import { LegendItemBadgeMode } from "igniteui-angular-core";
import { MarkerType } from "./MarkerType";
import { MarkerFillMode } from "./MarkerFillMode";
import { MarkerOutlineMode } from "./MarkerOutlineMode";
import { SeriesOutlineMode } from "./SeriesOutlineMode";
import { SeriesHighlightedValuesDisplayMode } from "./SeriesHighlightedValuesDisplayMode";
import { CategoryTransitionInMode } from "./CategoryTransitionInMode";
import { TransitionInSpeedType } from "./TransitionInSpeedType";
import { IgxPropertyUpdatedEventArgs } from "igniteui-angular-core";
import { StackedFragmentSeries } from "./StackedFragmentSeries";
import * as i0 from "@angular/core";
/**
 * Represents a non-visual child of StackedSeriesBase.
*/
export declare class IgxStackedFragmentSeriesComponent implements OnInit {
    protected createImplementation(): StackedFragmentSeries;
    ngOnInit(): void;
    protected _implementation: any;
    /**
     * @hidden
     */
    get i(): StackedFragmentSeries; /**
                                 * @hidden
                                 */
    static _createFromInternal(internal: any): IgxStackedFragmentSeriesComponent;
    private onImplementationCreated;
    constructor();
    /**
     * Gets or sets the ItemsSource property for the current series object. Normally you will want to provide data to the parent series instead.
     * But if you have data as individual columns, it can be assigned here. The data must be aligned and have the same number of items for each fragment.
    */
    get dataSource(): any[];
    set dataSource(v: any[]);
    /**
     * Gets or sets the HighlightedItemsSource property for the current series object.
    */
    get highlightedDataSource(): any[];
    set highlightedDataSource(v: any[]);
    /**
     * Gets or sets the brush of the stacked fragment.
    */
    get brush(): string;
    set brush(v: string);
    /**
     * Gets the actual brush used by the series.
    */
    get actualBrush(): string;
    set actualBrush(v: string);
    /**
     * Gets or sets a collection of Double values that indicate the pattern of dashes and gaps that
     * is used to outline the current series object.
    */
    get dashArray(): number[];
    set dashArray(v: number[]);
    static ngAcceptInputType_dashArray: number[] | string;
    /**
     * Gets or sets whether drop shadow should be enabled for this series.
    */
    get isDropShadowEnabled(): boolean;
    set isDropShadowEnabled(v: boolean);
    static ngAcceptInputType_isDropShadowEnabled: boolean | string;
    /**
     * Gets whether drop shadow is actually enabled for this series.
    */
    get actualIsDropShadowEnabled(): boolean;
    set actualIsDropShadowEnabled(v: boolean);
    static ngAcceptInputType_actualIsDropShadowEnabled: boolean | string;
    /**
     * Gets or sets the shadow blur.
     * This property is ignored when
     * StackedFragmentSeries.UseSingleShadow is set to true.
    */
    get shadowBlur(): number;
    set shadowBlur(v: number);
    static ngAcceptInputType_shadowBlur: number | string;
    /**
     * Gets the actual shadow blur used by the series.
    */
    get actualShadowBlur(): number;
    set actualShadowBlur(v: number);
    static ngAcceptInputType_actualShadowBlur: number | string;
    /**
     * Gets or sets the drop shadow color.
    */
    get shadowColor(): string;
    set shadowColor(v: string);
    /**
     * Gets actual the drop shadow color used by the series.
    */
    get actualShadowColor(): string;
    set actualShadowColor(v: string);
    /**
     * Gets or sets whether drop shadow is applied to the whole StackedFragmentSeries visual or to each of the individual shapes forming the StackedFragmentSeries.
     * When this property is set to true, no
     * StackedFragmentSeries.ShadowBlur is applied.
    */
    get useSingleShadow(): boolean;
    set useSingleShadow(v: boolean);
    static ngAcceptInputType_useSingleShadow: boolean | string;
    /**
     * Gets whether drop shadow is actually applied to the whole StackedFragmentSeries visual or to each of the individual shapes forming the StackedFragmentSeries.
    */
    get actualUseSingleShadow(): boolean;
    set actualUseSingleShadow(v: boolean);
    static ngAcceptInputType_actualUseSingleShadow: boolean | string;
    /**
     * Gets or sets the drop shadow x-offset.
    */
    get shadowOffsetX(): number;
    set shadowOffsetX(v: number);
    static ngAcceptInputType_shadowOffsetX: number | string;
    /**
     * Gets the actual drop shadow x-offset applied to the series.
    */
    get actualShadowOffsetX(): number;
    set actualShadowOffsetX(v: number);
    static ngAcceptInputType_actualShadowOffsetX: number | string;
    /**
     * Gets or sets the drop shadow y-offset.
    */
    get shadowOffsetY(): number;
    set shadowOffsetY(v: number);
    static ngAcceptInputType_shadowOffsetY: number | string;
    /**
     * Gets the actual drop shadow y-offset applied to the series.
    */
    get actualShadowOffsetY(): number;
    set actualShadowOffsetY(v: number);
    static ngAcceptInputType_actualShadowOffsetY: number | string;
    /**
     * The style of the end points of any lines or polylines representing this series.
     * Not every series type has a line at which it would be appropriate to display an end cap, so this property does not affect every series type.  LineSeries, for example, is affected by EndCap, but ColumnSeries is not.
    */
    get lineCap(): PenLineCap;
    set lineCap(v: PenLineCap);
    static ngAcceptInputType_lineCap: PenLineCap | string;
    /**
     * Gets the actual end cap used by the series.
    */
    get actualLineCap(): PenLineCap;
    set actualLineCap(v: PenLineCap);
    static ngAcceptInputType_actualLineCap: PenLineCap | string;
    /**
     * Gets or sets the LegendItemBadgeTemplate property.
     * The legend item badge is created according to the LegendItemBadgeTemplate on-demand by
     * the series object itself.
    */
    get legendItemBadgeTemplate(): IgDataTemplate;
    set legendItemBadgeTemplate(v: IgDataTemplate);
    /**
     * Gets the actual legend item badge template used by the series.
    */
    get actualLegendItemBadgeTemplate(): IgDataTemplate;
    set actualLegendItemBadgeTemplate(v: IgDataTemplate);
    /**
     * Gets or sets the LegendItemTemplate property.
     * The legend item control content is created according to the LegendItemTemplate on-demand by
     * the series object itself.
    */
    get legendItemTemplate(): IgDataTemplate;
    set legendItemTemplate(v: IgDataTemplate);
    /**
     * Gets the actual legend item template used by the series.
    */
    get actualLegendItemTemplate(): IgDataTemplate;
    set actualLegendItemTemplate(v: IgDataTemplate);
    /**
     * Gets or sets the legend item visibility for the current series object.
    */
    get legendItemVisibility(): Visibility;
    set legendItemVisibility(v: Visibility);
    static ngAcceptInputType_legendItemVisibility: Visibility | string;
    /**
     * Gets the actual visibility of the legend items in the series.
    */
    get actualLegendItemVisibility(): Visibility;
    set actualLegendItemVisibility(v: Visibility);
    static ngAcceptInputType_actualLegendItemVisibility: Visibility | string;
    /**
     * Gets or sets the type of legend badge representing the current series in a legend.
     * This property will be ignored when the LegendItemTemplate or LegendItemBadgeTemplate property is set on the series
    */
    get legendItemBadgeShape(): LegendItemBadgeShape;
    set legendItemBadgeShape(v: LegendItemBadgeShape);
    static ngAcceptInputType_legendItemBadgeShape: LegendItemBadgeShape | string;
    /**
     * Gets or sets the mode of legend badge representing the current series in a legend.
     * This property will be ignored when the LegendItemTemplate or LegendItemBadgeTemplate property is set on the series
    */
    get legendItemBadgeMode(): LegendItemBadgeMode;
    set legendItemBadgeMode(v: LegendItemBadgeMode);
    static ngAcceptInputType_legendItemBadgeMode: LegendItemBadgeMode | string;
    /**
     * Gets the actual LegendItemBadgeShape of the series.
    */
    get actualLegendItemBadgeShape(): LegendItemBadgeShape;
    set actualLegendItemBadgeShape(v: LegendItemBadgeShape);
    static ngAcceptInputType_actualLegendItemBadgeShape: LegendItemBadgeShape | string;
    /**
     * Gets the actual LegendItemBadgeMode of the series.
    */
    get actualLegendItemBadgeMode(): LegendItemBadgeMode;
    set actualLegendItemBadgeMode(v: LegendItemBadgeMode);
    static ngAcceptInputType_actualLegendItemBadgeMode: LegendItemBadgeMode | string;
    /**
     * Gets or sets the brush that specifies how the current series object's marker interiors are painted.
    */
    get markerBrush(): string;
    set markerBrush(v: string);
    /**
     * Gets the actual marker brush of the series.
    */
    get actualMarkerBrush(): string;
    set actualMarkerBrush(v: string);
    /**
     * Gets or sets the brush that specifies how the current series object's marker outlines are painted.
    */
    get markerOutline(): string;
    set markerOutline(v: string);
    /**
     * Gets the actual marker outline of the series.
    */
    get actualMarkerOutline(): string;
    set actualMarkerOutline(v: string);
    /**
     * Gets or sets the MarkerTemplate for the current series object.
    */
    get markerTemplate(): IgDataTemplate;
    set markerTemplate(v: IgDataTemplate);
    /**
     * Gets the actual marker template used by the series.
    */
    get actualMarkerTemplate(): IgDataTemplate;
    set actualMarkerTemplate(v: IgDataTemplate);
    /**
     * Gets or sets the marker type for the current series object.
     * If the MarkerTemplate property is set, the setting of the MarkerType property will be ignored.
    */
    get markerType(): MarkerType;
    set markerType(v: MarkerType);
    static ngAcceptInputType_markerType: MarkerType | string;
    /**
     * Gets the actual marker type set used in the series.
    */
    get actualMarkerType(): MarkerType;
    set actualMarkerType(v: MarkerType);
    static ngAcceptInputType_actualMarkerType: MarkerType | string;
    /**
     * Gets or sets whether the marker fill is based on the marker outline of the series rather than the marker brushes collection.
    */
    get markerFillMode(): MarkerFillMode;
    set markerFillMode(v: MarkerFillMode);
    static ngAcceptInputType_markerFillMode: MarkerFillMode | string;
    /**
     * Gets whether the marker fill is based on the marker outline of the series rather than the marker brushes collection.
    */
    get actualMarkerFillMode(): MarkerFillMode;
    set actualMarkerFillMode(v: MarkerFillMode);
    static ngAcceptInputType_actualMarkerFillMode: MarkerFillMode | string;
    /**
     * Gets or sets whether the marker outline is based on the marker brush of the series rather than the marker outlines collection.
    */
    get markerOutlineMode(): MarkerOutlineMode;
    set markerOutlineMode(v: MarkerOutlineMode);
    static ngAcceptInputType_markerOutlineMode: MarkerOutlineMode | string;
    /**
     * Gets whether the marker outline is based on the marker brush of the series rather than the marker outlines collection.
    */
    get actualMarkerOutlineMode(): MarkerOutlineMode;
    set actualMarkerOutlineMode(v: MarkerOutlineMode);
    static ngAcceptInputType_actualMarkerOutlineMode: MarkerOutlineMode | string;
    /**
     * Gets or sets the Name of the stacked fragment.
    */
    get name(): string;
    set name(v: string);
    /**
     * Gets or sets the Opacity of the stacked fragment.
    */
    get opacity(): number;
    set opacity(v: number);
    static ngAcceptInputType_opacity: number | string;
    /**
     * Gets the series opacity.
    */
    get actualOpacity(): number;
    set actualOpacity(v: number);
    static ngAcceptInputType_actualOpacity: number | string;
    /**
     * Gets or sets the brush to use for the outline of the series.
     * Some series types, such as LineSeries, do not display outlines.  Therefore, this property does not affect some charts.
    */
    get outline(): string;
    set outline(v: string);
    /**
     * Gets the series outline.
    */
    get actualOutline(): string;
    set actualOutline(v: string);
    /**
     * Gets or sets the AreaFillOpacity of the stacked fragment. This property only applies for area-like series.
    */
    get areaFillOpacity(): number;
    set areaFillOpacity(v: number);
    static ngAcceptInputType_areaFillOpacity: number | string;
    /**
     * Gets the series ActualAreaFillOpacity.  This property only applies for area-like series.
    */
    get actualAreaFillOpacity(): number;
    set actualAreaFillOpacity(v: number);
    static ngAcceptInputType_actualAreaFillOpacity: number | string;
    /**
     * Gets or sets the opacity to use for the marker fills.
    */
    get markerFillOpacity(): number;
    set markerFillOpacity(v: number);
    static ngAcceptInputType_markerFillOpacity: number | string;
    /**
     * Gets the actual opacity to use for hte marker fills.
    */
    get actualMarkerFillOpacity(): number;
    set actualMarkerFillOpacity(v: number);
    static ngAcceptInputType_actualMarkerFillOpacity: number | string;
    /**
     * Gets or sets the outline mode to use for the fragment.
    */
    get outlineMode(): SeriesOutlineMode;
    set outlineMode(v: SeriesOutlineMode);
    static ngAcceptInputType_outlineMode: SeriesOutlineMode | string;
    /**
     * Gets the actual outline mode to use for the fragment.
    */
    get actualOutlineMode(): SeriesOutlineMode;
    set actualOutlineMode(v: SeriesOutlineMode);
    static ngAcceptInputType_actualOutlineMode: SeriesOutlineMode | string;
    /**
     * Gets or sets the target opacity to fade to for fade style highlighting.
    */
    get highlightingFadeOpacity(): number;
    set highlightingFadeOpacity(v: number);
    static ngAcceptInputType_highlightingFadeOpacity: number | string;
    /**
     * Gets the actual target opacity to fade to for fade style highlighting.
    */
    get actualHighlightingFadeOpacity(): number;
    set actualHighlightingFadeOpacity(v: number);
    static ngAcceptInputType_actualHighlightingFadeOpacity: number | string;
    /**
     * Gets the actual mode for displaying highlighted values.
    */
    get actualHighlightedValuesDisplayMode(): SeriesHighlightedValuesDisplayMode;
    set actualHighlightedValuesDisplayMode(v: SeriesHighlightedValuesDisplayMode);
    static ngAcceptInputType_actualHighlightedValuesDisplayMode: SeriesHighlightedValuesDisplayMode | string;
    /**
     * Gets or sets the x-radius of the ellipse that is used to round the corners of the column. This only applies to Bar and Column series.
    */
    get radiusX(): number;
    set radiusX(v: number);
    static ngAcceptInputType_radiusX: number | string;
    /**
     * Gets the actual corner radius of the series
    */
    get actualRadiusX(): number;
    set actualRadiusX(v: number);
    static ngAcceptInputType_actualRadiusX: number | string;
    /**
     * Gets whether the spline part is considered to be part of the range
    */
    get actualIsSplineShapePartOfRange(): boolean;
    set actualIsSplineShapePartOfRange(v: boolean);
    static ngAcceptInputType_actualIsSplineShapePartOfRange: boolean | string;
    /**
     * Gets or sets whether to include the spline shape in the axis range requested of the axis.
    */
    get isSplineShapePartOfRange(): boolean;
    set isSplineShapePartOfRange(v: boolean);
    static ngAcceptInputType_isSplineShapePartOfRange: boolean | string;
    /**
     * Gets or sets the y-radius of the ellipse that is used to round the corners of the column. This only applies to Bar and Column series.
    */
    get radiusY(): number;
    set radiusY(v: number);
    static ngAcceptInputType_radiusY: number | string;
    /**
     * Gets the actual corner radius of the series
    */
    get actualRadiusY(): number;
    set actualRadiusY(v: number);
    static ngAcceptInputType_actualRadiusY: number | string;
    /**
     * Gets or sets the width of the current series object's line thickness.
    */
    get thickness(): number;
    set thickness(v: number);
    static ngAcceptInputType_thickness: number | string;
    /**
     * Gets or sets the thickness of this stacked fragment.
    */
    get actualThickness(): number;
    set actualThickness(v: number);
    static ngAcceptInputType_actualThickness: number | string;
    /**
     * Gets or sets the width of the current series object's marker thickness.
    */
    get markerThickness(): number;
    set markerThickness(v: number);
    static ngAcceptInputType_markerThickness: number | string;
    /**
     * Gets actual marker thickness of this stacked fragment.
    */
    get actualMarkerThickness(): number;
    set actualMarkerThickness(v: number);
    static ngAcceptInputType_actualMarkerThickness: number | string;
    /**
     * Gets or sets the Title property.
     * The legend item control is created according to the Title on-demand by
     * the series object itself.
    */
    get title(): any;
    set title(v: any);
    /**
     * Gets or sets the EasingFunction used to morph the current series.
    */
    get transitionEasingFunction(): (time: number) => number;
    set transitionEasingFunction(v: (time: number) => number);
    /**
     * Gets or sets the duration of the current series's morph.
    */
    get transitionDuration(): number;
    set transitionDuration(v: number);
    static ngAcceptInputType_transitionDuration: number | string;
    /**
     * Gets or sets the duration of the current series's transition in morph.
    */
    get transitionInDuration(): number;
    set transitionInDuration(v: number);
    static ngAcceptInputType_transitionInDuration: number | string;
    /**
     * Gets or sets the EasingFunction used to morph the current series during the initial transition.
    */
    get transitionInEasingFunction(): (time: number) => number;
    set transitionInEasingFunction(v: (time: number) => number);
    /**
     * Gets or sets the method by which to animate the data into the chart when the chart data source is swapped.
     * Note: Transitions are not currently supported for stacked series.
    */
    get transitionInMode(): CategoryTransitionInMode;
    set transitionInMode(v: CategoryTransitionInMode);
    static ngAcceptInputType_transitionInMode: CategoryTransitionInMode | string;
    /**
     * Gets or sets whether the series should transition into the plot area when a new data source is assigned.
     * Note: Transitions are not currently supported for stacked series.
    */
    get isTransitionInEnabled(): boolean;
    set isTransitionInEnabled(v: boolean);
    static ngAcceptInputType_isTransitionInEnabled: boolean | string;
    /**
     * Gets or sets the duration of the current series's transition in morph.
    */
    get transitionInSpeedType(): TransitionInSpeedType;
    set transitionInSpeedType(v: TransitionInSpeedType);
    static ngAcceptInputType_transitionInSpeedType: TransitionInSpeedType | string;
    /**
     * Gets the the resolved value of whether transition in is enabled.
    */
    get actualIsTransitionInEnabled(): boolean;
    set actualIsTransitionInEnabled(v: boolean);
    static ngAcceptInputType_actualIsTransitionInEnabled: boolean | string;
    /**
     * Gets the resolved transition in duration
    */
    get actualTransitionInDuration(): number;
    set actualTransitionInDuration(v: number);
    static ngAcceptInputType_actualTransitionInDuration: number | string;
    /**
     * Gets the series transition easing function.
    */
    get actualTransitionInMode(): CategoryTransitionInMode;
    set actualTransitionInMode(v: CategoryTransitionInMode);
    static ngAcceptInputType_actualTransitionInMode: CategoryTransitionInMode | string;
    /**
     * Gets the series transition easing function.
    */
    get actualTransitionInSpeedType(): TransitionInSpeedType;
    set actualTransitionInSpeedType(v: TransitionInSpeedType);
    static ngAcceptInputType_actualTransitionInSpeedType: TransitionInSpeedType | string;
    /**
     * Gets the series transition easing function.
    */
    get actualTransitionInEasingFunction(): (time: number) => number;
    set actualTransitionInEasingFunction(v: (time: number) => number);
    /**
     * Gets the series transition easing function.
    */
    get actualTransitionEasingFunction(): (time: number) => number;
    set actualTransitionEasingFunction(v: (time: number) => number);
    /**
     * Gets the series transition duration.
    */
    get actualTransitionDuration(): number;
    set actualTransitionDuration(v: number);
    static ngAcceptInputType_actualTransitionDuration: number | string;
    /**
     * Gets or sets the value mapping property for the current series object.
    */
    get valueMemberPath(): string;
    set valueMemberPath(v: string);
    /**
     * Gets or sets the label displayed before series value in the Data Legend.
    */
    get valueMemberAsLegendLabel(): string;
    set valueMemberAsLegendLabel(v: string);
    /**
     * Gets or sets the unit displayed after series value in the Data Legend.
    */
    get valueMemberAsLegendUnit(): string;
    set valueMemberAsLegendUnit(v: string);
    /**
     * Gets the label displayed before series value in the Data Legend.
    */
    get actualValueMemberAsLegendLabel(): string;
    set actualValueMemberAsLegendLabel(v: string);
    /**
     * Gets the unit displayed after series value in the Data Legend.
    */
    get actualValueMemberAsLegendUnit(): string;
    set actualValueMemberAsLegendUnit(v: string);
    /**
     * Gets or sets a name used for grouping multiple fragment series in the Data Legend
     * If not set, series will be grouped by series family, e.g. "Stacked Series"
    */
    get dataLegendGroup(): string;
    set dataLegendGroup(v: string);
    /**
     * Gets or sets a name used for grouping highlighted series in the Data Legend
     * If not set, series will default to main series' HighlightedValuesDataLegendGroup, e.g. "Stacked Highlight"
    */
    get highlightedValuesDataLegendGroup(): string;
    set highlightedValuesDataLegendGroup(v: string);
    /**
     * Gets the label displayed before series value in the Data Legend.
    */
    get actualDataLegendGroup(): string;
    set actualDataLegendGroup(v: string);
    /**
     * Gets the label displayed before series value in the Data Legend.
    */
    get actualHighlightedValuesDataLegendGroup(): string;
    set actualHighlightedValuesDataLegendGroup(v: string);
    /**
     * Gets or sets the Visibility of the stacked fragment.
    */
    get visibility(): Visibility;
    set visibility(v: Visibility);
    static ngAcceptInputType_visibility: Visibility | string;
    /**
     * Gets the actual visibility of the stacked fragment.
    */
    get actualVisibility(): Visibility;
    set actualVisibility(v: Visibility);
    static ngAcceptInputType_actualVisibility: Visibility | string;
    /**
     * Gets the resolved brush used between the local series and the parent series.
    */
    get parentOrLocalBrush(): string;
    set parentOrLocalBrush(v: string);
    findByName(name: string): any;
    protected __p: string;
    protected _hasUserValues: Set<string>;
    protected get hasUserValues(): Set<string>;
    protected __m(propertyName: string): void;
    protected _stylingContainer: any;
    protected _stylingParent: any;
    protected _inStyling: boolean;
    protected _styling(container: any, component: any, parent?: any): void;
    /**
     * Gets the item index associated with the specified world position
    
    */
    getItemIndex(world: IgPoint): number;
    /**
     * Gets the item that is the best match for the specified world coordinates.
    
    * @param world  * The world coordinates to use.
    */
    getItem(world: IgPoint): any;
    getPreviousOrExactIndex(world: IgPoint, skipUnknowns: boolean): number;
    getNextOrExactIndex(world: IgPoint, skipUnknowns: boolean): number;
    getSeriesValue(world: IgPoint, useInterpolation: boolean, skipUnknowns: boolean): number;
    getSeriesValuePosition(world: IgPoint, useInterpolation: boolean, skipUnknowns: boolean): IgPoint;
    /**
     * If possible, will return the best available value bounding box within the series that has the best value match for the world position provided.
    
    * @param world  * The world coordinate for which to get a value bounding box for
    */
    getSeriesValueBoundingBox(world: IgPoint): IgRect;
    /**
     * If possible, will return the best available value marker bounding box within the series that has the best value match for the world position provided.
    
    * @param world  * The world coordinates for which to get a value marker bounding box for
    */
    getSeriesValueMarkerBoundingBox(world: IgPoint): IgRect;
    getSeriesHighValue(world: IgPoint, useInterpolation: boolean, skipUnknowns: boolean): number;
    getSeriesHighValuePosition(world: IgPoint, useInterpolation: boolean, skipUnknowns: boolean): IgPoint;
    getSeriesLowValue(world: IgPoint, useInterpolation: boolean, skipUnknowns: boolean): number;
    getSeriesLowValuePosition(world: IgPoint, useInterpolation: boolean, skipUnknowns: boolean): IgPoint;
    getSeriesValuePositionFromSeriesPixel(mouse: IgPoint, useInterpolation: boolean, skipUnknowns: boolean): IgPoint;
    getSeriesValueFromSeriesPixel(mouse: IgPoint, useInterpolation: boolean, skipUnknowns: boolean): number;
    /**
     * For a category plotted series, returns the current width of the items within the categories. This only returns a value if the items have some form of width (e.g. columns, bars, etc.) otherwise 0 is returned.
    
    */
    getItemSpan(): number;
    /**
     * Converts a point from coordinates within the series plot area to a world position within axis space.
    
    * @param seriesPoint  * The pixel location within the plot area of the series.
    */
    toWorldPosition(seriesPoint: IgPoint): IgPoint;
    /**
     * Converts a point from world coordinates to coordinates within the viewport of the series.
    
    * @param world  * The world position from which to convert.
    */
    fromWorldPosition(world: IgPoint): IgPoint;
    /**
     * Requests that the provided item should be brought into view if possible.
    
    * @param item  * The item to attempt to bring into view.
    */
    scrollIntoView(item: any): boolean;
    /**
     * Gets the effective viewport, adjusted to account for margins and other factors.
    
    */
    getEffectiveViewport(): IgRect;
    /**
     * Notifies the series that a visual property has changed, requiring a visual update.
    
    */
    notifyVisualPropertiesChanged(): void;
    /**
     * Simulates a pointer hover over the series surface.
    
    * @param point  * The pointer position relative to the series viewport over which to hover.
    */
    simulateHover(point: IgPoint): void;
    /**
     * Moves the cursor point to the provided world position. Some series may react to the current cursor position.
    
    * @param point  * The cursor point, in world coordinates.
    */
    moveCursorPoint(point: IgPoint): void;
    replayTransitionIn(): void;
    private _propertyUpdated;
    /**
     * Event raised when a property (including "effective" and non-dependency property) value changes.
    */
    get propertyUpdated(): EventEmitter<{
        sender: any;
        args: IgxPropertyUpdatedEventArgs;
    }>;
    protected _zoneRunner: (act: () => void) => void;
    protected _runInZone(act: () => void): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<IgxStackedFragmentSeriesComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IgxStackedFragmentSeriesComponent, "igx-stacked-fragment-series", never, { "dataSource": "dataSource"; "highlightedDataSource": "highlightedDataSource"; "brush": "brush"; "actualBrush": "actualBrush"; "dashArray": "dashArray"; "isDropShadowEnabled": "isDropShadowEnabled"; "actualIsDropShadowEnabled": "actualIsDropShadowEnabled"; "shadowBlur": "shadowBlur"; "actualShadowBlur": "actualShadowBlur"; "shadowColor": "shadowColor"; "actualShadowColor": "actualShadowColor"; "useSingleShadow": "useSingleShadow"; "actualUseSingleShadow": "actualUseSingleShadow"; "shadowOffsetX": "shadowOffsetX"; "actualShadowOffsetX": "actualShadowOffsetX"; "shadowOffsetY": "shadowOffsetY"; "actualShadowOffsetY": "actualShadowOffsetY"; "lineCap": "lineCap"; "actualLineCap": "actualLineCap"; "legendItemBadgeTemplate": "legendItemBadgeTemplate"; "actualLegendItemBadgeTemplate": "actualLegendItemBadgeTemplate"; "legendItemTemplate": "legendItemTemplate"; "actualLegendItemTemplate": "actualLegendItemTemplate"; "legendItemVisibility": "legendItemVisibility"; "actualLegendItemVisibility": "actualLegendItemVisibility"; "legendItemBadgeShape": "legendItemBadgeShape"; "legendItemBadgeMode": "legendItemBadgeMode"; "actualLegendItemBadgeShape": "actualLegendItemBadgeShape"; "actualLegendItemBadgeMode": "actualLegendItemBadgeMode"; "markerBrush": "markerBrush"; "actualMarkerBrush": "actualMarkerBrush"; "markerOutline": "markerOutline"; "actualMarkerOutline": "actualMarkerOutline"; "markerTemplate": "markerTemplate"; "actualMarkerTemplate": "actualMarkerTemplate"; "markerType": "markerType"; "actualMarkerType": "actualMarkerType"; "markerFillMode": "markerFillMode"; "actualMarkerFillMode": "actualMarkerFillMode"; "markerOutlineMode": "markerOutlineMode"; "actualMarkerOutlineMode": "actualMarkerOutlineMode"; "name": "name"; "opacity": "opacity"; "actualOpacity": "actualOpacity"; "outline": "outline"; "actualOutline": "actualOutline"; "areaFillOpacity": "areaFillOpacity"; "actualAreaFillOpacity": "actualAreaFillOpacity"; "markerFillOpacity": "markerFillOpacity"; "actualMarkerFillOpacity": "actualMarkerFillOpacity"; "outlineMode": "outlineMode"; "actualOutlineMode": "actualOutlineMode"; "highlightingFadeOpacity": "highlightingFadeOpacity"; "actualHighlightingFadeOpacity": "actualHighlightingFadeOpacity"; "actualHighlightedValuesDisplayMode": "actualHighlightedValuesDisplayMode"; "radiusX": "radiusX"; "actualRadiusX": "actualRadiusX"; "actualIsSplineShapePartOfRange": "actualIsSplineShapePartOfRange"; "isSplineShapePartOfRange": "isSplineShapePartOfRange"; "radiusY": "radiusY"; "actualRadiusY": "actualRadiusY"; "thickness": "thickness"; "actualThickness": "actualThickness"; "markerThickness": "markerThickness"; "actualMarkerThickness": "actualMarkerThickness"; "title": "title"; "transitionEasingFunction": "transitionEasingFunction"; "transitionDuration": "transitionDuration"; "transitionInDuration": "transitionInDuration"; "transitionInEasingFunction": "transitionInEasingFunction"; "transitionInMode": "transitionInMode"; "isTransitionInEnabled": "isTransitionInEnabled"; "transitionInSpeedType": "transitionInSpeedType"; "actualIsTransitionInEnabled": "actualIsTransitionInEnabled"; "actualTransitionInDuration": "actualTransitionInDuration"; "actualTransitionInMode": "actualTransitionInMode"; "actualTransitionInSpeedType": "actualTransitionInSpeedType"; "actualTransitionInEasingFunction": "actualTransitionInEasingFunction"; "actualTransitionEasingFunction": "actualTransitionEasingFunction"; "actualTransitionDuration": "actualTransitionDuration"; "valueMemberPath": "valueMemberPath"; "valueMemberAsLegendLabel": "valueMemberAsLegendLabel"; "valueMemberAsLegendUnit": "valueMemberAsLegendUnit"; "actualValueMemberAsLegendLabel": "actualValueMemberAsLegendLabel"; "actualValueMemberAsLegendUnit": "actualValueMemberAsLegendUnit"; "dataLegendGroup": "dataLegendGroup"; "highlightedValuesDataLegendGroup": "highlightedValuesDataLegendGroup"; "actualDataLegendGroup": "actualDataLegendGroup"; "actualHighlightedValuesDataLegendGroup": "actualHighlightedValuesDataLegendGroup"; "visibility": "visibility"; "actualVisibility": "actualVisibility"; "parentOrLocalBrush": "parentOrLocalBrush"; }, { "propertyUpdated": "propertyUpdated"; }, never, never>;
}
