import { __extends } from "tslib";
import { EventEmitter, Output, Component, Input } from '@angular/core';
import { delegateCombine } from "igniteui-angular-core";
import { IgxCategoryAxisBaseComponent } from "./igx-category-axis-base-component";
import { ensureBool } from "igniteui-angular-core";
import * as i0 from "@angular/core";
/**
 * Represents an category-based horizontal X axis that uses a DateTime scale.
*
* Represents horizontal axis that uses a DateTime scale.
*
* ```html
* <igx-data-chart
*     [dataSource]="data">
*     <igx-time-x-axis
* 		dateTimeMemberPath="date"
* 		#xAxis>
*     </igx-time-x-axis>
* </igx-data-chart>
* ```
*
* ```ts
* let xAxis = new IgxTimeXAxisComponent();
* xAxis.dataTimeMemberPath="date";
* this.chart.axes.add(xAxis);
* ```
*/
var IgxTimeAxisBaseComponent = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(IgxTimeAxisBaseComponent, _super);
    function IgxTimeAxisBaseComponent() {
        var _this = _super.call(this) || this;
        _this._actualMinimumValueChange = null;
        _this._actualMaximumValueChange = null;
        return _this;
    }
    Object.defineProperty(IgxTimeAxisBaseComponent.prototype, "i", {
        /**
                                     * @hidden
                                     */
        get: function () {
            return this._implementation;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgxTimeAxisBaseComponent.prototype, "dateTimeMemberPath", {
        /**
         * Gets or sets the DateTime mapping property for the axis.
        *
        * Use `DateTimeMemberPath` property for DateTime mapping with the axis.
        *
        * ```html
        * <igx-data-chart
        *     [dataSource]="data">
        *     <igx-time-x-axis
        * 		dateTimeMemberPath="date"
        * 		#xAxis>
        *     </igx-time-x-axis>
        * </igx-data-chart>
        * ```
        *
        * ```ts
        * let xAxis = new IgxTimeXAxisComponent();
        * xAxis.dataTimeMemberPath="date";
        * this.chart.axes.add(xAxis);
        * ```
        */
        get: function () {
            return this.i.dateTimeMemberPath;
        },
        set: function (v) {
            this.i.dateTimeMemberPath = v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgxTimeAxisBaseComponent.prototype, "isDataPreSorted", {
        /**
         * Gets or sets whether the data assigned to the date time axis should be considered pre-sorted by date/time.
        *
        * Use `IsDataPreSorted` property to decide if the data assigned to the date time axis should be considered pre-sorted by date/time.
        */
        get: function () {
            return this.i.mo;
        },
        set: function (v) {
            this.i.mo = ensureBool(v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgxTimeAxisBaseComponent.prototype, "actualMinimumValue", {
        /**
         * Gets the coerced minimum value.
        *
        * Use `ActualMinimumValue` to get the coerced maximum value.
        */
        get: function () {
            return this.i.actualMinimumValue;
        },
        set: function (v) {
            this.i.actualMinimumValue = v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgxTimeAxisBaseComponent.prototype, "actualMaximumValue", {
        /**
         * Gets the coerced maximum value.
        *
        * Use `ActualMaximumValue` to get the  coerced maximum value
        */
        get: function () {
            return this.i.actualMaximumValue;
        },
        set: function (v) {
            this.i.actualMaximumValue = v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgxTimeAxisBaseComponent.prototype, "minimumValue", {
        /**
         * Gets or sets the axis MinimumValue.
        *
        * Use `MinimumValue` property for axis minimum value.
        *
        * ```ts
        * this.timeXAxis.maximumValue="2019-12-26";
        * ```
        */
        get: function () {
            return this.i.minimumValue;
        },
        set: function (v) {
            this.i.minimumValue = v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgxTimeAxisBaseComponent.prototype, "maximumValue", {
        /**
         * Gets or sets the axis MaximumValue.
        *
        * Use `MaximumValue` property for axis maximum value.
        *
        * ```ts
        * this.timeXAxis.maximumValue="2019-12-26";
        * ```
        */
        get: function () {
            return this.i.maximumValue;
        },
        set: function (v) {
            this.i.maximumValue = v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgxTimeAxisBaseComponent.prototype, "isDateTime", {
        /**
         * Checks if the axis is of date time axis type
        *
        * Use `IsDateTime` property to Checks if the axis is of date time axis type.
        *
        * ```ts
        * const isDT = this.timeXAxis.isDateTime;
        * ```
        */
        get: function () {
            return this.i.ce;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgxTimeAxisBaseComponent.prototype, "isSorting", {
        /**
         * Checks if axis requires sorting of items
        *
        * Use `IsSorting` property to Checks if axis requires sorting of items.
        *
        * ```ts
        * const isDT = this.timeXAxis.isDateTime;
        * ```
        */
        get: function () {
            return this.i.cn;
        },
        enumerable: false,
        configurable: true
    });
    IgxTimeAxisBaseComponent.prototype.getFullRange = function () {
        var iv = this.i.ag();
        return (iv);
    };
    IgxTimeAxisBaseComponent.prototype.getItemValue = function (item, memberPathName) {
        var iv = this.i.fy(item, memberPathName);
        return (iv);
    };
    /**
     * Gets the index of the data item with the value nearest the given value.
    
    * @param unscaledValue  * The value to find a value close to.
    */
    IgxTimeAxisBaseComponent.prototype.getIndexClosestToUnscaledValue = function (unscaledValue) {
        var iv = this.i.i$f(unscaledValue);
        return (iv);
    };
    /**
     * Updates the axis when the data has been changed.
    
    */
    IgxTimeAxisBaseComponent.prototype.notifyDataChanged = function () {
        this.i.i$i();
    };
    Object.defineProperty(IgxTimeAxisBaseComponent.prototype, "actualMinimumValueChange", {
        get: function () {
            var _this = this;
            if (this._actualMinimumValueChange == null) {
                this._actualMinimumValueChange = new EventEmitter();
                this.i.propertyChanged = delegateCombine(this.i.propertyChanged, function (o, e) {
                    var iv = e;
                    var ext = _this.actualMinimumValue;
                    if (_this.beforeActualMinimumValueChange) {
                        _this.beforeActualMinimumValueChange(_this, ext);
                    }
                    _this._actualMinimumValueChange.emit(ext);
                });
            }
            return this._actualMinimumValueChange;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgxTimeAxisBaseComponent.prototype, "actualMaximumValueChange", {
        get: function () {
            var _this = this;
            if (this._actualMaximumValueChange == null) {
                this._actualMaximumValueChange = new EventEmitter();
                this.i.propertyChanged = delegateCombine(this.i.propertyChanged, function (o, e) {
                    var iv = e;
                    var ext = _this.actualMaximumValue;
                    if (_this.beforeActualMaximumValueChange) {
                        _this.beforeActualMaximumValueChange(_this, ext);
                    }
                    _this._actualMaximumValueChange.emit(ext);
                });
            }
            return this._actualMaximumValueChange;
        },
        enumerable: false,
        configurable: true
    });
    IgxTimeAxisBaseComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: IgxTimeAxisBaseComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    IgxTimeAxisBaseComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: IgxTimeAxisBaseComponent, selector: "ng-component", inputs: { dateTimeMemberPath: "dateTimeMemberPath", isDataPreSorted: "isDataPreSorted", actualMinimumValue: "actualMinimumValue", actualMaximumValue: "actualMaximumValue", minimumValue: "minimumValue", maximumValue: "maximumValue" }, outputs: { actualMinimumValueChange: "actualMinimumValueChange", actualMaximumValueChange: "actualMaximumValueChange" }, usesInheritance: true, ngImport: i0, template: "", isInline: true });
    return IgxTimeAxisBaseComponent;
}(IgxCategoryAxisBaseComponent));
export { IgxTimeAxisBaseComponent };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: IgxTimeAxisBaseComponent, decorators: [{
            type: Component,
            args: [{
                    template: "",
                }]
        }], ctorParameters: function () { return []; }, propDecorators: { dateTimeMemberPath: [{
                type: Input
            }], isDataPreSorted: [{
                type: Input
            }], actualMinimumValue: [{
                type: Input
            }], actualMaximumValue: [{
                type: Input
            }], minimumValue: [{
                type: Input
            }], maximumValue: [{
                type: Input
            }], actualMinimumValueChange: [{
                type: Output
            }], actualMaximumValueChange: [{
                type: Output
            }] } });
