/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { __extends, __values } from "tslib";
import { ScatterTriangulationSeries } from "./ScatterTriangulationSeries";
import { DependencyProperty } from "igniteui-angular-core";
import { Point_$type, typeCast, Number_$type, fromEnum, runOn, delegateRemove, delegateCombine, markType, markDep } from "igniteui-angular-core";
import { ValueBrushScale } from "./ValueBrushScale";
import { FastItemIntColumn } from "igniteui-angular-core";
import { LinearContourValueResolver } from "./LinearContourValueResolver";
import { SeriesView } from "./SeriesView";
import { DataLegendSeriesValueInfo } from "igniteui-angular-core";
import { DataLegendSeriesContext } from "igniteui-angular-core";
import { List$1 } from "igniteui-angular-core";
import { IFastItemsSource_$type } from "igniteui-angular-core";
import { ScalerParams } from "./ScalerParams";
import { ContourBuilder } from "./ContourBuilder";
import { Clipper } from "igniteui-angular-core";
import { RectUtil } from "igniteui-angular-core";
import { Brush } from "igniteui-angular-core";
import { BrushUtil } from "igniteui-angular-core";
import { BrushCollection } from "igniteui-angular-core";
import { DataContext } from "igniteui-angular-core";
import { Path } from "igniteui-angular-core";
import { PropertyMetadata } from "igniteui-angular-core";
import { boxArray$1 } from "igniteui-angular-core";
import { isNaN_ } from "igniteui-angular-core";
import { Pool$1 } from "igniteui-angular-core";
import { PathGeometry } from "igniteui-angular-core";
import { PathFigure } from "igniteui-angular-core";
import { PointCollectionUtil } from "igniteui-angular-core";
import { PolyLineSegment } from "igniteui-angular-core";
import { Tuple$2 } from "igniteui-angular-core";
import { GeometryUtil } from "igniteui-angular-core";
import { stringIsNullOrEmpty } from "igniteui-angular-core";
/**
 * @hidden
 */
var ScatterContourSeries = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(ScatterContourSeries, _super);
    function ScatterContourSeries() {
        var _this = _super.call(this) || this;
        _this.yo = null;
        _this.yj = null;
        FastItemIntColumn.m();
        _this.ab = ScatterContourSeries.$;
        _this.yk = new LinearContourValueResolver();
        return _this;
    }
    ScatterContourSeries.prototype.bi = function () {
        return new ScatterContourSeries();
    };
    ScatterContourSeries.prototype.get_fh = function () {
        return true;
    };
    ScatterContourSeries.prototype.ko = function (a, b) {
        var c = this.nb(b);
        if (c == ScatterContourSeries.$$p[4]) {
            return this.kp(a, b, this.yx);
        }
        return _super.prototype.ko.call(this, a, b);
    };
    ScatterContourSeries.prototype.mb = function (a) {
        var b = this.nb(a);
        if (b == ScatterContourSeries.$$p[4]) {
            return this.yx;
        }
        return _super.prototype.mb.call(this, a);
    };
    ScatterContourSeries.prototype.cq = function () {
        this.yl = new ScatterContourSeriesView(this);
        return this.yl;
    };
    Object.defineProperty(ScatterContourSeries.prototype, "yp", {
        get: function () {
            return this.yo;
        },
        set: function (a) {
            var b = this.yp != a;
            if (b) {
                var c = this.yp;
                this.yo = a;
                this.raisePropertyChanged("ValueColumn", c, this.yp);
            }
        },
        enumerable: false,
        configurable: true
    });
    ScatterContourSeries.prototype.getDataLegendSeriesContextAt = function (a, b) {
        var c = { $type: Point_$type, x: a, y: b };
        var d = this.kl(c);
        var e = d == null ? NaN : this.iv(d, "XMemberPath");
        var f = d == null ? NaN : this.iv(d, "YMemberPath");
        var g = d == null ? NaN : this.iv(d, "ValueMemberPath");
        var h = new DataLegendSeriesValueInfo();
        h.a = 13;
        h.l = e;
        h.q = "X";
        h.r = this.xs != null ? this.xs : "X";
        h.s = this.xo != null ? this.xo : "X:";
        h.t = this.xq != null ? this.xq : "";
        var i = new DataLegendSeriesValueInfo();
        i.a = 14;
        i.l = f;
        i.q = "Y";
        i.r = this.x0 != null ? this.x0 : "Y";
        i.s = this.xw != null ? this.xw : "Y:";
        i.t = this.xy != null ? this.xy : "";
        var j = new DataLegendSeriesValueInfo();
        j.a = 0;
        j.l = g;
        j.q = "Value";
        j.r = this.yx != null ? this.yx : "Value";
        j.s = this.yt != null ? this.yt : "V:";
        j.t = this.yv != null ? this.yv : "";
        var k = new DataLegendSeriesContext();
        k.e = ((function () {
            var $ret = new List$1(DataLegendSeriesValueInfo.$, 0);
            $ret.add(h);
            $ret.add(i);
            $ret.add(j);
            return $ret;
        })());
        k.h = this.ma();
        return k;
    };
    ScatterContourSeries.prototype.q5 = function (a, b, c, d) {
        _super.prototype.q5.call(this, a, b, c, d);
        switch (b) {
            case ScatterContourSeries.$$p[2]:
            case ScatterContourSeries.$$p[3]:
                this.qb();
                break;
            case "FastItemsSource":
                var e = typeCast(IFastItemsSource_$type, c);
                if (e != null) {
                    e.deregisterColumn(this.yp);
                    this.yp = null;
                }
                var f = typeCast(IFastItemsSource_$type, d);
                if (f != null) {
                    this.yp = this.di(this.yx);
                }
                this.rn(this.ge && c != null);
                break;
            case ScatterContourSeries.$$p[4]:
                if (this.dl != null) {
                    this.dl.deregisterColumn(this.yp);
                    this.yp = this.di(this.yx);
                }
                this.rn(false);
                this.qh();
                break;
            case "ValueResolver":
                this.rn(false);
                this.qh();
                break;
            case ScatterContourSeries.$$p[1]:
                var g = c;
                var h = d;
                if (g != null) {
                    g.unregisterSeries(this);
                }
                if (h != null) {
                    h.registerSeries(this);
                }
                this.y1();
                this.rn(false);
                this.qh();
                break;
            case "ActualBrush":
                this.y1();
                this.rn(false);
                this.qh();
                break;
        }
    };
    ScatterContourSeries.prototype.o3 = function (a, b) {
        _super.prototype.o3.call(this, a, b);
        if (a) {
            b.b6(a);
        }
    };
    ScatterContourSeries.prototype.ro = function (a) {
        _super.prototype.ro.call(this, a);
        this.y0(this.ct);
    };
    ScatterContourSeries.prototype.rm = function (a, b, c, d, e) {
        _super.prototype.rm.call(this, a, b, c, d, e);
        var f = this.a9.a$j.item(d);
        f.a3(c);
        if (this.d3(f)) {
            return;
        }
        this.y0(f);
    };
    ScatterContourSeries.prototype.y0 = function (a) {
        var e_1, _a;
        if (this.d3(a)) {
            return;
        }
        var b;
        var c;
        var d = a;
        var e = a.getViewInfo(c, b);
        c = e.p0;
        b = e.p1;
        var f = new ScalerParams(1, b, c, this.wq.ch);
        f.c = this.getEffectiveViewport1(a);
        var g = new ScalerParams(1, b, c, this.wr.ch);
        g.c = this.getEffectiveViewport1(a);
        var h = this.wq;
        var i = this.wr;
        var j = this.w0.count;
        var k;
        var xArr_ = this.w3.asArray();
        k = (xArr_.slice(0));
        var l;
        var yArr_ = this.w4.asArray();
        l = (yArr_.slice(0));
        var m = this.yp.asArray();
        var n = this.w0.asArray();
        var o = this.w1.asArray();
        var p = this.w2.asArray();
        var q = this.yk.j(this.yp);
        var r = new List$1(Number_$type, 1, q).toArray();
        h.ho(boxArray$1(k), 0, k.length, f);
        i.ho(boxArray$1(l), 0, l.length, g);
        var s = r.length;
        var t = new Array(s);
        for (var u = 0; u < s; ++u) {
            t[u] = new ContourBuilder();
        }
        var v = c.top;
        var w = c.left;
        var x = c.right;
        var y = c.bottom;
        var z;
        var aa;
        var ab;
        var ac;
        var ad = k.length;
        for (var ae = 0; ae < j; ae++) {
            var af = n[ae];
            var ag = o[ae];
            var ah = p[ae];
            if ((af >= ad) || (ag >= ad) || (ah >= ad) || (af < 0) || (ag < 0) || (ah < 0)) {
                continue;
            }
            var ai = k[af];
            var aj = l[af];
            var ak = { $type: Point_$type, x: ai, y: aj };
            var al = k[ag];
            var am = l[ag];
            var an = { $type: Point_$type, x: al, y: am };
            var ao = k[ah];
            var ap = l[ah];
            var aq = { $type: Point_$type, x: ao, y: ap };
            z = an.y < aq.y ? an.y : aq.y;
            z = ak.y < z ? ak.y : z;
            aa = an.y > aq.y ? an.y : aq.y;
            aa = ak.y > aa ? ak.y : aa;
            ab = an.x < aq.x ? an.x : aq.x;
            ab = ak.x < ab ? ak.x : ab;
            ac = an.x > aq.x ? an.x : aq.x;
            ac = ak.x > ac ? ak.x : ac;
            if (z < y && aa > v && ab < x && ac > w) {
                var ar = m[af];
                var as = m[ag];
                var at = m[ah];
                if (isNaN_(ar) || isNaN_(as) || isNaN_(at)) {
                    continue;
                }
                for (var au = 0; au < s; au++) {
                    var av = r[au];
                    var aw = t[au];
                    switch ((ar < av ? 1 : 0) | (as < av ? 2 : 0) | (at < av ? 4 : 0)) {
                        case 0: break;
                        case 1:
                            aw.d(aw.k(af, ak.x, ak.y, ar, ag, an.x, an.y, as, av), aw.k(ah, aq.x, aq.y, at, af, ak.x, ak.y, ar, av));
                            break;
                        case 2:
                            aw.d(aw.k(ag, an.x, an.y, as, ah, aq.x, aq.y, at, av), aw.k(af, ak.x, ak.y, ar, ag, an.x, an.y, as, av));
                            break;
                        case 3:
                            aw.d(aw.k(ag, an.x, an.y, as, ah, aq.x, aq.y, at, av), aw.k(ah, aq.x, aq.y, at, af, ak.x, ak.y, ar, av));
                            break;
                        case 4:
                            aw.d(aw.k(ah, aq.x, aq.y, at, af, ak.x, ak.y, ar, av), aw.k(ag, an.x, an.y, as, ah, aq.x, aq.y, at, av));
                            break;
                        case 5:
                            aw.d(aw.k(af, ak.x, ak.y, ar, ag, an.x, an.y, as, av), aw.k(ag, an.x, an.y, as, ah, aq.x, aq.y, at, av));
                            break;
                        case 6:
                            aw.d(aw.k(ah, aq.x, aq.y, at, af, ak.x, ak.y, ar, av), aw.k(af, ak.x, ak.y, ar, ag, an.x, an.y, as, av));
                            break;
                        case 7: break;
                    }
                }
            }
        }
        var ax = new Clipper(0, RectUtil.r(c, 2), false);
        var ay = new List$1(List$1.$.specialize(List$1.$.specialize(Point_$type)), 0);
        for (var az = 0; az < s; ++az) {
            var a0 = t[az];
            var a1 = new List$1(List$1.$.specialize(Point_$type), 0);
            var a2 = a0.c();
            for (var a3 = 0; a3 < a2.count; a3++) {
                var a4 = a2._inner[a3];
                var a5 = new List$1(Point_$type, 0);
                ax.i = a5;
                try {
                    for (var _b = (e_1 = void 0, __values(fromEnum(a4))), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var a6 = _c.value;
                        ax.j({ $type: Point_$type, x: a0.g.item(a6), y: a0.h.item(a6) });
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return))
                            _a.call(_b);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                ax.i = null;
                a1.add(a5);
            }
            ay.add(a1);
        }
        d.b5(ay, r);
    };
    ScatterContourSeries.prototype.sb = function () {
        _super.prototype.sb.call(this);
        this.y1();
    };
    ScatterContourSeries.prototype.y1 = function () {
        var e_2, _a;
        var a = this.u3;
        if (a == null) {
            a = this.u9;
        }
        if (a == null) {
            a = BrushUtil.h(255, 255, 255, 255);
        }
        var b = new ValueBrushScale();
        b.brushes = new BrushCollection();
        if (this.yn == null || this.yn.brushes == null || this.yn.brushes.count == 0) {
            b.brushes.add(BrushUtil.m(a, -0.5));
            b.brushes.add(a);
        }
        else {
            try {
                for (var _b = __values(fromEnum(this.yn.brushes)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var c = _c.value;
                    b.brushes.add(c);
                }
            }
            catch (e_2_1) {
                e_2 = { error: e_2_1 };
            }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return))
                        _a.call(_b);
                }
                finally {
                    if (e_2)
                        throw e_2.error;
                }
            }
        }
        if (this.yn != null) {
            if (!isNaN_(this.yn.minimumValue)) {
                b.minimumValue = this.yn.minimumValue;
            }
            if (!isNaN_(this.yn.maximumValue)) {
                b.maximumValue = this.yn.maximumValue;
            }
            b.logarithmBase = this.yn.logarithmBase;
            b.isLogarithmic = this.yn.isLogarithmic;
        }
        this.ym = b;
    };
    Object.defineProperty(ScatterContourSeries.prototype, "yk", {
        get: function () {
            return this.yj;
        },
        set: function (a) {
            var b = a != this.yk;
            if (b) {
                if (this.yj != null) {
                    var c = this.yj;
                    c.updated = delegateRemove(c.updated, runOn(this, this.y2));
                }
                var d = this.yj;
                this.yj = a;
                if (this.yj != null) {
                    var e = this.yj;
                    e.updated = delegateCombine(e.updated, runOn(this, this.y2));
                }
                this.raisePropertyChanged("ValueResolver", d, a);
                this.rn(false);
            }
        },
        enumerable: false,
        configurable: true
    });
    ScatterContourSeries.prototype.y2 = function (a, b) {
        this.rn(false);
    };
    ScatterContourSeries.prototype.hc = function (a, b, c) {
        return _super.prototype.hc.call(this, a, b, c) && this.yk != null && this.w3 != null && this.w4 != null && this.w0 != null && this.w1 != null && this.w2 != null && this.w3.count > 0 && this.w4.count > 0 && this.w0.count > 0 && this.w1.count > 0 && this.w2.count > 0;
    };
    ScatterContourSeries.prototype.a1 = function (a, b) {
        var c = this.yl.ca(a, b);
        if (c != null) {
            return c.dataContext;
        }
        return null;
    };
    ScatterContourSeries.$t = markType(ScatterContourSeries, 'ScatterContourSeries', ScatterTriangulationSeries.$);
    ScatterContourSeries.$$p = markDep(DependencyProperty, PropertyMetadata, ScatterContourSeries, 'raisePropertyChanged', ['ActualFillScale:ym:y3', [ValueBrushScale.$, null], 'FillScale:yn:y4', [ValueBrushScale.$, null], 'ValueMemberAsLegendLabel:yt:y5', [2, null], 'ValueMemberAsLegendUnit:yv:y6', [2, null], 'ValueMemberPath:yx:y7', [2, null]]);
    return ScatterContourSeries;
}(ScatterTriangulationSeries));
export { ScatterContourSeries };
/**
 * @hidden
 */
var ScatterContourSeriesView = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(ScatterContourSeriesView, _super);
    function ScatterContourSeriesView(a) {
        var _this = _super.call(this, a) || this;
        _this.b2 = null;
        _this.b1 = null;
        _this.b4 = null;
        _this.b3 = new List$1(Brush.$, 0);
        _this.b0 = null;
        _this.b4 = new List$1(Path.$, 0);
        _this.b1 = a;
        _this.b2 = ((function () {
            var $ret = new Pool$1(Path.$);
            $ret.create = runOn(_this, _this.cb);
            $ret.destroy = runOn(_this, _this.b9);
            $ret.activate = runOn(_this, _this.b7);
            $ret.disactivate = runOn(_this, _this.b8);
            return $ret;
        })());
        return _this;
    }
    ScatterContourSeriesView.prototype.cb = function () {
        var _this = this;
        var a = new Path();
        a.dataContext = ((function () {
            var $ret = new DataContext();
            $ret.series = _this.e;
            return $ret;
        })());
        this.b4.add(a);
        return a;
    };
    ScatterContourSeriesView.prototype.b7 = function (a) {
        a._visibility = 0;
    };
    ScatterContourSeriesView.prototype.b8 = function (a) {
        a._visibility = 1;
    };
    ScatterContourSeriesView.prototype.b9 = function (a) {
        this.b4.remove(a);
    };
    ScatterContourSeriesView.prototype.b5 = function (a, b) {
        var c = 0;
        this.b0 = b;
        this.b3.clear();
        var d = this.b1.ym;
        for (var e = 0; e < b.length; e++) {
            var f = b[e];
            var g = a._inner[c];
            var h = new PathGeometry();
            var _loop_1 = function (i) {
                var j = g._inner[i];
                if (j.count == 0) {
                    return "continue";
                }
                var k = PointCollectionUtil.f(j);
                var l = ((function () {
                    var $ret = new PathFigure();
                    $ret.isClosed = false;
                    $ret.isFilled = false;
                    $ret.startPoint = k._inner[0];
                    return $ret;
                })());
                l._segments.add(((function () {
                    var $ret = new PolyLineSegment();
                    $ret.points = k;
                    return $ret;
                })()));
                h.c.add(l);
            };
            for (var i = 0; i < g.count; i++) {
                _loop_1(i);
            }
            this.b2.item(c).an = h;
            if (this.b2.item(c).dataContext != null) {
                this.b2.item(c).dataContext.item = f;
            }
            if (d != null) {
                var m = d.getBrushByValue(f, this.b1.yp);
                if (m == null) {
                    m = this.e.u3;
                }
                this.b3.add(m);
            }
            else {
                this.b3.add(this.e.u3);
            }
            c++;
        }
        this.b2.count = c;
        this.as();
    };
    ScatterContourSeriesView.prototype.bg = function (a, b) {
        _super.prototype.bg.call(this, a, b);
        var c = a;
        c._stroke = this.b3._inner[b];
        c.ad = this.e.ic;
        if (c.y != null) {
            this.k.j(c, c.y);
        }
    };
    ScatterContourSeriesView.prototype.bh = function (a, b) {
        _super.prototype.bh.call(this, a, b);
        var c = a;
        var d = this.bs(b);
        c._stroke = d;
        c.ad = this.e.ic + 3;
    };
    ScatterContourSeriesView.prototype.a8 = function (a, b) {
        _super.prototype.a8.call(this, a, b);
        for (var c = 0; c < this.b4.count; c++) {
            var d = this.b4._inner[c];
            if (d._visibility != 1) {
                this.bf(d, c, b);
                a.t(d);
            }
        }
    };
    ScatterContourSeriesView.prototype.b6 = function (a) {
        this.b2.count = 0;
        this.as();
    };
    ScatterContourSeriesView.prototype.an = function (a) {
        _super.prototype.an.call(this, a);
        var b = new List$1(Tuple$2.$.specialize(Number_$type, Path.$), 0);
        if (this.b0 != null) {
            for (var c = 0; c < this.b2.count; c++) {
                b.add(new Tuple$2(Number_$type, Path.$, this.b0[c], this.b2.item(c)));
            }
        }
        b.aa(function (d, e) {
            if (d.c < e.c) {
                return -1;
            }
            else if (d.c > e.c) {
                return 1;
            }
            return 0;
        });
        for (var d = 0; d < b.count; d++) {
            var e = typeCast(Path.$, b._inner[d].d);
            if (e._visibility != 1) {
                this.e.bb.exportPathData(a, e, "contour" + d, ["Main "]);
            }
        }
    };
    ScatterContourSeriesView.prototype.getDefaultTooltipTemplate = function () {
        var a = "<div class='ui-chart-default-tooltip-content'><span";
        var b = this.e.a9.a$u(this.e);
        if (!stringIsNullOrEmpty(b)) {
            a += " style='color:" + b + "'";
        }
        a += ">" + this.b1.title + "</span><br/>";
        if (!stringIsNullOrEmpty(this.b1.yx)) {
            a += "<span>Value: ${item}</span>";
        }
        a += "</div>";
        return a;
    };
    ScatterContourSeriesView.prototype.ca = function (a, b) {
        for (var c = 0; c < this.b4.count; c++) {
            var d = this.b4._inner[c];
            var e = typeCast(PathGeometry.$, d.an);
            if (e != null) {
                for (var f = 0; f < e.c.count; f++) {
                    var g = e.c._inner[f];
                    var h = e.c._inner[f]._startPoint;
                    for (var i = 0; i < g._segments.count; i++) {
                        var j = typeCast(PolyLineSegment.$, g._segments._inner[i]);
                        if (j != null) {
                            var k = this.b1.ic / 2 + this.b1.is(b);
                            if (j._points.count > 0 && GeometryUtil.d(a, h, j._points, k)) {
                                return d;
                            }
                        }
                    }
                }
            }
        }
        return null;
    };
    ScatterContourSeriesView.$t = markType(ScatterContourSeriesView, 'ScatterContourSeriesView', SeriesView.$);
    return ScatterContourSeriesView;
}(SeriesView));
export { ScatterContourSeriesView };
