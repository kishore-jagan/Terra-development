import { Component, ChangeDetectionStrategy, ViewChild, ViewContainerRef, Input, EventEmitter, Output, ContentChildren } from '@angular/core';
import { AngularRenderer, AngularWrapper } from "igniteui-angular-core";
import { TypeRegistrar, delegateCombine } from "igniteui-angular-core";
import { DataChartStylingDefaults } from './DataChartStylingDefaults';
import { XamDoughnutChart } from './XamDoughnutChart';
import { ensureBool, fromPoint, CollectionAdapter, toSpinal, initializePropertiesFromCss, NamePatcher } from "igniteui-angular-core";
import { Style } from "igniteui-angular-core";
import { IgxSliceClickEventArgs } from "./igx-slice-click-event-args";
import { IgxHoleDimensionsChangedEventArgs } from "./igx-hole-dimensions-changed-event-args";
import { IgxRingSeriesBaseComponent } from "./igx-ring-series-base-component";
import { NotifyCollectionChangedAction } from "igniteui-angular-core";
import { IgxRingSeriesCollection } from "./igx-ring-series-collection";
import { IgxPieSliceDataContext } from "./igx-pie-slice-data-context";
import * as i0 from "@angular/core";
/**
 * Represents concentric circles divided on arcs  depending on data.
*/
var IgxDoughnutChartComponent = /** @class */ /*@__PURE__*/ (function () {
    function IgxDoughnutChartComponent(renderer, _elRef, ngZone, injector, componentFactoryResolver) {
        var _this = this;
        this.renderer = renderer;
        this._elRef = _elRef;
        this.ngZone = ngZone;
        this.injector = injector;
        this.componentFactoryResolver = componentFactoryResolver;
        /**
         * The series actually present in the chart. Do not directly modify this array.
         * This array's contents can be modified by causing Angular to reproject the child content.
         * Or adding and removing series from the manual series collection on the series property.
         */
        this.actualSeries = [];
        this._seriesAdapter = null;
        this._series = null;
        this._defaultTooltips = null;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        this._sliceClick = null;
        this._holeDimensionsChanged = null;
        this._zoneRunner = null;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        this._zoneRunner = function (act) { return ngZone.run(act); };
        this.container = renderer.createElement("div");
        renderer.appendChild(_elRef.element.nativeElement, this.container);
        renderer.setStyle(this.container, "display", "block");
        renderer.setStyle(this.container, "width", "100%");
        renderer.setStyle(this.container, "height", "100%");
        var root;
        root = this.container;
        if (this.container != null) {
            root = this.container;
        }
        var ren = new AngularRenderer(root, this.renderer, window.document, this.ngZone, true, DataChartStylingDefaults);
        this._wrapper = ren;
        var chart = this.i;
        this._chart = chart;
        this._seriesAdapter = new CollectionAdapter([], this.i.series, this.actualSeries, function (c) { return c.i; }, function (i) {
            i.owner = _this;
            // (<any>i)._provideRenderer(this._dataSource);
            if (_this.container && _this.container.parentElement) {
                i._styling(_this.container, _this, _this);
            }
            _this._ensureDefaultTooltip(i);
            _this._ensureTooltipCreated(i);
        }, function (i) {
            //(<any>i)._provideRenderer(null);
        });
        chart.provideContainer(ren);
        ren.addSizeWatcher(function () {
            _this._chart.notifyResized();
        });
    }
    Object.defineProperty(IgxDoughnutChartComponent.prototype, "height", {
        get: function () {
            return this._height;
        },
        set: function (value) {
            this._height = value;
            this.renderer.setStyle(this._elRef.element.nativeElement, "height", value);
            this._chart.notifyResized();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgxDoughnutChartComponent.prototype, "width", {
        get: function () {
            return this._width;
        },
        set: function (value) {
            this._width = value;
            this.renderer.setStyle(this._elRef.element.nativeElement, "width", value);
            this._chart.notifyResized();
        },
        enumerable: false,
        configurable: true
    });
    IgxDoughnutChartComponent.prototype.ngOnDestroy = function () {
        this._chart.destroy();
        this._wrapper.destroy();
    };
    IgxDoughnutChartComponent.prototype.onImplementationCreated = function () {
    };
    IgxDoughnutChartComponent.prototype.createImplementation = function () {
        return new XamDoughnutChart();
    };
    Object.defineProperty(IgxDoughnutChartComponent.prototype, "i", {
        get: function () {
            return this._implementation;
        },
        enumerable: false,
        configurable: true
    });
    IgxDoughnutChartComponent.prototype.createSeriesComponent = function (type) {
        if (TypeRegistrar.isRegistered(type)) {
            var s = TypeRegistrar.create(type);
            s.owner = this;
            s._provideRenderer(this._wrapper);
            return s;
        }
        else {
            //we shouldn't get here, hopefully.
            throw Error("series type not loaded: " + type);
        }
    };
    IgxDoughnutChartComponent.prototype.ngAfterContentInit = function () {
        var _this = this;
        if (TypeRegistrar.isRegistered("IgxDoughnutChartDefaultTooltipsComponent")) {
            var c = TypeRegistrar.get("IgxDoughnutChartDefaultTooltipsComponent");
            var cf = this.componentFactoryResolver.resolveComponentFactory(c);
            var cr_1 = this._dynamicContent.createComponent(cf);
            this._defaultTooltips = cr_1;
            cr_1.instance.onContentReady.subscribe(function () {
                _this._onDefaultTooltipsReady(cr_1);
            });
        }
        this._seriesAdapter.updateQuery(this.contentSeries);
        this._styling(this.container, this);
        if (this.actualSeries && this.actualSeries.length > 0) {
            var currSeries = this.actualSeries;
            for (var i = 0; i < currSeries.length; i++) {
                currSeries[i]._styling(this.container, this, this);
            }
        }
        this.i.notifyResized();
    };
    Object.defineProperty(IgxDoughnutChartComponent.prototype, "series", {
        /**
         * A collection or manually added series for the chart.
        */
        get: function () {
            var _this = this;
            if (this._series === null) {
                var coll = new IgxRingSeriesCollection();
                var inner = coll._innerColl;
                inner.addListener(function (sender, e) {
                    switch (e.action) {
                        case NotifyCollectionChangedAction.Add:
                            _this._seriesAdapter.addManualItem(e.newItems.item(0));
                            break;
                        case NotifyCollectionChangedAction.Remove:
                            _this._seriesAdapter.removeManualItemAt(e.oldStartingIndex);
                            break;
                        case NotifyCollectionChangedAction.Replace:
                            _this._seriesAdapter.removeManualItemAt(e.oldStartingIndex);
                            _this._seriesAdapter.insertManualItem(e.newStartingIndex, e.newItems.item(0));
                            break;
                        case NotifyCollectionChangedAction.Reset:
                            _this._seriesAdapter.clearManualItems();
                            break;
                    }
                });
                this._series = coll;
            }
            return this._series;
        },
        enumerable: false,
        configurable: true
    });
    IgxDoughnutChartComponent.prototype._ensureTooltipCreated = function (series) {
        var _this = this;
        series._ensureTooltipCreated(function () { return _this.createTooltip(); }, function (ele) {
            var wrapper = new AngularWrapper(ele, _this.renderer, _this.ngZone);
            wrapper.updateToolTip = ele.updateToolTip;
            wrapper.hideToolTip = ele.hideToolTip;
            return wrapper;
        });
    };
    IgxDoughnutChartComponent.prototype._ensureDefaultTooltip = function (series) {
        if (this._defaultTooltips == null) {
            return;
        }
        this._defaultTooltips.instance["ensureDefaultTooltip"](series);
    };
    IgxDoughnutChartComponent.prototype._onDefaultTooltipsReady = function (cr) {
        if (this.actualSeries && this.actualSeries.length > 0) {
            var currSeries = this.actualSeries;
            for (var i = 0; i < currSeries.length; i++) {
                if (currSeries[i].showDefaultTooltip) {
                    this._ensureDefaultTooltip(currSeries[i]);
                }
            }
        }
    };
    IgxDoughnutChartComponent.prototype.createTooltip = function () {
        if (!TypeRegistrar.isRegistered("IgxTooltipContainerComponent")) {
            return null;
        }
        var t = TypeRegistrar.get("IgxTooltipContainerComponent");
        var cf = this.componentFactoryResolver.resolveComponentFactory(t);
        var cr = this._dynamicContent.createComponent(cf);
        var ele = cr.location.nativeElement;
        var self = this;
        ele.updateToolTip = function (c) {
            if (c.externalObject) {
                c = c.externalObject;
            }
            else {
                var ext = new IgxPieSliceDataContext();
                ext._implementation = c;
                c = ext;
            }
            if (ele.parentElement != self.container) {
                if (ele.parentElement != null) {
                    ele.parentElement.removeChild(ele);
                }
                self.container.appendChild(ele);
            }
            cr.instance.context = c;
            if (c.series.showDefaultTooltip) {
                var tooltipContainers = ele.getElementsByClassName("ui-tooltip-container");
                if (tooltipContainers.length > 0)
                    tooltipContainers[0].style.borderColor = c.i.slice.background.fill;
            }
            ele.style.display = "block";
            return true;
        };
        ele.hideToolTip = function () {
            ele.style.display = "none";
        };
        ele.style.display = "none";
        return cr;
    };
    Object.defineProperty(IgxDoughnutChartComponent.prototype, "allowSliceSelection", {
        /**
     * Gets or sets whether the slices can be selected.
    */
        get: function () {
            return this.i.aw;
        },
        set: function (v) {
            this.i.aw = ensureBool(v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgxDoughnutChartComponent.prototype, "isSurfaceInteractionDisabled", {
        /**
         * Gets or sets whether all surface interactions with the plot area should be disabled.
        */
        get: function () {
            return this.i.ax;
        },
        set: function (v) {
            this.i.ax = ensureBool(v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgxDoughnutChartComponent.prototype, "allowSliceExplosion", {
        /**
         * Gets or sets whether the slices can be exploded.
        */
        get: function () {
            return this.i.av;
        },
        set: function (v) {
            this.i.av = ensureBool(v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgxDoughnutChartComponent.prototype, "innerExtent", {
        /**
         * Gets or sets the inner extent of the doughnut chart. It is percent from the outer ring's radius.
        */
        get: function () {
            return this.i.a3;
        },
        set: function (v) {
            this.i.a3 = +v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgxDoughnutChartComponent.prototype, "selectedSliceFill", {
        /**
         * Gets or sets the fill brush.
        */
        get: function () {
            return this.i.cg ? this.i.cg.fill : null;
        },
        set: function (v) {
            this.ensureSelectedStyle();
            this.i.cg.fill = v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgxDoughnutChartComponent.prototype, "selectedSliceStroke", {
        /**
         * Gets or sets the stroke brush.
        */
        get: function () {
            return this.i.cg ? this.i.cg.stroke : null;
        },
        set: function (v) {
            this.ensureSelectedStyle();
            this.i.cg.stroke = v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgxDoughnutChartComponent.prototype, "selectedSliceStrokeThickness", {
        /**
         * Gets or sets the stroke thickness.
        */
        get: function () {
            return this.i.cg ? this.i.cg.strokeThickness : NaN;
        },
        set: function (v) {
            this.ensureSelectedStyle();
            this.i.cg.strokeThickness = +v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgxDoughnutChartComponent.prototype, "selectedSliceOpacity", {
        /**
         * Gets or sets the opacity.
        */
        get: function () {
            return this.i.cg ? this.i.cg.opacity : NaN;
        },
        set: function (v) {
            this.ensureSelectedStyle();
            this.i.cg.opacity = +v;
        },
        enumerable: false,
        configurable: true
    });
    IgxDoughnutChartComponent.prototype.ensureSelectedStyle = function () {
        if (this.i.cg) {
            return;
        }
        this.i.cg = new Style();
    };
    Object.defineProperty(IgxDoughnutChartComponent.prototype, "pixelScalingRatio", {
        /**
         * Gets or sets the scaling value used to affect the pixel density of the control.
         * A higher scaling ratio will produce crisper visuals at the expense of memory.  Lower values will cause the control
         * to appear blurry.
        */
        get: function () {
            return this.i.a4;
        },
        set: function (v) {
            this.i.a4 = +v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgxDoughnutChartComponent.prototype, "actualPixelScalingRatio", {
        /**
         * Resolved pixel scaling ratio. Unless explicitly overridden by the
         * IgxDoughnutChart.PixelScalingRatioComponent property,
         * this one returns the default ratio enforced by device. High resolution devices will initialize this property
         * to a higher value.
        */
        get: function () {
            return this.i.a1;
        },
        set: function (v) {
            this.i.a1 = +v;
        },
        enumerable: false,
        configurable: true
    });
    IgxDoughnutChartComponent.prototype.findByName = function (name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        if (this.series != null && this.series.findByName && this.series.findByName(name)) {
            return this.series.findByName(name);
        }
        return null;
    };
    Object.defineProperty(IgxDoughnutChartComponent.prototype, "hasUserValues", {
        get: function () {
            return this._hasUserValues;
        },
        enumerable: false,
        configurable: true
    });
    IgxDoughnutChartComponent.prototype.__m = function (propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    };
    IgxDoughnutChartComponent.prototype._styling = function (container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        var genericPrefix = "";
        var typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("DoughnutChartComponent");
        var additionalPrefixes = [];
        var prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        var b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            var basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            var parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            var parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    };
    /**
 * Called by the UI framework to provide a UI container for rendering this control.

* @param container  * The UI container element.
*/
    IgxDoughnutChartComponent.prototype.provideContainer = function (container) {
        this.i.provideContainer(container);
    };
    /**
     * Called when the control has been resized.
    
    */
    IgxDoughnutChartComponent.prototype.notifyResized = function () {
        this.i.notifyResized();
    };
    /**
     * Gets the ID of the UI container.
    
    */
    IgxDoughnutChartComponent.prototype.getContainerID = function () {
        var iv = this.i.bd();
        return (iv);
    };
    /**
     * Gets the center coordinates of the doughnut chart's center presenter.
    
    */
    IgxDoughnutChartComponent.prototype.getCenterCoordinates = function () {
        var iv = this.i.cf();
        return fromPoint(iv);
    };
    /**
     * Gets the hole radius of the doughnut chart's center presenter.
    
    */
    IgxDoughnutChartComponent.prototype.getHoleRadius = function () {
        var iv = this.i.a2();
        return (iv);
    };
    /**
     * Use to force the doughnut chart to finish any deferred work before printing or evaluating its visual.
     * This should only be called if the visual of the doughnut chart needs to be synchronously saved or evaluated.
     * Calling this method too often will hinder the performance of the doughnut chart.
    
    */
    IgxDoughnutChartComponent.prototype.flush = function () {
        this.i.bk();
    };
    /**
     * Returns the chart visuals expressed as a serialized string.
    
    */
    IgxDoughnutChartComponent.prototype.exportSerializedVisualData = function () {
        var iv = this.i.bc();
        return (iv);
    };
    IgxDoughnutChartComponent.prototype.notifyInsertItem = function (source_, index, newItem) {
        this.i.bm(source_, index, newItem);
    };
    IgxDoughnutChartComponent.prototype.notifySetItem = function (source_, index, oldItem, newItem) {
        this.i.bp(source_, index, oldItem, newItem);
    };
    /**
     * Used to manually notify the chart that the data source has reset or cleared its items.
    
    */
    IgxDoughnutChartComponent.prototype.notifyClearItems = function (source_) {
        this.i.bl(source_);
    };
    IgxDoughnutChartComponent.prototype.notifyRemoveItem = function (source_, index, oldItem) {
        this.i.bn(source_, index, oldItem);
    };
    Object.defineProperty(IgxDoughnutChartComponent.prototype, "sliceClick", {
        /**
         * Raised when the slice is clicked.
        */
        get: function () {
            var _this = this;
            if (this._sliceClick == null) {
                this._sliceClick = new EventEmitter();
                this.i.sliceClick = delegateCombine(this.i.sliceClick, function (o, e) {
                    _this._runInZone(function () {
                        var outerArgs = new IgxSliceClickEventArgs();
                        outerArgs._provideImplementation(e);
                        if (_this.beforeSliceClick) {
                            _this.beforeSliceClick(_this, outerArgs);
                        }
                        _this._sliceClick.emit({
                            sender: _this,
                            args: outerArgs
                        });
                    });
                });
            }
            return this._sliceClick;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgxDoughnutChartComponent.prototype, "holeDimensionsChanged", {
        /**
         * Raised when the dimensions (center point or radius) of the doughnut hole change.
        */
        get: function () {
            var _this = this;
            if (this._holeDimensionsChanged == null) {
                this._holeDimensionsChanged = new EventEmitter();
                this.i.holeDimensionsChanged = delegateCombine(this.i.holeDimensionsChanged, function (o, e) {
                    _this._runInZone(function () {
                        var outerArgs = new IgxHoleDimensionsChangedEventArgs();
                        outerArgs._provideImplementation(e);
                        if (_this.beforeHoleDimensionsChanged) {
                            _this.beforeHoleDimensionsChanged(_this, outerArgs);
                        }
                        _this._holeDimensionsChanged.emit({
                            sender: _this,
                            args: outerArgs
                        });
                    });
                });
            }
            return this._holeDimensionsChanged;
        },
        enumerable: false,
        configurable: true
    });
    IgxDoughnutChartComponent.prototype._runInZone = function (act) {
        if (this._zoneRunner != null) {
            this._zoneRunner(act);
        }
        else {
            act();
        }
    };
    IgxDoughnutChartComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: IgxDoughnutChartComponent, deps: [{ token: i0.Renderer2 }, { token: i0.ViewContainerRef }, { token: i0.NgZone }, { token: i0.Injector }, { token: i0.ComponentFactoryResolver }], target: i0.ɵɵFactoryTarget.Component });
    IgxDoughnutChartComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: IgxDoughnutChartComponent, selector: "igx-doughnut-chart", inputs: { height: "height", width: "width", allowSliceSelection: "allowSliceSelection", isSurfaceInteractionDisabled: "isSurfaceInteractionDisabled", allowSliceExplosion: "allowSliceExplosion", innerExtent: "innerExtent", selectedSliceFill: "selectedSliceFill", selectedSliceStroke: "selectedSliceStroke", selectedSliceStrokeThickness: "selectedSliceStrokeThickness", selectedSliceOpacity: "selectedSliceOpacity", pixelScalingRatio: "pixelScalingRatio", actualPixelScalingRatio: "actualPixelScalingRatio" }, outputs: { sliceClick: "sliceClick", holeDimensionsChanged: "holeDimensionsChanged" }, host: { classAttribute: "ig-doughnut-chart igx-doughnut-chart" }, providers: [], queries: [{ propertyName: "contentSeries", predicate: IgxRingSeriesBaseComponent }], viewQueries: [{ propertyName: "_dynamicContent", first: true, predicate: ["dynamicContent"], descendants: true, read: ViewContainerRef, static: true }], ngImport: i0, template: "<ng-container #dynamicContent></ng-container>", isInline: true, styles: ["\n\t\t:host {\n\t\t\tdisplay: block;\n\t\t}\n\t"], changeDetection: i0.ChangeDetectionStrategy.OnPush });
    return IgxDoughnutChartComponent;
}());
export { IgxDoughnutChartComponent };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: IgxDoughnutChartComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'igx-doughnut-chart',
                    template: "<ng-container #dynamicContent></ng-container>",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [],
                    host: { 'class': 'ig-doughnut-chart igx-doughnut-chart' },
                    styles: ["\n\t\t:host {\n\t\t\tdisplay: block;\n\t\t}\n\t"]
                }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }, { type: i0.ViewContainerRef }, { type: i0.NgZone }, { type: i0.Injector }, { type: i0.ComponentFactoryResolver }]; }, propDecorators: { contentSeries: [{
                type: ContentChildren,
                args: [IgxRingSeriesBaseComponent]
            }], _dynamicContent: [{
                type: ViewChild,
                args: ["dynamicContent", { read: ViewContainerRef, static: true }]
            }], height: [{
                type: Input
            }], width: [{
                type: Input
            }], allowSliceSelection: [{
                type: Input
            }], isSurfaceInteractionDisabled: [{
                type: Input
            }], allowSliceExplosion: [{
                type: Input
            }], innerExtent: [{
                type: Input
            }], selectedSliceFill: [{
                type: Input
            }], selectedSliceStroke: [{
                type: Input
            }], selectedSliceStrokeThickness: [{
                type: Input
            }], selectedSliceOpacity: [{
                type: Input
            }], pixelScalingRatio: [{
                type: Input
            }], actualPixelScalingRatio: [{
                type: Input
            }], sliceClick: [{
                type: Output
            }], holeDimensionsChanged: [{
                type: Output
            }] } });
