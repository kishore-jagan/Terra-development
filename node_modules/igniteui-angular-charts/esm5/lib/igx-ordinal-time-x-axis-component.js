import { __extends } from "tslib";
import { Component, forwardRef, Input, ChangeDetectionStrategy } from '@angular/core';
import { TimeAxisLabellingMode_$type } from "./TimeAxisLabellingMode";
import { IgxTimeAxisLabelFormatCollection } from "./igx-time-axis-label-format-collection";
import { IgxCategoryXAxisComponent } from "./igx-category-x-axis-component";
import { IgxCategoryAxisBaseComponent } from "./igx-category-axis-base-component";
import { IgxAxisComponent } from "./igx-axis-component";
import { OrdinalTimeXAxis } from "./OrdinalTimeXAxis";
import { ensureEnum } from "igniteui-angular-core";
import { TimeAxisLabelFormatCollection as TimeAxisLabelFormatCollection_internal } from "./TimeAxisLabelFormatCollection";
import { TimeAxisLabelFormat } from "./TimeAxisLabelFormat";
import { SyncableObservableCollection$1 } from "igniteui-angular-core";
import * as i0 from "@angular/core";
/**
 * A horizontal axis that uses an ordinal DateTime scale.
 * On an ordinal time axis, datapoints are aligned according to their order in the ItemsSource, like a category axis.
*
* You can use the `OrdinalTimeXAxis` to display dates at equidistant.
*
* ```html
* <igx-data-chart
*     [dataSource]="data">
*     <igx-ordinal-time-x-axis
* 		dateTimeMemberPath="date"
* 		#xAxis>
*     </igx-ordinal-time-x-axis>
* </igx-data-chart>
* ```
*
* ```ts
* let xAxis = new IgxOrdinalTimeXAxisComponent();
* xAxis.dataTimeMemberPath="date";
* this.chart.axes.add(xAxis);
* ```
*
* ```ts
* this.series.xAxis = this.ordinalTimeXAxis;
* this.series.yAxis = this.numericYAxis;
* this.series.xAxisName = "xAxis";
* this.series.yAxisName = "YAxis";
* ```
*/
var IgxOrdinalTimeXAxisComponent = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(IgxOrdinalTimeXAxisComponent, _super);
    function IgxOrdinalTimeXAxisComponent() {
        var _this = _super.call(this) || this;
        _this._labelFormats = null;
        return _this;
    }
    IgxOrdinalTimeXAxisComponent.prototype.createImplementation = function () {
        return new OrdinalTimeXAxis();
    };
    Object.defineProperty(IgxOrdinalTimeXAxisComponent.prototype, "i", {
        /**
                                     * @hidden
                                     */
        get: function () {
            return this._implementation;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgxOrdinalTimeXAxisComponent.prototype, "dateTimeMemberPath", {
        /**
         * Gets or sets the DateTime mapping property for the axis.
        */
        get: function () {
            return this.i.dateTimeMemberPath;
        },
        set: function (v) {
            this.i.dateTimeMemberPath = v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgxOrdinalTimeXAxisComponent.prototype, "labellingMode", {
        /**
         * Gets or sets the labelling mode to use when the automatic label formats are applied.
        */
        get: function () {
            return this.i.nn;
        },
        set: function (v) {
            this.i.nn = ensureEnum(TimeAxisLabellingMode_$type, v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgxOrdinalTimeXAxisComponent.prototype, "isOrdinal", {
        /**
         * Gets or sets if the current axis is of ordinal axis type
        */
        get: function () {
            return this.i.ck;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgxOrdinalTimeXAxisComponent.prototype, "labelFormats", {
        /**
         * A list of axis label formats to apply, which are selected according to the visible axis range.
         * The label format selected will be the one with the largest range smaller than the visible range of the axis.
        *
        * You can use the `LabelFormats` for adjusting the labels depending on the range of the time shown by the chart.
        *
        * ```ts
        * let labelFormat = new TimeAxisLabelFormat();
        * labelFormat.format = "hh:mm:ss";
        * labelFormat.range = 1000;
        * this.xAxis.labelFormats.add(labelFormat);
        * labelFormat = new TimeAxisLabelFormat();
        * labelFormat.format = "hh:mm";
        * labelFormat.range = 60 * 1000;
        * this.xAxis.labelFormats.add(labelFormat);
        * labelFormat = new TimeAxisLabelFormat();
        * labelFormat.format = "MMM-dd-yy";
        * labelFormat.range = 24 * 60 * 60 * 1000;
        * this.xAxis.labelFormats.add(labelFormat);
        * labelFormat = new TimeAxisLabelFormat();
        * labelFormat.format = "MMM yy";
        * labelFormat.range = 365.24 * 24 * 60 * 60 * 1000;
        * this.xAxis.labelFormats.add(labelFormat);
        * labelFormat = new TimeAxisLabelFormat();
        * labelFormat.format = "yyyy";
        * labelFormat.range = 5 * 365 * 24 * 60 * 60 * 1000;
        * this.xAxis.labelFormats.add(labelFormat);
        * ```
        *
        * ```html
        * <igx-data-chart
        *     [dataSource]="data">
        * 	<igx-ordinal-time-x-axis
        * 		[labelFormats]="labelFormats"
        * 		dateTimeMemberPath="time"
        * 		#xAxis>
        *     </igx-ordinal-time-x-axis>
        * </igx-data-chart>
        * ```
        */
        get: function () {
            if (this._labelFormats === null) {
                var coll = new IgxTimeAxisLabelFormatCollection();
                var innerColl = this.i.nl;
                if (!innerColl) {
                    innerColl = new TimeAxisLabelFormatCollection_internal();
                }
                this._labelFormats = coll._fromInner(innerColl);
            }
            return this._labelFormats;
        },
        set: function (v) {
            if (this._labelFormats !== null) {
                this._labelFormats._setSyncTarget(null);
                this._labelFormats = null;
            }
            var coll = new IgxTimeAxisLabelFormatCollection();
            this._labelFormats = coll._fromOuter(v);
            var syncColl = new SyncableObservableCollection$1(TimeAxisLabelFormat.$type);
            var innerColl = this.i.nl;
            if (!innerColl) {
                innerColl = new TimeAxisLabelFormatCollection_internal();
            }
            syncColl._inner = innerColl;
            syncColl.clear();
            this._labelFormats._setSyncTarget(syncColl);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgxOrdinalTimeXAxisComponent.prototype, "minimumValue", {
        /**
         * Sets the minimum DateTime value to be displayed on this axis.
         * This property can be used to constrain the items displayed on the axis, within the range of DateTimes in the ItemsSource.  It will ignore any setting outside the actual range of data.
        */
        get: function () {
            return this.i.minimumValue;
        },
        set: function (v) {
            this.i.minimumValue = v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgxOrdinalTimeXAxisComponent.prototype, "maximumValue", {
        /**
         * Sets the maximum DateTime value to be displayed on this axis.
         * This property can be used to constrain the items displayed on the axis, within the range of DateTimes in the ItemsSource.  It will ignore any setting outside the actual range of data.
        */
        get: function () {
            return this.i.maximumValue;
        },
        set: function (v) {
            this.i.maximumValue = v;
        },
        enumerable: false,
        configurable: true
    });
    IgxOrdinalTimeXAxisComponent.prototype.findByName = function (name) {
        var baseResult = _super.prototype.findByName.call(this, name);
        if (baseResult) {
            return baseResult;
        }
        if (this.labelFormats != null && this.labelFormats.findByName && this.labelFormats.findByName(name)) {
            return this.labelFormats.findByName(name);
        }
        return null;
    };
    IgxOrdinalTimeXAxisComponent.prototype.getValueLabel = function (value) {
        var iv = this.i.ge(value);
        return (iv);
    };
    IgxOrdinalTimeXAxisComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: IgxOrdinalTimeXAxisComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    IgxOrdinalTimeXAxisComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: IgxOrdinalTimeXAxisComponent, selector: "igx-ordinal-time-x-axis", inputs: { dateTimeMemberPath: "dateTimeMemberPath", labellingMode: "labellingMode", labelFormats: "labelFormats", minimumValue: "minimumValue", maximumValue: "maximumValue" }, providers: [{ provide: IgxCategoryXAxisComponent, useExisting: forwardRef(function () { return IgxOrdinalTimeXAxisComponent; }) }, { provide: IgxCategoryAxisBaseComponent, useExisting: forwardRef(function () { return IgxOrdinalTimeXAxisComponent; }) }, { provide: IgxAxisComponent, useExisting: forwardRef(function () { return IgxOrdinalTimeXAxisComponent; }) }], usesInheritance: true, ngImport: i0, template: "", isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
    return IgxOrdinalTimeXAxisComponent;
}(IgxCategoryXAxisComponent));
export { IgxOrdinalTimeXAxisComponent };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: IgxOrdinalTimeXAxisComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'igx-ordinal-time-x-axis',
                    template: "",
                    providers: [{ provide: IgxCategoryXAxisComponent, useExisting: forwardRef(function () { return IgxOrdinalTimeXAxisComponent; }) }, { provide: IgxCategoryAxisBaseComponent, useExisting: forwardRef(function () { return IgxOrdinalTimeXAxisComponent; }) }, { provide: IgxAxisComponent, useExisting: forwardRef(function () { return IgxOrdinalTimeXAxisComponent; }) }],
                    changeDetection: ChangeDetectionStrategy.OnPush
                }]
        }], ctorParameters: function () { return []; }, propDecorators: { dateTimeMemberPath: [{
                type: Input
            }], labellingMode: [{
                type: Input
            }], labelFormats: [{
                type: Input
            }], minimumValue: [{
                type: Input
            }], maximumValue: [{
                type: Input
            }] } });
