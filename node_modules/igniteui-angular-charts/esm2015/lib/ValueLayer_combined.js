/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { AnnotationLayer } from "./AnnotationLayer";
import { ValueLayerValueMode_$type } from "./ValueLayerValueMode";
import { DependencyProperty } from "igniteui-angular-core";
import { Brush } from "igniteui-angular-core";
import { Series } from "./Series";
import { Axis } from "./Axis";
import { Base, enumGetBox, Delegate_$type, Number_$type, fromEnum, Point_$type, markType, markDep, runOn } from "igniteui-angular-core";
import { Thickness } from "igniteui-angular-core";
import { Visibility_$type } from "igniteui-angular-core";
import { ValueLayerFrame } from "./ValueLayerFrame";
import { List$1 } from "igniteui-angular-core";
import { Dictionary$2 } from "igniteui-angular-core";
import { Pool$1 } from "igniteui-angular-core";
import { AxisAnnotation } from "./AxisAnnotation";
import { AxisAnnotationFrameManager } from "./AxisAnnotationFrameManager";
import { DoubleCollection } from "igniteui-angular-core";
import { DeviceUtils } from "igniteui-angular-core";
import { Tuple$2 } from "igniteui-angular-core";
import { Path } from "igniteui-angular-core";
import { PathGeometry } from "igniteui-angular-core";
import { PathFigure } from "igniteui-angular-core";
import { LineSegment } from "igniteui-angular-core";
import { PropertyMetadata } from "igniteui-angular-core";
import { isNaN_, truncate } from "igniteui-angular-core";
import { AnnotationLayerView } from "./AnnotationLayerView";
import { Defaults } from "./Defaults";
import { TranslateTransform } from "igniteui-angular-core";
import { LineGeometry } from "igniteui-angular-core";
import { BrushUtil } from "igniteui-angular-core";
import { Color } from "igniteui-angular-core";
/**
 * @hidden
 */
export let ValueLayer = /*@__PURE__*/ (() => {
    class ValueLayer extends AnnotationLayer {
        constructor() {
            super();
            this.acq = null;
            this.z1 = null;
            this.z0 = null;
            let a = new ValueLayerFrame();
            let b = new ValueLayerFrame();
            let c = new ValueLayerFrame();
            let d = this.kb / 1000;
            this.w4 = a;
            this.w3 = b;
            this.w5 = c;
            this.ab = ValueLayer.$;
        }
        bi() {
            return new ValueLayer();
        }
        get_er() {
            return true;
        }
        cq() {
            return new ValueLayerView(this);
        }
        qx(a) {
            super.qx(a);
            this.zv = a;
        }
        gs(a) {
            if (this.zs == null) {
                return true;
            }
            if (this.zs == a) {
                return true;
            }
            return false;
        }
        get acs() {
            return new Thickness(1, this.z4, this.z6, this.z5, this.z3);
        }
        get act() {
            return new Thickness(1, this.aaa, this.aac, this.aab, this.z9);
        }
        yh(a, b) {
            if (this.zs == null || this.zs == a) {
                if (!this.a0.c) {
                    this.rn(b);
                }
            }
        }
        yj(a, b) {
            super.yj(a, b);
            let c = a;
            let d = this.zz;
            let e = this.zy;
            c.af.clear();
            c.ag.clear();
            c.ae.clear();
            c.ah.clear();
            AxisAnnotationFrameManager.b(c);
            if (this.xa(this.zs)) {
                this.abh(this.zs, c, d, e);
            }
            else {
                let f = this.zt();
                if (f == 5 || f == 4 || f == 6) {
                    let g = null;
                    let h = null;
                    let i = [NaN, NaN];
                    let j = 0;
                    for (let k of fromEnum(this.c9.series)) {
                        if (!this.xa(k)) {
                            continue;
                        }
                        let l = k.ai();
                        for (let n = 0; n < l.length; n++) {
                            let m = l[n];
                            if (!this.zx(m)) {
                                continue;
                            }
                            let o = m.cp ? 1 : 0;
                            let p = i[o];
                            let q = null;
                            if (f == 5) {
                                let r = k.i6(2, m);
                                if (!isNaN_(r) && (r > p || isNaN_(p))) {
                                    q = k;
                                }
                                p = !isNaN_(p) ? Math.max(r, p) : r;
                            }
                            else if (f == 4) {
                                let s = k.i6(1, m);
                                if (!isNaN_(s) && (s < p || isNaN_(p))) {
                                    q = k;
                                }
                                p = !isNaN_(p) ? Math.min(s, p) : s;
                            }
                            else if (f == 6) {
                                let t = k.i6(3, m);
                                q = k;
                                p = !isNaN_(p) ? p + t : t;
                            }
                            if (m.cp) {
                                h = q != null ? q : h;
                            }
                            else {
                                g = q != null ? q : g;
                            }
                            i[o] = p;
                        }
                        j++;
                    }
                    if (f == 6) {
                        i[0] = !isNaN_(i[0]) ? i[0] / j : NaN;
                        i[1] = !isNaN_(i[1]) ? i[1] / j : NaN;
                    }
                    if (g != null && !isNaN_(i[0])) {
                        let u = g.wa(i);
                        this.abi(g, { $type: Point_$type, x: u.x, y: NaN }, c, d, e);
                    }
                    if (h != null && !isNaN_(i[1])) {
                        let v = h.wa(i);
                        this.abi(h, { $type: Point_$type, x: NaN, y: v.y }, c, d, e);
                    }
                }
                else {
                    for (let w of fromEnum(this.c9.series)) {
                        if (this.xa(w)) {
                            this.abh(w, c, d, e);
                        }
                        if (w.isStacked) {
                            w.pz((x) => {
                                if (this.xa(x)) {
                                    this.abh(x, c, d, e);
                                }
                                if (x.ee) {
                                    x.px((y) => {
                                        if (this.xa(y)) {
                                            this.abh(y, c, d, e);
                                        }
                                        return true;
                                    });
                                }
                                return true;
                            });
                        }
                        if (w.ee) {
                            w.px((x) => {
                                if (this.xa(x)) {
                                    this.abh(x, c, d, e);
                                }
                                return true;
                            });
                        }
                    }
                }
            }
        }
        xa(a) {
            if (!super.xa(a)) {
                return false;
            }
            if (this.aan != null) {
                if (a.e9) {
                    let b = a.na();
                    if (!Base.equalsStatic(this.aan, b)) {
                        return false;
                    }
                }
                else {
                    if (!Base.equalsStatic(this.aan, a.name)) {
                        return false;
                    }
                }
            }
            return true;
        }
        zx(a) {
            if (!a.cj) {
                return false;
            }
            if (this.zp != null && this.zp != a) {
                return false;
            }
            if (this.aak != null && !Base.equalsStatic(this.aak, a.name)) {
                return false;
            }
            return true;
        }
        ql() {
            super.ql();
            if (!this.a0.c && !this.d1()) {
                return;
            }
            if (this.d1()) {
                this.abj(this.w5, false);
            }
            else {
                this.abj(this.w3, false);
            }
        }
        zt() {
            if (this.zu == 0) {
                return 2;
            }
            return this.zu;
        }
        wu() {
            return 3;
        }
        xh() {
            return 0.3;
        }
        xk() {
            return -0.4;
        }
        xj() {
            return 0.5;
        }
        zg() {
            return this.wr == 3 ? this.acr() : null;
        }
        zh() {
            return this.ws == 3 ? this.acr() : null;
        }
        acr() {
            if (this.acq == null) {
                this.acq = new DoubleCollection();
                this.acq.add(DeviceUtils.g(5));
                this.acq.add(DeviceUtils.g(5));
            }
            return this.acq;
        }
        abi(a, b, c, d, e) {
            let f = false;
            let g = this.u3;
            if (g == null) {
                g = this.u9;
            }
            if (g == null) {
                g = a.u3;
                f = true;
            }
            let h = false;
            let i = this.ack;
            if (i == null) {
                if (this.u9 != null) {
                    i = this.u9;
                }
                else {
                    i = a.u3;
                    h = true;
                }
            }
            let j = false;
            let k = this.acn;
            if (k == null) {
                if (this.u9 != null) {
                    k = this.u9;
                }
                else {
                    k = a.u3;
                    j = true;
                }
            }
            let l = g;
            let m = g;
            let n = i;
            let o = k;
            if (this.aci != null) {
                l = this.aci;
            }
            else if (f) {
                switch (this.wr) {
                    case 1:
                        l = this.zv.ce(l, this.xe);
                        break;
                    case 2:
                        l = this.zv.cg(l, this.xe);
                        break;
                    case 4:
                        l = this.zv.cf(l, this.xe);
                        break;
                }
            }
            if (this.acj != null) {
                m = this.acj;
            }
            else if (f) {
                switch (this.ws) {
                    case 1:
                        m = this.zv.ce(m, this.xg);
                        break;
                    case 2:
                        m = this.zv.cg(m, this.xg);
                        break;
                    case 4:
                        m = this.zv.cf(m, this.xg);
                        break;
                }
            }
            if (h) {
                switch (this.ws) {
                    case 1:
                        n = this.zv.ce(n, this.xg);
                        break;
                    case 2:
                        n = this.zv.cg(n, this.xg);
                        break;
                }
            }
            if (j) {
                switch (this.wr) {
                    case 1:
                        o = this.zv.ce(o, this.xe);
                        break;
                    case 2:
                        o = this.zv.cg(o, this.xe);
                        break;
                }
            }
            c.ae.add(l);
            c.ah.add(m);
            c.af.add(b.y);
            c.ag.add(b.x);
            if (this.zw) {
                AxisAnnotationFrameManager.c(c, b, a, this.c9, this.getEffectiveViewport(), g, n, this.z2, this.acm, this.acl, this.acs, this.z7, o, this.z8, this.acp, this.aco, this.act, this.aad, this.acv == 0, this.acu == 0);
            }
        }
        abh(a, b, c, d) {
            let e = { $type: Point_$type, x: NaN, y: NaN };
            let f = this.zt();
            switch (f) {
                case 5:
                    e = a.v9(2);
                    break;
                case 4:
                    e = a.v9(1);
                    break;
                case 6:
                    e = a.v9(3);
                    break;
                default:
                    e = a.v9(f);
                    break;
            }
            let i = a.ai();
            for (let h = 0; h < i.length; h++) {
                let g = i[h];
                if (!this.zx(g)) {
                    continue;
                }
                if (g.cp) {
                    this.abi(a, { $type: Point_$type, x: NaN, y: e.y }, b, c, d);
                }
                else {
                    this.abi(a, { $type: Point_$type, x: e.x, y: NaN }, b, c, d);
                }
            }
        }
        abj(a, b) {
            let c = false;
            if (this.z0 == null) {
                c = true;
                this.z1 = new List$1(Axis.$, 0);
                this.z0 = new Dictionary$2(Axis.$, Pool$1.$.specialize(AxisAnnotation.$), 0);
            }
            AxisAnnotationFrameManager.d(this, a, c, this.z0, this.z1, b, this.aae, this.aaf, this.zq, this.zr);
        }
        abg(a, b, c, d, e) {
            let f = a.item(b);
            b++;
            if (e) {
                f._stroke = d.ah._inner[c];
                f._fill = d.ah._inner[c];
            }
            else {
                f._stroke = d.ae._inner[c];
                f._fill = d.ae._inner[c];
            }
            f.ad = this.ic;
            f.ai = e ? this.zf : this.ze;
            f.am = this.vz;
            f.al = this.vy;
            f.ak = this.vy;
            f.aj = this.vx;
            f.ac = this.jf;
            return new Tuple$2(Path.$, Number_$type, f, b);
        }
        ym(a, b) {
            super.ym(a, b);
            let c = this.zv.b8;
            let d = a;
            let e = d.af.count;
            let f = 0;
            let g = b.bx.left;
            let h = b.bx.right;
            let i = b.bx.top;
            let j = b.bx.bottom;
            let k = this.acv == 0;
            let l = this.acu == 0;
            for (let m = 0; m < e; m++) {
                let n = Math.floor(d.af._inner[m]);
                let o = Math.floor(d.ag._inner[m]);
                let p = null;
                if (k) {
                    if (!isNaN_(o)) {
                        let q = this.abg(c, f, m, d, true);
                        p = q.c;
                        f = q.d;
                        let r = new PathGeometry();
                        let s = new PathFigure();
                        s._startPoint = { $type: Point_$type, x: o, y: i };
                        let t = new LineSegment(1);
                        t.c = { $type: Point_$type, x: o, y: j };
                        s._segments.add(t);
                        r.c.add(s);
                        p.an = r;
                    }
                }
                if (l) {
                    if (!isNaN_(n)) {
                        let u = this.abg(c, f, m, d, false);
                        p = u.c;
                        f = u.d;
                        let v = new PathGeometry();
                        let w = new PathFigure();
                        w._startPoint = { $type: Point_$type, x: g, y: n };
                        let x = new LineSegment(1);
                        x.c = { $type: Point_$type, x: h, y: n };
                        w._segments.add(x);
                        v.c.add(w);
                        p.an = v;
                    }
                }
            }
            c.count = f;
            if (this.d1()) {
                this.abj(this.w5, true);
            }
            else {
                this.abj(this.w3, false);
            }
        }
        f8() {
            return true;
        }
        q5(a, b, c, d) {
            super.q5(a, b, c, d);
            switch (b) {
                case "SeriesViewer":
                    if (d == null) {
                        if (this.z0 != null && this.z0.count > 0) {
                            let e;
                            if (this.d1()) {
                                e = this.w5;
                            }
                            else {
                                e = this.w3;
                            }
                            AxisAnnotationFrameManager.b(e);
                            AxisAnnotationFrameManager.d(this, e, true, this.z0, this.z1, true, this.aae, this.aaf, this.zq, this.zr);
                        }
                    }
                    break;
                case ValueLayer.$$p[1]:
                    this.rn(true);
                    break;
                case ValueLayer.$$p[11]:
                    this.rn(true);
                    break;
                case ValueLayer.$$p[6]:
                case ValueLayer.$$p[7]:
                case "Visibility":
                    this.rn(true);
                    break;
                case ValueLayer.$$p[2]:
                case ValueLayer.$$p[13]:
                case ValueLayer.$$p[12]:
                case ValueLayer.$$p[16]:
                case ValueLayer.$$p[18]:
                case ValueLayer.$$p[20]:
                case ValueLayer.$$p[19]:
                case ValueLayer.$$p[17]:
                case ValueLayer.$$p[21]:
                case ValueLayer.$$p[22]:
                case ValueLayer.$$p[24]:
                case ValueLayer.$$p[27]:
                case ValueLayer.$$p[29]:
                case ValueLayer.$$p[31]:
                case ValueLayer.$$p[30]:
                case ValueLayer.$$p[28]:
                case ValueLayer.$$p[32]:
                case ValueLayer.$$p[33]:
                case ValueLayer.$$p[0]:
                case ValueLayer.$$p[10]:
                case ValueLayer.$$p[8]:
                    this.rn(true);
                    break;
            }
        }
        o3(a, b) {
            super.o3(a, b);
            if (a) {
                AxisAnnotationFrameManager.b(this.w3);
                this.abj(this.w3, false);
            }
        }
    }
    ValueLayer.$t = markType(ValueLayer, 'ValueLayer', AnnotationLayer.$);
    ValueLayer.$$p = markDep(DependencyProperty, PropertyMetadata, ValueLayer, 'raisePropertyChanged', ['HorizontalLineStroke:aci:abk', [Brush.$, null], 'HorizontalLineVisibility:acu:abl', [Visibility_$type, enumGetBox(Visibility_$type, 0)], 'IsAxisAnnotationEnabled:zw:abm', [0, false], 'SkipUnknownValues:zy:abn', [0, true], 'TargetAxisName:aak:abo', [2, null], 'TargetAxis:zp:abp', [Axis.$, null], 'TargetSeriesName:aan:abq', [2, null], 'TargetSeries:zs:abr', [Series.$, null], 'UseInterpolation:zz:abs', [0, true], 'ValueMode:zu:abt', [ValueLayerValueMode_$type, enumGetBox(ValueLayerValueMode_$type, 2)], 'VerticalLineStroke:acj:abu', [Brush.$, null], 'VerticalLineVisibility:acv:abv', [Visibility_$type, enumGetBox(Visibility_$type, 0)], 'XAxisAnnotationBackgroundCornerRadius:z2:abw', [1, DeviceUtils.g(3)], 'XAxisAnnotationBackground:ack:abx', [Brush.$, null], 'XAxisAnnotationFormatLabel:zq:aby', [Delegate_$type], 'XAxisAnnotationInterpolatedValuePrecision:aae:abz', [1, -1], 'XAxisAnnotationOutline:acl:ab0', [Brush.$, null], 'XAxisAnnotationPaddingBottom:z3:ab1', [1, NaN], 'XAxisAnnotationPaddingLeft:z4:ab2', [1, NaN], 'XAxisAnnotationPaddingRight:z5:ab3', [1, NaN], 'XAxisAnnotationPaddingTop:z6:ab4', [1, NaN], 'XAxisAnnotationStrokeThickness:z7:ab5', [1, NaN], 'XAxisAnnotationTextColor:acm:ab6', [Brush.$, null], 'YAxisAnnotationBackgroundCornerRadius:z8:ab7', [1, DeviceUtils.g(3)], 'YAxisAnnotationBackground:acn:ab8', [Brush.$, null], 'YAxisAnnotationFormatLabel:zr:ab9', [Delegate_$type], 'YAxisAnnotationInterpolatedValuePrecision:aaf:aca', [1, -1], 'YAxisAnnotationOutline:aco:acb', [Brush.$, null], 'YAxisAnnotationPaddingBottom:z9:acc', [1, NaN], 'YAxisAnnotationPaddingLeft:aaa:acd', [1, NaN], 'YAxisAnnotationPaddingRight:aab:ace', [1, NaN], 'YAxisAnnotationPaddingTop:aac:acf', [1, NaN], 'YAxisAnnotationStrokeThickness:aad:acg', [1, NaN], 'YAxisAnnotationTextColor:acp:ach', [Brush.$, null]]);
    return ValueLayer;
})();
/**
 * @hidden
 */
export let ValueLayerView = /*@__PURE__*/ (() => {
    class ValueLayerView extends AnnotationLayerView {
        constructor(a) {
            super(a);
            this.b7 = null;
            this.b8 = null;
            this.b9 = null;
            this.b7 = a;
            this.b9 = new List$1(Path.$, 0);
        }
        au() {
            super.au();
            this.b8 = ((() => {
                let $ret = new Pool$1(Path.$);
                $ret.create = runOn(this, this.ch);
                $ret.activate = runOn(this, this.ca);
                $ret.disactivate = runOn(this, this.cc);
                $ret.destroy = runOn(this, this.cb);
                return $ret;
            })());
            this.b7.jn = Defaults.j;
        }
        ch() {
            let a = new Path();
            a.j = new TranslateTransform();
            this.b9.add(a);
            return a;
        }
        ca(a) {
            a._visibility = 0;
        }
        cc(a) {
            a._visibility = 1;
        }
        cb(a) {
            this.b9.remove(a);
        }
        cd(a, b, c, d) {
            if (a.an == null || a.an.c.x != d || a.an.d.x != c) {
                let e = ((() => {
                    let $ret = new LineGeometry();
                    $ret.d = { $type: Point_$type, x: c, y: b };
                    $ret.c = { $type: Point_$type, x: d, y: b };
                    return $ret;
                })());
                a.an = e;
            }
        }
        ce(a, b) {
            if (a == null) {
                return a;
            }
            return BrushUtil.m(a, b);
        }
        cg(a, b) {
            if (a == null) {
                return a;
            }
            return BrushUtil.o(a, b);
        }
        cf(a, b) {
            if (a == null) {
                return a;
            }
            let c = new Brush();
            c.color = Color.u(truncate((a.color.l * b)), a.color.o, a.color.n, a.color.m);
            return c;
        }
        a8(a, b) {
            super.a8(a, b);
            if (a.d && !b) {
                for (let c = 0; c < this.b9.count; c++) {
                    let d = this.b9._inner[c];
                    if (d._visibility == 0) {
                        a.t(d);
                    }
                }
            }
        }
        an(a) {
            super.an(a);
            for (let b = 0; b < this.b9.count; b++) {
                this.e.bb.exportPathData(a, this.b9._inner[b], "crosshairLine", ["Main", "Crosshair"]);
            }
        }
    }
    ValueLayerView.$t = markType(ValueLayerView, 'ValueLayerView', AnnotationLayerView.$);
    return ValueLayerView;
})();
