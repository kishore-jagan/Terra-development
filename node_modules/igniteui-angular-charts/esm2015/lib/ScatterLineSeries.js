/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { ScatterBase } from "./ScatterBase";
import { UnknownValuePlotting_$type } from "igniteui-angular-core";
import { DependencyProperty } from "igniteui-angular-core";
import { Point_$type, typeCast, runOn, Number_$type, enumGetBox, markType, markDep } from "igniteui-angular-core";
import { OwnedPoint } from "./OwnedPoint";
import { ScatterFrame } from "./ScatterFrame";
import { ScatterLineSeriesView } from "./ScatterLineSeriesView";
import { Defaults } from "./Defaults";
import { PathGeometry } from "igniteui-angular-core";
import { Rect } from "igniteui-angular-core";
import { ScalerParams } from "./ScalerParams";
import { Clipper } from "igniteui-angular-core";
import { List$1 } from "igniteui-angular-core";
import { RectUtil } from "igniteui-angular-core";
import { PolyLineSegment } from "igniteui-angular-core";
import { PathFigure } from "igniteui-angular-core";
import { PathFigureCollection } from "igniteui-angular-core";
import { Flattener } from "igniteui-angular-core";
import { PropertyMetadata } from "igniteui-angular-core";
import { boxArray$1, arrayShallowClone } from "igniteui-angular-core";
import { isNaN_ } from "igniteui-angular-core";
/**
 * @hidden
 */
export let ScatterLineSeries = /*@__PURE__*/ (() => {
    class ScatterLineSeries extends ScatterBase {
        constructor() {
            super();
            this.ab = ScatterLineSeries.$;
            this.yu = new ScatterFrame();
            this.yw = new ScatterFrame();
            this.ys = new ScatterFrame();
            let a = (b, c, d) => {
                let e = this.dl.indexOf(b.a);
                if (e == -1 || e == 0) {
                    return b;
                }
                let f = this.dl.item(e - 1);
                let g;
                if (!((() => { let h = c.g.tryGetValue(f, g); g = h.p1; return h.ret; })())) {
                    return b;
                }
                return g;
            };
            this.yu.o = a;
            this.yw.o = a;
            this.ys.o = a;
        }
        bi() {
            return new ScatterLineSeries();
        }
        get_fi() {
            return true;
        }
        cq() {
            return new ScatterLineSeriesView(this);
        }
        zo() {
            return true;
        }
        ji() {
            if (!isNaN_(this.jh)) {
                return super.ji();
            }
            return Defaults.x;
        }
        gu(a, b) {
            if (this.w9(a, b)) {
                return true;
            }
            if (this.acf(a, b)) {
                return true;
            }
            return false;
        }
        acf(a, b) {
            let c = this.ct;
            let d = c.dl;
            return this.gv(a, b, d.an);
        }
        aa6(a, b) {
            super.aa6(a, b);
            a.m.clear();
            a.u.clear();
            let c = b.by;
            let d = b.bx;
            let e = this.getEffectiveViewport1(b);
            let f = this.ib * this.ib;
            let g = 0;
            if (this.y9 != null) {
                g = this.y9.count;
            }
            if (this.za != null) {
                g = Math.min(this.za.count, g);
            }
            let h = new ScalerParams(0, c, d, this.yo.d, e);
            let i = ((() => {
                let $ret = new ScalerParams(0, c, d, this.yo.e, e);
                $ret.b = this.iw();
                return $ret;
            })());
            let j = arrayShallowClone(this.y9.asArray());
            let k = arrayShallowClone(this.za.asArray());
            this.xAxis.ho(boxArray$1(j), 0, j.length, h);
            this.yAxis.ho(boxArray$1(k), 0, k.length, i);
            let l = d.top - 10;
            let m = d.bottom + 10;
            let n = d.left - 10;
            let o = d.right + 10;
            let p = ((() => {
                let $ret = new Clipper(1, n, m, o, l, false);
                $ret.i = a.m;
                return $ret;
            })());
            for (let q = 0; q < g;) {
                let r = q;
                ++q;
                if (g > this.z1) {
                    while (q < g) {
                        let s = j[q] - j[r];
                        let t = k[q] - k[r];
                        let u = s * s + t * t;
                        if (isNaN_(u) || u >= f) {
                            break;
                        }
                        ++q;
                    }
                    p.j(this.acm(j, k, r, q - 1));
                }
                else {
                    let v = new OwnedPoint();
                    v.c = { $type: Point_$type, x: j[r], y: k[r] };
                    v.a = this.dl.item(r);
                    if (!a.u.containsKey(v.a)) {
                        a.u.addItem(v.a, v);
                    }
                }
            }
            if (g > this.z1) {
                p.i = null;
            }
        }
        acm(a, b, c, d) {
            if (c == d) {
                return { $type: Point_$type, x: a[c], y: b[c] };
            }
            let e = 0;
            let f = 0;
            let g = (d - c + 1);
            for (let h = c; h <= d; ++h) {
                e += a[h];
                f += b[h];
            }
            return { $type: Point_$type, x: e / g, y: f / g };
        }
        get_zi() {
            return true;
        }
        abh(a, b) {
            b.c9(false);
            super.abh(a, b);
            let c = this.getEffectiveViewport1(b);
            let d = new Rect(0, b.bx.left, b.bx.top, b.bx.width, b.bx.height);
            d = RectUtil.t(d, this.ic, this.ic);
            this.aba(a, new Clipper(0, d, false));
            let e = typeCast(ScatterLineSeriesView.$, b);
            this.y1.az(this, this.zn(), runOn(this, this.yh));
            let f = false;
            let g = this.y1.b;
            if (g != null) {
                f = true;
            }
            if (f) {
                this.aa2(-1, this.y9.count, b.q);
            }
            this.y1.ad(e.dl, true, false, true, false);
            this.ack(e.dl, a.m.count, (h) => a.m._inner[h].x, (h) => a.m._inner[h].y, this.ace, this.ib);
        }
        ack(a, b, c, d, e, f) {
            let g = new PathGeometry();
            a.an = g;
            g.c = new PathFigureCollection();
            let h = new List$1(PolyLineSegment.$, 0);
            let i = 0;
            for (let j = 0; j < b; j++) {
                if (isNaN_(c(j)) || isNaN_(d(j))) {
                    let k = j - i;
                    if (k > 0) {
                        if (e == 1 || h.count == 0) {
                            let l = new PolyLineSegment();
                            h.add(l);
                        }
                        this.acj(h._inner[h.count - 1]._points, i, j - 1, c, d, f);
                    }
                    i = j + 1;
                }
            }
            if (e == 1 || h.count == 0) {
                let m = new PolyLineSegment();
                h.add(m);
            }
            this.acj(h._inner[h.count - 1]._points, i, b - 1, c, d, f);
            for (let n = 0; n < h.count; n++) {
                let o = h._inner[n];
                if (o._points.count > 0) {
                    let p = ((() => {
                        let $ret = new PathFigure();
                        $ret.startPoint = o._points._inner[0];
                        return $ret;
                    })());
                    p._segments.add(o);
                    g.c.add(p);
                }
            }
        }
        acg(a, b, c, d, e, f) {
            let g = new List$1(Number_$type, 0);
            let h = d;
            let i = e;
            let j = i - h + 1;
            while (j > 0) {
                if (j <= 512) {
                    Flattener.c(g, b, c, h, i, f);
                    h = i + 1;
                }
                else {
                    let k = h + 512 - 1;
                    Flattener.c(g, b, c, h, k, f);
                    h = k + 1;
                }
                j = i - h + 1;
            }
            return g;
        }
        acj(a, b, c, d, e, f) {
            if (c > -1) {
                let g = !isNaN_(this.jh) ? f : 1;
                let h = this.acg(new List$1(Number_$type, 0), d, e, b, c, g);
                let i;
                for (let j = 0; j < h.count; j++) {
                    i = h.item(j);
                    a.add({ $type: Point_$type, x: d(i), y: e(i) });
                }
            }
        }
        q5(a, b, c, d) {
            super.q5(a, b, c, d);
            switch (b) {
                case ScatterLineSeries.$$p[0]:
                    this.rn(false);
                    this.qh();
                    break;
            }
        }
    }
    ScatterLineSeries.$t = markType(ScatterLineSeries, 'ScatterLineSeries', ScatterBase.$);
    ScatterLineSeries.$$p = markDep(DependencyProperty, PropertyMetadata, ScatterLineSeries, 'raisePropertyChanged', ['UnknownValuePlotting:ace:acl', [UnknownValuePlotting_$type, enumGetBox(UnknownValuePlotting_$type, 1)]]);
    return ScatterLineSeries;
})();
