import { EventEmitter, Output, Component, forwardRef, Input, ChangeDetectionStrategy } from '@angular/core';
import { delegateCombine } from "igniteui-angular-core";
import { IgxSeriesComponent } from "./igx-series-component";
import { IgxCalloutPlacementPositionsCollection } from "./igx-callout-placement-positions-collection";
import { HighlightedValueLabelMode_$type } from "igniteui-angular-core";
import { AutoCalloutVisibilityMode_$type } from "./AutoCalloutVisibilityMode";
import { CalloutCollisionMode_$type } from "igniteui-angular-core";
import { IgxCalloutStyleUpdatingEventArgs } from "./igx-callout-style-updating-event-args";
import { IgxCalloutRenderStyleUpdatingEventArgs } from "./igx-callout-render-style-updating-event-args";
import { IgxCalloutContentUpdatingEventArgs } from "./igx-callout-content-updating-event-args";
import { IgxCalloutLabelUpdatingEventArgs } from "./igx-callout-label-updating-event-args";
import { IgxCalloutSeriesSelectingEventArgs } from "./igx-callout-series-selecting-event-args";
import { IgxAnnotationLayerComponent } from "./igx-annotation-layer-component";
import { CalloutLayer } from "./CalloutLayer";
import { ensureBool, ensureEnum, brushToString, stringToBrush, arrayFindByName } from "igniteui-angular-core";
import { CalloutPlacementPositionsCollection as CalloutPlacementPositionsCollection_internal } from "./CalloutPlacementPositionsCollection";
import { CalloutPlacementPositions_$type } from "./CalloutPlacementPositions";
import { SyncableObservableCollection$1 } from "igniteui-angular-core";
import * as i0 from "@angular/core";
/**
 * Represents an annotation layer that displays crosshair lines that cross through the closest value of the target series under the cursor.
*/
export let IgxCalloutLayerComponent = /*@__PURE__*/ (() => {
    class IgxCalloutLayerComponent extends IgxAnnotationLayerComponent {
        constructor() {
            super();
            this._allowedPositions = null;
            this._calloutStyleUpdating = null;
            this._calloutRenderStyleUpdating = null;
            this._calloutContentUpdating = null;
            this._calloutLabelUpdating = null;
            this._calloutSeriesSelecting = null;
        }
        createImplementation() {
            return new CalloutLayer();
        }
        /**
                                     * @hidden
                                     */
        get i() {
            return this._implementation;
        }
        /**
         * Gets whether the series is an callout annotation layer.
        */
        get isAnnotationCalloutLayer() {
            return this.i.em;
        }
        /**
         * Gets or sets the label mapping property for the callouts.
        */
        get labelMemberPath() {
            return this.i.acr;
        }
        set labelMemberPath(v) {
            this.i.acr = v;
        }
        /**
         * Gets or sets the label mapping property for the callouts.
        */
        get xMemberPath() {
            return this.i.ac5;
        }
        set xMemberPath(v) {
            this.i.ac5 = v;
        }
        /**
         * Gets or sets the label mapping property for the callouts.
        */
        get yMemberPath() {
            return this.i.ac8;
        }
        set yMemberPath(v) {
            this.i.ac8 = v;
        }
        /**
         * Gets or sets the key mapping property for the callouts.
        */
        get keyMemberPath() {
            return this.i.acl;
        }
        set keyMemberPath(v) {
            this.i.acl = v;
        }
        /**
         * Gets or sets whether to allow the callouts to be variable distances from the target points, for suppporting collision modes.
        */
        get isCalloutOffsettingEnabled() {
            return this.i.aaw;
        }
        set isCalloutOffsettingEnabled(v) {
            this.i.aaw = ensureBool(v);
        }
        /**
         * Gets or sets the label format string to use for the label.
        */
        get labelFormat() {
            return this.i.aco;
        }
        set labelFormat(v) {
            this.i.aco = v;
        }
        /**
         * Gets or sets the format specifiers to use with the LabelFormat string.
        */
        get labelFormatSpecifiers() {
            return this.i.zq;
        }
        set labelFormatSpecifiers(v) {
            if (v && !Array.isArray(v) && typeof (v) == "string") {
                const re = /\s*(?:,|\s|$)\s*/gm;
                v = v.split(re);
            }
            this.i.zq = v;
        }
        /**
         * Gets or sets the content mapping property for the callouts.
        */
        get contentMemberPath() {
            return this.i.acd;
        }
        set contentMemberPath(v) {
            this.i.acd = v;
        }
        /**
         * Gets or sets the name of the series series to target this annotation to. If null, this annotation targets all series simultaneously.
        */
        get targetSeriesName() {
            return this.i.act;
        }
        set targetSeriesName(v) {
            this.i.act = v;
        }
        /**
         * Gets or sets the series to target this annotation to. If null, this annotation targets all series simultaneously.
        */
        get targetSeries() {
            const r = this.i.z7;
            if (r == null) {
                return null;
            }
            if (!r.externalObject) {
                let e = IgxSeriesComponent._createFromInternal(r);
                if (e) {
                    e._implementation = r;
                }
                r.externalObject = e;
            }
            return r.externalObject;
        }
        set targetSeries(v) {
            if (v != null && this._stylingContainer && v._styling)
                v._styling(this._stylingContainer, this, this);
            v == null ? this.i.z7 = null : this.i.z7 = v.i;
        }
        /**
         * Gets or sets a channel name to identify other callout layers within the chart to share collision information with.
        */
        get collisionChannel() {
            return this.i.aca;
        }
        set collisionChannel(v) {
            this.i.aca = v;
        }
        /**
         * Gets or sets the allowed positions that the callout layer is allowed to use.
        */
        get allowedPositions() {
            if (this._allowedPositions === null) {
                let coll = new IgxCalloutPlacementPositionsCollection();
                let innerColl = this.i.z2;
                if (!innerColl) {
                    innerColl = new CalloutPlacementPositionsCollection_internal();
                }
                this._allowedPositions = coll._fromInner(innerColl);
                this.i.z2 = innerColl;
            }
            return this._allowedPositions;
        }
        set allowedPositions(v) {
            if (this._allowedPositions !== null) {
                this._allowedPositions._setSyncTarget(null);
                this._allowedPositions = null;
            }
            let coll = new IgxCalloutPlacementPositionsCollection();
            this._allowedPositions = coll._fromOuter(v);
            let syncColl = new SyncableObservableCollection$1(CalloutPlacementPositions_$type);
            let innerColl = this.i.z2;
            if (!innerColl) {
                innerColl = new CalloutPlacementPositionsCollection_internal();
            }
            syncColl._inner = innerColl;
            syncColl.clear();
            this._allowedPositions._setSyncTarget(syncColl);
            this.i.z2 = innerColl;
        }
        /**
         * Gets or sets how to select the final value to annotate.
        */
        get isAutoCalloutBehaviorEnabled() {
            return this.i.aav;
        }
        set isAutoCalloutBehaviorEnabled(v) {
            this.i.aav = ensureBool(v);
        }
        /**
         * Gets or sets whether to use values, rather than labels for auto callout labels.
        */
        get useInterpolatedValueForAutoCalloutLabels() {
            return this.i.aa0;
        }
        set useInterpolatedValueForAutoCalloutLabels(v) {
            this.i.aa0 = ensureBool(v);
        }
        /**
         * Gets or sets whether to the series color as the outline of the callout.
        */
        get useSeriesColorForOutline() {
            return this.i.aa3;
        }
        set useSeriesColorForOutline(v) {
            this.i.aa3 = ensureBool(v);
        }
        /**
         * Gets or sets whether to the label color is automatically decided between a light and dark option for contrast.
        */
        get useAutoContrastingLabelColors() {
            return this.i.aaz;
        }
        set useAutoContrastingLabelColors(v) {
            this.i.aaz = ensureBool(v);
        }
        /**
         * Gets or sets whether to the series color as the outline of the callout.
        */
        get useItemColorForFill() {
            return this.i.aa1;
        }
        set useItemColorForFill(v) {
            this.i.aa1 = ensureBool(v);
        }
        /**
         * Gets or sets whether to the series item color as the outline of the callout.
        */
        get useItemColorForOutline() {
            return this.i.aa2;
        }
        set useItemColorForOutline(v) {
            this.i.aa2 = ensureBool(v);
        }
        /**
         * Gets or sets whether to use values, rather than labels for auto callout labels.
        */
        get useValueForAutoCalloutLabels() {
            return this.i.aa4;
        }
        set useValueForAutoCalloutLabels(v) {
            this.i.aa4 = ensureBool(v);
        }
        /**
         * Gets or sets whether to use values, rather than labels for auto callout labels.
        */
        get highlightedValueLabelMode() {
            return this.i.z6;
        }
        set highlightedValueLabelMode(v) {
            this.i.z6 = ensureEnum(HighlightedValueLabelMode_$type, v);
        }
        /**
         * Gets or sets the rules for when the callouts should be visible.
        */
        get autoCalloutVisibilityMode() {
            return this.i.zv;
        }
        set autoCalloutVisibilityMode(v) {
            this.i.zv = ensureEnum(AutoCalloutVisibilityMode_$type, v);
        }
        /**
         * Gets or sets the corner radius to use for the callout borders.
        */
        get calloutCornerRadius() {
            return this.i.abe;
        }
        set calloutCornerRadius(v) {
            this.i.abe = +v;
        }
        /**
         * Gets or sets whether to allow for custom callout styles.
        */
        get isCustomCalloutStyleEnabled() {
            return this.i.aay;
        }
        set isCustomCalloutStyleEnabled(v) {
            this.i.aay = ensureBool(v);
        }
        /**
         * Gets or sets whether to allow for custom callout styles.
        */
        get isCustomCalloutRenderStyleEnabled() {
            return this.i.aax;
        }
        set isCustomCalloutRenderStyleEnabled(v) {
            this.i.aax = ensureBool(v);
        }
        /**
         * Gets or sets the precision to use when values are used for the auto callout labels.
        */
        get autoCalloutLabelPrecision() {
            return this.i.abn;
        }
        set autoCalloutLabelPrecision(v) {
            this.i.abn = +v;
        }
        /**
         * Gets or sets the color to use for the callout text. Leave unset for an automatic value.
        */
        get calloutTextColor() {
            return brushToString(this.i.aey);
        }
        set calloutTextColor(v) {
            this.i.aey = stringToBrush(v);
        }
        /**
         * Gets or sets the light color to use for the callout text. Leave unset for an automatic value.
        */
        get calloutLightTextColor() {
            return brushToString(this.i.aew);
        }
        set calloutLightTextColor(v) {
            this.i.aew = stringToBrush(v);
        }
        /**
         * Gets or sets the dark color to use for the callout text. Leave unset for an automatic value.
        */
        get calloutDarkTextColor() {
            return brushToString(this.i.aeu);
        }
        set calloutDarkTextColor(v) {
            this.i.aeu = stringToBrush(v);
        }
        /**
         * Gets or sets the brush that specifies how the backgrounds for the callouts of the layer are painted. Leave unset for an automatic value.
        */
        get calloutBackground() {
            return brushToString(this.i.aet);
        }
        set calloutBackground(v) {
            this.i.aet = stringToBrush(v);
        }
        /**
         * Gets or sets the precision to use displaying values for interpolated crosshair positions.
        */
        get calloutInterpolatedValuePrecision() {
            return this.i.abo;
        }
        set calloutInterpolatedValuePrecision(v) {
            this.i.abo = +v;
        }
        /**
         * Gets or sets the brush that specifies how the outlines for the callouts of the layer are painted.
        */
        get calloutOutline() {
            return brushToString(this.i.aex);
        }
        set calloutOutline(v) {
            this.i.aex = stringToBrush(v);
        }
        /**
         * Gets or sets the brush that specifies how the leader lines for the callouts of the layer are painted.
        */
        get calloutLeaderBrush() {
            return brushToString(this.i.aev);
        }
        set calloutLeaderBrush(v) {
            this.i.aev = stringToBrush(v);
        }
        /**
         * Gets or sets the left padding to use withing the callout. Leaving this NaN will use an automatic value related to the axis label margins.
        */
        get calloutPaddingLeft() {
            return this.i.abg;
        }
        set calloutPaddingLeft(v) {
            this.i.abg = +v;
        }
        /**
         * Gets or sets the top padding to use within the callout. Leaving this NaN will use an automatic value related to the axis label margins.
        */
        get calloutPaddingTop() {
            return this.i.abi;
        }
        set calloutPaddingTop(v) {
            this.i.abi = +v;
        }
        /**
         * Gets or sets the right padding to use within the callout. Leaving this NaN will use an automatic value related to the axis label margins.
        */
        get calloutPaddingRight() {
            return this.i.abh;
        }
        set calloutPaddingRight(v) {
            this.i.abh = +v;
        }
        /**
         * Gets or sets the bottom padding to use within the callout. Leaving this NaN will use an automatic value related to the axis label margins.
        */
        get calloutPaddingBottom() {
            return this.i.abf;
        }
        set calloutPaddingBottom(v) {
            this.i.abf = +v;
        }
        /**
         * Gets or sets the strategy to use for avoiding collisions between the callouts in this layer. Leave unset for an automatic value.
        */
        get calloutCollisionMode() {
            return this.i.zx;
        }
        set calloutCollisionMode(v) {
            this.i.zx = ensureEnum(CalloutCollisionMode_$type, v);
        }
        /**
         * Gets or sets the padding to add to the callout positioning. Leave unset for an automatic value.
        */
        get calloutPositionPadding() {
            return this.i.abj;
        }
        set calloutPositionPadding(v) {
            this.i.abj = +v;
        }
        /**
         * Gets or sets the stroke thickness for the callout backing. Leave unset for an automatic value.
        */
        get calloutStrokeThickness() {
            return this.i.abk;
        }
        set calloutStrokeThickness(v) {
            this.i.abk = +v;
        }
        /**
         * Gets or sets the stroke thickness for the axis annotation backing. Leave unset for an automatic value.
        */
        get textStyle() {
            return this.i.acw;
        }
        set textStyle(v) {
            this.i.acw = v;
        }
        findByName(name) {
            var baseResult = super.findByName(name);
            if (baseResult) {
                return baseResult;
            }
            if (this.labelFormatSpecifiers != null && arrayFindByName(this.labelFormatSpecifiers, name)) {
                return arrayFindByName(this.labelFormatSpecifiers, name);
            }
            if (this.targetSeries && this.targetSeries.name && this.targetSeries.name == name) {
                return this.targetSeries;
            }
            if (this.allowedPositions != null && this.allowedPositions.findByName && this.allowedPositions.findByName(name)) {
                return this.allowedPositions.findByName(name);
            }
            return null;
        }
        _styling(container, component, parent) {
            super._styling(container, component, parent);
            this._inStyling = true;
            if (this.targetSeries && this.targetSeries._styling) {
                this.targetSeries._styling(container, component, this);
            }
            this._inStyling = false;
        }
        getItemValue(item, memberPathName) {
            let iv = this.i.ko(item, memberPathName);
            return (iv);
        }
        /**
         * Gets the value of a requested member path from the series.
        
        * @param memberPathName  * The property name of a valid member path for the series
        */
        getMemberPathValue(memberPathName) {
            let iv = this.i.mb(memberPathName);
            return (iv);
        }
        /**
         * Invalidates content of callout layer
        
        */
        invalidateCalloutContent() {
            this.i.adi();
        }
        /**
         * Event raised when updating style of callout layer
        */
        get calloutStyleUpdating() {
            if (this._calloutStyleUpdating == null) {
                this._calloutStyleUpdating = new EventEmitter();
                this.i.calloutStyleUpdating = delegateCombine(this.i.calloutStyleUpdating, (o, e) => {
                    this._runInZone(() => {
                        let outerArgs = new IgxCalloutStyleUpdatingEventArgs();
                        outerArgs._provideImplementation(e);
                        if (this.beforeCalloutStyleUpdating) {
                            this.beforeCalloutStyleUpdating(this, outerArgs);
                        }
                        this._calloutStyleUpdating.emit({
                            sender: this,
                            args: outerArgs
                        });
                    });
                });
            }
            return this._calloutStyleUpdating;
        }
        /**
         * Event raised when updating style of callout layer
        */
        get calloutRenderStyleUpdating() {
            if (this._calloutRenderStyleUpdating == null) {
                this._calloutRenderStyleUpdating = new EventEmitter();
                this.i.calloutRenderStyleUpdating = delegateCombine(this.i.calloutRenderStyleUpdating, (o, e) => {
                    this._runInZone(() => {
                        let outerArgs = new IgxCalloutRenderStyleUpdatingEventArgs();
                        outerArgs._provideImplementation(e);
                        if (this.beforeCalloutRenderStyleUpdating) {
                            this.beforeCalloutRenderStyleUpdating(this, outerArgs);
                        }
                        this._calloutRenderStyleUpdating.emit({
                            sender: this,
                            args: outerArgs
                        });
                    });
                });
            }
            return this._calloutRenderStyleUpdating;
        }
        /**
         * Raised to allow you to decide on the content for an automatically created callout.
        */
        get calloutContentUpdating() {
            if (this._calloutContentUpdating == null) {
                this._calloutContentUpdating = new EventEmitter();
                this.i.calloutContentUpdating = delegateCombine(this.i.calloutContentUpdating, (o, e) => {
                    this._runInZone(() => {
                        let outerArgs = new IgxCalloutContentUpdatingEventArgs();
                        outerArgs._provideImplementation(e);
                        if (this.beforeCalloutContentUpdating) {
                            this.beforeCalloutContentUpdating(this, outerArgs);
                        }
                        this._calloutContentUpdating.emit({
                            sender: this,
                            args: outerArgs
                        });
                    });
                });
            }
            return this._calloutContentUpdating;
        }
        /**
         * Raised to allow you to decide on the label for an automatically created callout.
        */
        get calloutLabelUpdating() {
            if (this._calloutLabelUpdating == null) {
                this._calloutLabelUpdating = new EventEmitter();
                this.i.calloutLabelUpdating = delegateCombine(this.i.calloutLabelUpdating, (o, e) => {
                    this._runInZone(() => {
                        let outerArgs = new IgxCalloutLabelUpdatingEventArgs();
                        outerArgs._provideImplementation(e);
                        if (this.beforeCalloutLabelUpdating) {
                            this.beforeCalloutLabelUpdating(this, outerArgs);
                        }
                        this._calloutLabelUpdating.emit({
                            sender: this,
                            args: outerArgs
                        });
                    });
                });
            }
            return this._calloutLabelUpdating;
        }
        /**
         * Raised to allow you to select a target series for a data bound callout.
        */
        get calloutSeriesSelecting() {
            if (this._calloutSeriesSelecting == null) {
                this._calloutSeriesSelecting = new EventEmitter();
                this.i.calloutSeriesSelecting = delegateCombine(this.i.calloutSeriesSelecting, (o, e) => {
                    this._runInZone(() => {
                        let outerArgs = new IgxCalloutSeriesSelectingEventArgs();
                        outerArgs._provideImplementation(e);
                        if (this.beforeCalloutSeriesSelecting) {
                            this.beforeCalloutSeriesSelecting(this, outerArgs);
                        }
                        this._calloutSeriesSelecting.emit({
                            sender: this,
                            args: outerArgs
                        });
                    });
                });
            }
            return this._calloutSeriesSelecting;
        }
    }
    IgxCalloutLayerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: IgxCalloutLayerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    IgxCalloutLayerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: IgxCalloutLayerComponent, selector: "igx-callout-layer", inputs: { labelMemberPath: "labelMemberPath", xMemberPath: "xMemberPath", yMemberPath: "yMemberPath", keyMemberPath: "keyMemberPath", isCalloutOffsettingEnabled: "isCalloutOffsettingEnabled", labelFormat: "labelFormat", labelFormatSpecifiers: "labelFormatSpecifiers", contentMemberPath: "contentMemberPath", targetSeriesName: "targetSeriesName", targetSeries: "targetSeries", collisionChannel: "collisionChannel", allowedPositions: "allowedPositions", isAutoCalloutBehaviorEnabled: "isAutoCalloutBehaviorEnabled", useInterpolatedValueForAutoCalloutLabels: "useInterpolatedValueForAutoCalloutLabels", useSeriesColorForOutline: "useSeriesColorForOutline", useAutoContrastingLabelColors: "useAutoContrastingLabelColors", useItemColorForFill: "useItemColorForFill", useItemColorForOutline: "useItemColorForOutline", useValueForAutoCalloutLabels: "useValueForAutoCalloutLabels", highlightedValueLabelMode: "highlightedValueLabelMode", autoCalloutVisibilityMode: "autoCalloutVisibilityMode", calloutCornerRadius: "calloutCornerRadius", isCustomCalloutStyleEnabled: "isCustomCalloutStyleEnabled", isCustomCalloutRenderStyleEnabled: "isCustomCalloutRenderStyleEnabled", autoCalloutLabelPrecision: "autoCalloutLabelPrecision", calloutTextColor: "calloutTextColor", calloutLightTextColor: "calloutLightTextColor", calloutDarkTextColor: "calloutDarkTextColor", calloutBackground: "calloutBackground", calloutInterpolatedValuePrecision: "calloutInterpolatedValuePrecision", calloutOutline: "calloutOutline", calloutLeaderBrush: "calloutLeaderBrush", calloutPaddingLeft: "calloutPaddingLeft", calloutPaddingTop: "calloutPaddingTop", calloutPaddingRight: "calloutPaddingRight", calloutPaddingBottom: "calloutPaddingBottom", calloutCollisionMode: "calloutCollisionMode", calloutPositionPadding: "calloutPositionPadding", calloutStrokeThickness: "calloutStrokeThickness", textStyle: "textStyle" }, outputs: { calloutStyleUpdating: "calloutStyleUpdating", calloutRenderStyleUpdating: "calloutRenderStyleUpdating", calloutContentUpdating: "calloutContentUpdating", calloutLabelUpdating: "calloutLabelUpdating", calloutSeriesSelecting: "calloutSeriesSelecting" }, providers: [{ provide: IgxAnnotationLayerComponent, useExisting: forwardRef(() => IgxCalloutLayerComponent) }, { provide: IgxSeriesComponent, useExisting: forwardRef(() => IgxCalloutLayerComponent) }], usesInheritance: true, ngImport: i0, template: ``, isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
    return IgxCalloutLayerComponent;
})();
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: IgxCalloutLayerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'igx-callout-layer',
                    template: ``,
                    providers: [{ provide: IgxAnnotationLayerComponent, useExisting: forwardRef(() => IgxCalloutLayerComponent) }, { provide: IgxSeriesComponent, useExisting: forwardRef(() => IgxCalloutLayerComponent) }],
                    changeDetection: ChangeDetectionStrategy.OnPush
                }]
        }], ctorParameters: function () { return []; }, propDecorators: { labelMemberPath: [{
                type: Input
            }], xMemberPath: [{
                type: Input
            }], yMemberPath: [{
                type: Input
            }], keyMemberPath: [{
                type: Input
            }], isCalloutOffsettingEnabled: [{
                type: Input
            }], labelFormat: [{
                type: Input
            }], labelFormatSpecifiers: [{
                type: Input
            }], contentMemberPath: [{
                type: Input
            }], targetSeriesName: [{
                type: Input
            }], targetSeries: [{
                type: Input
            }], collisionChannel: [{
                type: Input
            }], allowedPositions: [{
                type: Input
            }], isAutoCalloutBehaviorEnabled: [{
                type: Input
            }], useInterpolatedValueForAutoCalloutLabels: [{
                type: Input
            }], useSeriesColorForOutline: [{
                type: Input
            }], useAutoContrastingLabelColors: [{
                type: Input
            }], useItemColorForFill: [{
                type: Input
            }], useItemColorForOutline: [{
                type: Input
            }], useValueForAutoCalloutLabels: [{
                type: Input
            }], highlightedValueLabelMode: [{
                type: Input
            }], autoCalloutVisibilityMode: [{
                type: Input
            }], calloutCornerRadius: [{
                type: Input
            }], isCustomCalloutStyleEnabled: [{
                type: Input
            }], isCustomCalloutRenderStyleEnabled: [{
                type: Input
            }], autoCalloutLabelPrecision: [{
                type: Input
            }], calloutTextColor: [{
                type: Input
            }], calloutLightTextColor: [{
                type: Input
            }], calloutDarkTextColor: [{
                type: Input
            }], calloutBackground: [{
                type: Input
            }], calloutInterpolatedValuePrecision: [{
                type: Input
            }], calloutOutline: [{
                type: Input
            }], calloutLeaderBrush: [{
                type: Input
            }], calloutPaddingLeft: [{
                type: Input
            }], calloutPaddingTop: [{
                type: Input
            }], calloutPaddingRight: [{
                type: Input
            }], calloutPaddingBottom: [{
                type: Input
            }], calloutCollisionMode: [{
                type: Input
            }], calloutPositionPadding: [{
                type: Input
            }], calloutStrokeThickness: [{
                type: Input
            }], textStyle: [{
                type: Input
            }], calloutStyleUpdating: [{
                type: Output
            }], calloutRenderStyleUpdating: [{
                type: Output
            }], calloutContentUpdating: [{
                type: Output
            }], calloutLabelUpdating: [{
                type: Output
            }], calloutSeriesSelecting: [{
                type: Output
            }] } });
