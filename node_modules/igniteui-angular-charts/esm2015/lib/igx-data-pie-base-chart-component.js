import { Component, Input } from '@angular/core';
import { PieChartSweepDirection_$type } from "./PieChartSweepDirection";
import { CalloutCollisionMode_$type } from "igniteui-angular-core";
import { OthersCategoryType_$type } from "igniteui-angular-core";
import { AxisRangeBufferMode_$type } from "./AxisRangeBufferMode";
import { RadialLabelMode_$type } from "igniteui-angular-core";
import { CollisionAvoidanceType_$type } from "./CollisionAvoidanceType";
import { IgxRadialBaseChartComponent } from "./igx-radial-base-chart-component";
import { ensureEnum, brushToString, stringToBrush, ensureBool, arrayFindByName } from "igniteui-angular-core";
import * as i0 from "@angular/core";
/**
 * Represents a base class for PieBase chart control that can plot scatter data
*/
export let IgxDataPieBaseChartComponent = /*@__PURE__*/ (() => {
    class IgxDataPieBaseChartComponent extends IgxRadialBaseChartComponent {
        constructor() {
            super();
        }
        /**
                                     * @hidden
                                     */
        get i() {
            return this._implementation;
        }
        /**
         * Gets or sets the label format for the slices.
        */
        get sliceLabelFormat() {
            return this.i.ai7;
        }
        set sliceLabelFormat(v) {
            this.i.ai7 = v;
        }
        /**
         * Gets or sets the format specifiers to use with the labels for the slices.
        */
        get sliceLabelFormatSpecifiers() {
            return this.i.ago;
        }
        set sliceLabelFormatSpecifiers(v) {
            if (v && !Array.isArray(v) && typeof (v) == "string") {
                const re = /\s*(?:,|\s|$)\s*/gm;
                v = v.split(re);
            }
            this.i.ago = v;
        }
        /**
         * Gets or sets the label format for the LegendSlices.
        */
        get legendSliceLabelFormat() {
            return this.i.air;
        }
        set legendSliceLabelFormat(v) {
            this.i.air = v;
        }
        /**
         * Gets or sets the format specifiers to use with the labels for the LegendSlices.
        */
        get legendSliceLabelFormatSpecifiers() {
            return this.i.agm;
        }
        set legendSliceLabelFormatSpecifiers(v) {
            if (v && !Array.isArray(v) && typeof (v) == "string") {
                const re = /\s*(?:,|\s|$)\s*/gm;
                v = v.split(re);
            }
            this.i.agm = v;
        }
        /**
         * Gets or sets the label format for the OthersSlices.
        */
        get othersSliceLabelFormat() {
            return this.i.ai0;
        }
        set othersSliceLabelFormat(v) {
            this.i.ai0 = v;
        }
        /**
         * Gets or sets the format specifiers to use with the labels for the OthersSlices.
        */
        get othersSliceLabelFormatSpecifiers() {
            return this.i.agn;
        }
        set othersSliceLabelFormatSpecifiers(v) {
            if (v && !Array.isArray(v) && typeof (v) == "string") {
                const re = /\s*(?:,|\s|$)\s*/gm;
                v = v.split(re);
            }
            this.i.agn = v;
        }
        /**
         * Gets or sets the label format for the LegendOthersSlices.
        */
        get legendOthersSliceLabelFormat() {
            return this.i.ain;
        }
        set legendOthersSliceLabelFormat(v) {
            this.i.ain = v;
        }
        /**
         * Gets or sets the format specifiers to use with the labels for the LegendOthersSlices.
        */
        get legendOthersSliceLabelFormatSpecifiers() {
            return this.i.agl;
        }
        set legendOthersSliceLabelFormatSpecifiers(v) {
            if (v && !Array.isArray(v) && typeof (v) == "string") {
                const re = /\s*(?:,|\s|$)\s*/gm;
                v = v.split(re);
            }
            this.i.agl = v;
        }
        /**
         * Defines the percentage of the maximum radius extent to leave blank at the center of the chart. Should be
         * a value between 0.0 and 1.0.
        */
        get innerExtent() {
            return this.i.aht;
        }
        set innerExtent(v) {
            this.i.aht = +v;
        }
        /**
         * Defines the percentage of the maximum radius extent to leave blank at the center of the chart. Should be
         * a value between 0.0 and 1.0.
        */
        get sweepDirection() {
            return this.i.ag0;
        }
        set sweepDirection(v) {
            this.i.ag0 = ensureEnum(PieChartSweepDirection_$type, v);
        }
        /**
         * Defines the positioning mode of the slice labels for the pie chart.
        */
        get sliceLabelPositionMode() {
            return this.i.ags;
        }
        set sliceLabelPositionMode(v) {
            this.i.ags = ensureEnum(CalloutCollisionMode_$type, v);
        }
        /**
         * Gets or sets the light color to use for slice labels.
        */
        get lightSliceLabelColor() {
            return brushToString(this.i.ajz);
        }
        set lightSliceLabelColor(v) {
            this.i.ajz = stringToBrush(v);
        }
        /**
         * Gets or sets the Dark color to use for slice labels.
        */
        get darkSliceLabelColor() {
            return brushToString(this.i.ajy);
        }
        set darkSliceLabelColor(v) {
            this.i.ajy = stringToBrush(v);
        }
        /**
         * Gets or sets the overridden value member path to use.
        */
        get valueMemberPath() {
            return this.i.ajn;
        }
        set valueMemberPath(v) {
            this.i.ajn = v;
        }
        /**
         * Gets or sets the legend label member path to use.
        */
        get legendLabelMemberPath() {
            return this.i.ail;
        }
        set legendLabelMemberPath(v) {
            this.i.ail = v;
        }
        /**
         * Gets or sets whether to use numeric or percent-based threshold value.
        */
        get othersCategoryType() {
            return this.i.agy;
        }
        set othersCategoryType(v) {
            this.i.agy = ensureEnum(OthersCategoryType_$type, v);
        }
        /**
         * Gets or sets the threshold value that determines if slices are grouped into the Others slice.
        */
        get othersCategoryThreshold() {
            return this.i.ahu;
        }
        set othersCategoryThreshold(v) {
            this.i.ahu = +v;
        }
        /**
         * Gets or sets the label of the Others slice.
        */
        get othersCategoryText() {
            return this.i.aiw;
        }
        set othersCategoryText(v) {
            this.i.aiw = v;
        }
        /**
         * Gets or sets the overridden value member path to use.
        */
        get labelMemberPath() {
            return this.i.aij;
        }
        set labelMemberPath(v) {
            this.i.aij = v;
        }
        /**
         * Gets or sets whether the axis should favor emitting a label at the end of the scale.
        */
        get valueAxisFavorLabellingScaleEnd() {
            return this.i.ahf;
        }
        set valueAxisFavorLabellingScaleEnd(v) {
            this.i.ahf = ensureBool(v);
        }
        /**
         * Gets or sets how the numeric axis will adjust its range buffer to less closely fix the data from the series.
        */
        get valueAxisAutoRangeBufferMode() {
            return this.i.agq;
        }
        set valueAxisAutoRangeBufferMode(v) {
            this.i.agq = ensureEnum(AxisRangeBufferMode_$type, v);
        }
        /**
         * Gets or sets the frequency of displayed labels along the X-axis.
         * Gets or sets the set value is a factor that determines which labels will be hidden. For example, an interval of 2 will display every other label.
        */
        get angleAxisInterval() {
            return this.i.ahr;
        }
        set angleAxisInterval(v) {
            this.i.ahr = +v;
        }
        /**
         * Gets or sets the frequency of displayed minor lines along the X-axis.
         * Gets or sets the set value is a factor that determines how the minor lines will be displayed.
        */
        get angleAxisMinorInterval() {
            return this.i.ahs;
        }
        set angleAxisMinorInterval(v) {
            this.i.ahs = +v;
        }
        /**
         * Gets or sets the distance between each label and grid line along the Y-axis.
        */
        get valueAxisInterval() {
            return this.i.ahz;
        }
        set valueAxisInterval(v) {
            this.i.ahz = +v;
        }
        /**
         * Gets or sets whether the Y-axis should use a logarithmic scale instead of a linear one.
         * Since log(-1) is imaginary and log(0) is undefined, it is recommended to enable this property only when the Y-axis minimum is greater than zero.
        */
        get valueAxisIsLogarithmic() {
            return this.i.ahg;
        }
        set valueAxisIsLogarithmic(v) {
            this.i.ahg = ensureBool(v);
        }
        /**
         * Gets or sets the base value to use in the log function when mapping the position of data items along the Y-axis.
         * This property is effective only when ValueAxisIsLogarithmic is true.
        */
        get valueAxisLogarithmBase() {
            return this.i.ah4;
        }
        set valueAxisLogarithmBase(v) {
            this.i.ah4 = +v;
        }
        /**
         * Gets or sets the data value corresponding to the minimum value of the Y-axis.
        */
        get valueAxisMinimumValue() {
            return this.i.ah1;
        }
        set valueAxisMinimumValue(v) {
            this.i.ah1 = +v;
        }
        /**
         * Gets or sets the data value corresponding to the maximum value of the Y-axis.
        */
        get valueAxisMaximumValue() {
            return this.i.ah0;
        }
        set valueAxisMaximumValue(v) {
            this.i.ah0 = +v;
        }
        /**
         * Gets or sets the frequency of displayed minor lines along the Y-axis.
        */
        get valueAxisMinorInterval() {
            return this.i.ah2;
        }
        set valueAxisMinorInterval(v) {
            this.i.ah2 = +v;
        }
        /**
         * Gets the current minimum value for the Y-axis.
        */
        get valueAxisActualMinimum() {
            return this.i.ahy;
        }
        /**
         * Gets the current maximum value for the Y-axis.
        */
        get valueAxisActualMaximum() {
            return this.i.ahx;
        }
        /**
         * Gets or sets the extent of the chart's radius. Value between 0 and 1.
        */
        get radiusExtent() {
            return this.i.ahv;
        }
        set radiusExtent(v) {
            this.i.ahv = +v;
        }
        /**
         * Gets or sets the start angle to use for the pie chart measured in degrees from the positive x axis.
        */
        get startAngle() {
            return this.i.ahw;
        }
        set startAngle(v) {
            this.i.ahw = +v;
        }
        /**
         * Gets or sets the label of the Others slice.
        */
        get sliceLabelContentSeparator() {
            return this.i.ai5;
        }
        set sliceLabelContentSeparator(v) {
            this.i.ai5 = v;
        }
        /**
         * Gets or sets the label of the Others slice.
        */
        get sliceLabelContentMode() {
            return this.i.ag6;
        }
        set sliceLabelContentMode(v) {
            this.i.ag6 = ensureEnum(RadialLabelMode_$type, v);
        }
        /**
         * Gets or sets the label of the Others slice.
        */
        get legendSliceLabelContentMode() {
            return this.i.ag5;
        }
        set legendSliceLabelContentMode(v) {
            this.i.ag5 = ensureEnum(RadialLabelMode_$type, v);
        }
        /**
         * Gets or sets whether to favor labelling the end of the scale.
        */
        get angleAxisFavorLabellingScaleEnd() {
            return this.i.ahc;
        }
        set angleAxisFavorLabellingScaleEnd(v) {
            this.i.ahc = ensureBool(v);
        }
        /**
         * Gets or sets whether the large numbers on the Y-axis labels are abbreviated.
        */
        get valueAxisAbbreviateLargeNumbers() {
            return this.i.ahe;
        }
        set valueAxisAbbreviateLargeNumbers(v) {
            this.i.ahe = ensureBool(v);
        }
        /**
         * Gets or sets collision avoidance between markers on series that support this behaviour.
        */
        get markerCollision() {
            return this.i.agu;
        }
        set markerCollision(v) {
            this.i.agu = ensureEnum(CollisionAvoidanceType_$type, v);
        }
        findByName(name) {
            var baseResult = super.findByName(name);
            if (baseResult) {
                return baseResult;
            }
            if (this.sliceLabelFormatSpecifiers != null && arrayFindByName(this.sliceLabelFormatSpecifiers, name)) {
                return arrayFindByName(this.sliceLabelFormatSpecifiers, name);
            }
            if (this.legendSliceLabelFormatSpecifiers != null && arrayFindByName(this.legendSliceLabelFormatSpecifiers, name)) {
                return arrayFindByName(this.legendSliceLabelFormatSpecifiers, name);
            }
            if (this.othersSliceLabelFormatSpecifiers != null && arrayFindByName(this.othersSliceLabelFormatSpecifiers, name)) {
                return arrayFindByName(this.othersSliceLabelFormatSpecifiers, name);
            }
            if (this.legendOthersSliceLabelFormatSpecifiers != null && arrayFindByName(this.legendOthersSliceLabelFormatSpecifiers, name)) {
                return arrayFindByName(this.legendOthersSliceLabelFormatSpecifiers, name);
            }
            return null;
        }
    }
    IgxDataPieBaseChartComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: IgxDataPieBaseChartComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    IgxDataPieBaseChartComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: IgxDataPieBaseChartComponent, selector: "ng-component", inputs: { sliceLabelFormat: "sliceLabelFormat", sliceLabelFormatSpecifiers: "sliceLabelFormatSpecifiers", legendSliceLabelFormat: "legendSliceLabelFormat", legendSliceLabelFormatSpecifiers: "legendSliceLabelFormatSpecifiers", othersSliceLabelFormat: "othersSliceLabelFormat", othersSliceLabelFormatSpecifiers: "othersSliceLabelFormatSpecifiers", legendOthersSliceLabelFormat: "legendOthersSliceLabelFormat", legendOthersSliceLabelFormatSpecifiers: "legendOthersSliceLabelFormatSpecifiers", innerExtent: "innerExtent", sweepDirection: "sweepDirection", sliceLabelPositionMode: "sliceLabelPositionMode", lightSliceLabelColor: "lightSliceLabelColor", darkSliceLabelColor: "darkSliceLabelColor", valueMemberPath: "valueMemberPath", legendLabelMemberPath: "legendLabelMemberPath", othersCategoryType: "othersCategoryType", othersCategoryThreshold: "othersCategoryThreshold", othersCategoryText: "othersCategoryText", labelMemberPath: "labelMemberPath", valueAxisFavorLabellingScaleEnd: "valueAxisFavorLabellingScaleEnd", valueAxisAutoRangeBufferMode: "valueAxisAutoRangeBufferMode", angleAxisInterval: "angleAxisInterval", angleAxisMinorInterval: "angleAxisMinorInterval", valueAxisInterval: "valueAxisInterval", valueAxisIsLogarithmic: "valueAxisIsLogarithmic", valueAxisLogarithmBase: "valueAxisLogarithmBase", valueAxisMinimumValue: "valueAxisMinimumValue", valueAxisMaximumValue: "valueAxisMaximumValue", valueAxisMinorInterval: "valueAxisMinorInterval", radiusExtent: "radiusExtent", startAngle: "startAngle", sliceLabelContentSeparator: "sliceLabelContentSeparator", sliceLabelContentMode: "sliceLabelContentMode", legendSliceLabelContentMode: "legendSliceLabelContentMode", angleAxisFavorLabellingScaleEnd: "angleAxisFavorLabellingScaleEnd", valueAxisAbbreviateLargeNumbers: "valueAxisAbbreviateLargeNumbers", markerCollision: "markerCollision" }, usesInheritance: true, ngImport: i0, template: ``, isInline: true });
    return IgxDataPieBaseChartComponent;
})();
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: IgxDataPieBaseChartComponent, decorators: [{
            type: Component,
            args: [{
                    template: ``,
                }]
        }], ctorParameters: function () { return []; }, propDecorators: { sliceLabelFormat: [{
                type: Input
            }], sliceLabelFormatSpecifiers: [{
                type: Input
            }], legendSliceLabelFormat: [{
                type: Input
            }], legendSliceLabelFormatSpecifiers: [{
                type: Input
            }], othersSliceLabelFormat: [{
                type: Input
            }], othersSliceLabelFormatSpecifiers: [{
                type: Input
            }], legendOthersSliceLabelFormat: [{
                type: Input
            }], legendOthersSliceLabelFormatSpecifiers: [{
                type: Input
            }], innerExtent: [{
                type: Input
            }], sweepDirection: [{
                type: Input
            }], sliceLabelPositionMode: [{
                type: Input
            }], lightSliceLabelColor: [{
                type: Input
            }], darkSliceLabelColor: [{
                type: Input
            }], valueMemberPath: [{
                type: Input
            }], legendLabelMemberPath: [{
                type: Input
            }], othersCategoryType: [{
                type: Input
            }], othersCategoryThreshold: [{
                type: Input
            }], othersCategoryText: [{
                type: Input
            }], labelMemberPath: [{
                type: Input
            }], valueAxisFavorLabellingScaleEnd: [{
                type: Input
            }], valueAxisAutoRangeBufferMode: [{
                type: Input
            }], angleAxisInterval: [{
                type: Input
            }], angleAxisMinorInterval: [{
                type: Input
            }], valueAxisInterval: [{
                type: Input
            }], valueAxisIsLogarithmic: [{
                type: Input
            }], valueAxisLogarithmBase: [{
                type: Input
            }], valueAxisMinimumValue: [{
                type: Input
            }], valueAxisMaximumValue: [{
                type: Input
            }], valueAxisMinorInterval: [{
                type: Input
            }], radiusExtent: [{
                type: Input
            }], startAngle: [{
                type: Input
            }], sliceLabelContentSeparator: [{
                type: Input
            }], sliceLabelContentMode: [{
                type: Input
            }], legendSliceLabelContentMode: [{
                type: Input
            }], angleAxisFavorLabellingScaleEnd: [{
                type: Input
            }], valueAxisAbbreviateLargeNumbers: [{
                type: Input
            }], markerCollision: [{
                type: Input
            }] } });
