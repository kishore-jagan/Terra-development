/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { AnchoredCategorySeries } from "./AnchoredCategorySeries";
import { IHorizontalAnchoredCategorySeriesInteractionManager_$type } from "./IHorizontalAnchoredCategorySeriesInteractionManager";
import { DVContainer } from "igniteui-angular-core";
import { runOn, Point_$type, typeCast, EnumUtil, enumGetBox, markType, markDep } from "igniteui-angular-core";
import { CategoryAxisBase } from "./CategoryAxisBase";
import { DependencyProperty } from "igniteui-angular-core";
import { NumericYAxis } from "./NumericYAxis";
import { CategoryMode_$type } from "./CategoryMode";
import { Axis } from "./Axis";
import { Rect } from "igniteui-angular-core";
import { ScalerParams } from "./ScalerParams";
import { TrendLineType_$type } from "igniteui-angular-core";
import { CategoryTrendLineManagerFactory } from "./CategoryTrendLineManagerFactory";
import { ISortingAxis_$type } from "./ISortingAxis";
import { CategoryXAxis } from "./CategoryXAxis";
import { PropertyMetadata } from "igniteui-angular-core";
/**
 * @hidden
 */
export let HorizontalAnchoredCategorySeries = /*@__PURE__*/ (() => {
    class HorizontalAnchoredCategorySeries extends AnchoredCategorySeries {
        constructor() {
            super(...arguments);
            this.aby = null;
            this.abu = null;
            this.ab0 = null;
            this.abw = 0;
        }
        get abz() {
            if (this.aby == null) {
                this.aby = DVContainer.instance.createInstance(IHorizontalAnchoredCategorySeriesInteractionManager_$type, () => this.dp.n);
            }
            return this.aby;
        }
        o0() {
            super.o0();
            this.xAxis = null;
            this.yAxis = null;
        }
        ci() {
            return 1;
        }
        cj() {
            if (this.yAxis != null && this.yAxis.ch) {
                return 4;
            }
            return 3;
        }
        b0() {
            if (this.b1 == 0) {
                return 1;
            }
            else {
                return super.b0();
            }
        }
        yk() {
            return this.abu;
        }
        y0() {
            return this.ab0;
        }
        wj(a) {
            if (this.yl == null || this.yl.n.count == 0 || !this.hasMarkers || !this.w8()) {
                return Rect.empty;
            }
            return this.abz.d$d(this, this.yl.n, a, runOn(this, this.acc));
        }
        acc(a) {
            return this.aae.de(a);
        }
        ab4(a, b, c) {
            return this.abz.d$c(this, this.y0(), a, b, c);
        }
        aj(a) {
            return this.abz.d$a(this, this.yl.f, this.zm(this.ct), this.zn(this.ct), a);
        }
        ak(a) {
            return this.abz.d$b(this, this.yl.f, this.zm(this.ct), this.zn(this.ct), a);
        }
        gu(a, b) {
            if (this.gt(a, b)) {
                return true;
            }
            if (this.w9(a, b)) {
                return true;
            }
            return false;
        }
        getOffsetValue() {
            return this.yq.r(this.yk(), this.ct.by, this.ct.bx, this.getEffectiveViewport1(this.ct));
        }
        getCategoryWidth() {
            let a = this.getEffectiveViewport1(this.ct);
            return this.yk().getCategorySize(this.ct.by, this.ct.bx, a);
        }
        i3(a, b, c) {
            if (this.c9 == null) {
                return NaN;
            }
            let d = this.getEffectiveViewport1(this.ct);
            let e = this.yk();
            if (e == null) {
                return NaN;
            }
            let f = new ScalerParams(0, this.c9.vl, this.ct.bx, e.ch, d);
            let g = this.yq.r(e, this.c9.vl, this.ct.bx, d);
            return this.i5(this.valueColumn, a, e, f, g, runOn(this, this.zk), b, c);
        }
        j8(a, b) {
            return this.j9(a, b, this.yk(), runOn(this, this.zk), this.valueColumn);
        }
        j6(a, b) {
            return this.j7(a, b, this.yk(), runOn(this, this.zk), this.valueColumn);
        }
        im(a, b, c, d, e) {
            if (this.valueColumn == null) {
                return Number.POSITIVE_INFINITY;
            }
            return this.io(a, b, this.yk(), d, e, this.valueColumn.count, runOn(this, this.zk));
        }
        v6(a, b, c) {
            if (this.yk() == null || this.y0() == null) {
                return { $type: Point_$type, x: NaN, y: NaN };
            }
            return this.v8(a, b, c, this.yq.r(this.yk(), this.ct.by, this.ct.bx, this.getEffectiveViewport1(this.ct)), this.y0(), this.yk(), null, null, null);
        }
        fetchXAxis() {
            return this.abu;
        }
        fetchYAxis() {
            return this.ab0;
        }
        aa8(a) {
            this.xAxis = typeCast(CategoryAxisBase.$, a);
        }
        aa9(a) {
            this.yAxis = typeCast(NumericYAxis.$, a);
        }
        zg() {
            return this.ab0 != null && this.ab0.c1();
        }
        ab8(a) {
            this.abu = a;
        }
        ab9(a) {
            this.ab0 = a;
        }
        ye(a, b) {
            return this.aab(a, b, this.abu);
        }
        q5(a, b, c, d) {
            switch (b) {
                case HorizontalAnchoredCategorySeries.$$p[0]:
                    this.ab8(this.xAxis);
                    if (this.aae.c8) {
                        this.aae.c7 = CategoryTrendLineManagerFactory.a(this.aae.c7, this.abu, this.sp, this, this.dp);
                    }
                    break;
                case "TrendLineType":
                    let e = EnumUtil.getEnumValue(TrendLineType_$type, d);
                    if (e != 0) {
                        this.aae.c7 = CategoryTrendLineManagerFactory.a(this.aae.c7, this.abu, this.sp, this, this.dp);
                    }
                    break;
            }
            super.q5(a, b, c, d);
            switch (b) {
                case HorizontalAnchoredCategorySeries.$$p[0]:
                    if (c != d) {
                        this.pa(typeCast(Axis.$, c));
                        this.rd(typeCast(Axis.$, d));
                        this.ab8(this.xAxis);
                        this.yu.cw.g(this.ib);
                        this.rn(false);
                        this.qh();
                    }
                    break;
                case HorizontalAnchoredCategorySeries.$$p[1]:
                    if (c != d) {
                        this.pa(typeCast(Axis.$, c));
                        this.rd(typeCast(Axis.$, d));
                        this.ab9(this.yAxis);
                        if (this.c9 != null) {
                            this.c9.nq();
                        }
                        this.yu.cw.g(this.ib);
                        this.zg();
                        this.rn(false);
                        this.qh();
                    }
                    break;
                case "CategoryMode":
                    if (this.xAxis != null) {
                        this.xAxis.l7(true);
                    }
                    break;
            }
        }
        o9(a, b, c, d) {
            super.o9(a, b, c, d);
            if (this.abu != null && typeCast(ISortingAxis_$type, this.abu) !== null) {
                this.abu.i$i();
            }
            switch (a) {
                case 4:
                    if (this.abu != null) {
                        this.abu.c1();
                    }
                    if (this.ab0 != null && !this.ab0.c1()) {
                        this.rn(true);
                    }
                    break;
                case 1:
                    if (this.abu != null) {
                        this.abu.c1();
                    }
                    if (this.ab0 != null && !this.ab0.c1()) {
                        this.rn(true);
                    }
                    break;
                case 0:
                    if (this.abu != null) {
                        this.abu.c1();
                    }
                    if (this.ab0 != null && !this.ab0.c1()) {
                        this.rn(true);
                    }
                    break;
                case 2:
                    if (this.aau != null && this.aae.cw.d > 0 && this.ab0 != null && !this.ab0.c1()) {
                        this.rn(true);
                    }
                    break;
                case 3:
                    if (d == this.aau) {
                        if (this.abu != null) {
                            this.abu.c1();
                        }
                        if (this.ab0 != null && !this.ab0.c1()) {
                            this.rn(true);
                        }
                    }
                    break;
            }
        }
        ab2(a) {
            if (typeCast(CategoryXAxis.$, a) !== null || a.ce) {
                return true;
            }
            return false;
        }
        ab3(a) {
            if (typeCast(NumericYAxis.$, a) !== null) {
                return true;
            }
            return false;
        }
        get abx() {
            return this.abw;
        }
        set abx(a) {
            let b = this.abx;
            if (a != b) {
                this.abw = a;
                this.raisePropertyChanged("CategoryMode", enumGetBox(CategoryMode_$type, b), enumGetBox(CategoryMode_$type, this.abx));
            }
        }
        get useHighMarkerFidelity() {
            return this.zh;
        }
    }
    HorizontalAnchoredCategorySeries.$t = markType(HorizontalAnchoredCategorySeries, 'HorizontalAnchoredCategorySeries', AnchoredCategorySeries.$);
    HorizontalAnchoredCategorySeries.$$p = markDep(DependencyProperty, PropertyMetadata, HorizontalAnchoredCategorySeries, 'raisePropertyChanged', ['XAxis::aca', [CategoryAxisBase.$, null], 'YAxis::acb', [NumericYAxis.$, null]]);
    return HorizontalAnchoredCategorySeries;
})();
