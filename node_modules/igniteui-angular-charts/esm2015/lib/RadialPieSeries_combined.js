/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { AnchoredRadialSeries } from "./AnchoredRadialSeries";
import { DependencyProperty } from "igniteui-angular-core";
import { Point_$type, runOn, markType, markDep, fromEnum } from "igniteui-angular-core";
import { Defaults } from "./Defaults";
import { Pool$1 } from "igniteui-angular-core";
import { Path } from "igniteui-angular-core";
import { List$1 } from "igniteui-angular-core";
import { Rect } from "igniteui-angular-core";
import { ScalerParams } from "./ScalerParams";
import { PathGeometry } from "igniteui-angular-core";
import { ViewportUtils } from "./ViewportUtils";
import { SliceCoords } from "./SliceCoords";
import { PathFigure } from "igniteui-angular-core";
import { LineSegment } from "igniteui-angular-core";
import { ArcSegment } from "igniteui-angular-core";
import { PieSliceCollisionGeometry } from "igniteui-angular-core";
import { Size } from "igniteui-angular-core";
import { GeometryUtil } from "igniteui-angular-core";
import { MathUtil } from "igniteui-angular-core";
import { PropertyMetadata } from "igniteui-angular-core";
import { intDivide, isNaN_ } from "igniteui-angular-core";
import { AnchoredRadialSeriesView } from "./AnchoredRadialSeriesView";
import { DataContext } from "igniteui-angular-core";
/**
 * @hidden
 */
export let RadialPieSeries = /*@__PURE__*/ (() => {
    class RadialPieSeries extends AnchoredRadialSeries {
        constructor() {
            super();
            this.ade = null;
            this.adj = null;
            this.ab = RadialPieSeries.$;
        }
        bi() {
            return new RadialPieSeries();
        }
        get_fl() {
            return true;
        }
        get_fj() {
            return true;
        }
        ji() {
            if (!isNaN_(this.jh)) {
                return super.ji();
            }
            return Defaults.h;
        }
        cq() {
            return new RadialPieSeriesView(this);
        }
        qx(a) {
            super.qx(a);
            this.add = a;
        }
        get adf() {
            return this.ade;
        }
        set adf(a) {
            if (this.ade != a) {
                let b = this.adf;
                this.ade = a;
                this.raisePropertyChanged("LegendLabelColumn", b, this.adf);
            }
        }
        get adl() {
            return this.adj;
        }
        set adl(a) {
            if (this.adj != a) {
                let b = this.adj;
                this.adj = a;
                this.raisePropertyChanged("LegendLabelMemberPath", b, this.adj);
            }
        }
        preferredCategoryMode(a) {
            return a != null && a == this.yr ? 2 : 0;
        }
        o3(a, b) {
            super.o3(a, b);
            let c = b;
            if (a && c.c6 != null) {
                c.c6.count = 0;
            }
        }
        iu() {
            return this.yr.k5(this.ct.by, this.ct.bx, this.getEffectiveViewport1(this.ct));
        }
        aq(a, b) {
            let c = new List$1(Rect.$, 0);
            let d = this.ct.by;
            let e = this.ct.bx;
            let f = this.getEffectiveViewport1(this.ct);
            let g = this.wd(this.ct);
            let h = this.yw.k2(e, d, f, g);
            let i = { $type: Point_$type, x: 0.5, y: 0.5 };
            let j = this.yw;
            let k = Math.max(0, 0.5 * j.no);
            let l = k;
            l = Math.max(l, h.minLength);
            let m = this.yr.k5(d, e, f);
            let n = this.yr != null && this.yr.cl;
            let o = this.y1;
            if (this.d1()) {
                o = this.y4;
            }
            {
                if (n) {
                    m = this.zr(a, d, e, f);
                }
                if (b < 0 || b > o.f.count - 1) {
                    return null;
                }
                let p = o.f._inner[b][0];
                let q = Math.min(o.f._inner[b][2], h.maxLength);
                return this.adg(d, e, f, p - (m * 0.5), p + (m * 0.5), l, q, i);
            }
        }
        get_eb() {
            return true;
        }
        get_ab5() {
            return true;
        }
        get_abz() {
            return true;
        }
        aa2(a, b) {
            super.aa2(a, b);
            let c = b;
            let d = b.by;
            let e = b.bx;
            let f = this.getEffectiveViewport1(b);
            let g = this.wd(b);
            let h = this.yw.k2(e, d, f, g);
            let i = a.f;
            let j = this.yw;
            let k = Math.max(0, 0.5 * j.no);
            let l = k;
            l = Math.max(l, h.minLength);
            let m = this.yr.k5(d, e, f);
            let n = this.yr.cl;
            let o = { $type: Point_$type, x: 0.5, y: 0.5 };
            let p = this.adh;
            let q = this.adi;
            let r = (p > 0 && q > 0);
            let s = this.abx.count;
            this.y7.a2(this, this.zo(), runOn(this, this.yf), this.zx(b), this.zy(b));
            this.y7.r = this.adh;
            this.y7.s = this.adi;
            this.y7.k = this.adh;
            this.y7.l = this.adi;
            let t = false;
            let u = this.y7.b;
            if (u != null) {
                t = true;
            }
            let v = this.yr;
            let w = new ScalerParams(1, b.by, b.bx, v.ch);
            w.c = this.getEffectiveViewport();
            let x = 0;
            let y = 0;
            for (let z = 0; z < i.count; ++z) {
                let aa = i._inner[z][0];
                let ab = Math.min(i._inner[z][2], h.maxLength);
                let ac = i._inner[z][1];
                let ad = i._inner[z][2];
                let ae = i._inner[z][3];
                if (t) {
                    this.act(i, z, s, v, w, b.q);
                }
                if (n) {
                    if (isNaN_(aa) || isNaN_(ac) || isNaN_(ad)) {
                        continue;
                    }
                    let af = (b.cx.c + z) * b.cx.b;
                    if ((b.cx.c + z) * b.cx.b > this.yr.lh - 1) {
                        if ((af) * b.cx.b >= this.yr.lg) {
                            af = (af) - (intDivide((this.yr.lg), b.cx.b));
                        }
                    }
                    m = ae;
                    if (isNaN_(m)) {
                        continue;
                    }
                }
                let ag = c.c6.item(x);
                x++;
                let ah = this.y7.k;
                let ai = this.y7.l;
                r = (ah > 0 && ai > 0);
                let aj = null;
                if (r) {
                    aj = this.adr(d, e, f, aa - (m * 0.5), aa + (m * 0.5), l, ab, o, ah, ai);
                }
                else {
                    aj = this.ads(d, e, f, aa - (m * 0.5), aa + (m * 0.5), l, ab, o);
                }
                ag.an = aj;
                this.y7.ad(ag, false, false, false, false);
                let ak = i._inner[z][2];
                if (ak > y) {
                    y = ak;
                }
            }
            c.cz = ViewportUtils.f(y, d, e);
            c.c0 = { $type: Point_$type, x: ViewportUtils.e(o.x, d, e, f), y: ViewportUtils.i(o.y, d, e, f) };
            c.c6.count = x;
            c.db();
        }
        ads(a, b, c, d, e, f, g, h) {
            let i = SliceCoords.b(a, b, c, d, e, f, g, h);
            let j = new PathFigure();
            j._startPoint = i.d;
            j._isClosed = true;
            j._segments.add(((() => {
                let $ret = new LineSegment(1);
                $ret.c = i.f;
                return $ret;
            })()));
            j._segments.add(((() => {
                let $ret = new ArcSegment();
                $ret.e = i.h;
                $ret.f = i.n;
                $ret.d = 1;
                $ret.b = i.c;
                return $ret;
            })()));
            j._segments.add(((() => {
                let $ret = new LineSegment(1);
                $ret.c = i.j;
                return $ret;
            })()));
            j._segments.add(((() => {
                let $ret = new ArcSegment();
                $ret.e = i.d;
                $ret.f = i.m;
                $ret.d = 0;
                $ret.b = i.c;
                return $ret;
            })()));
            let k = new PathGeometry();
            k.c.add(j);
            return k;
        }
        adg(a, b, c, d, e, f, g, h) {
            let i = SliceCoords.b(a, b, c, d, e, f, g, h);
            if (isNaN_(i.n.width) || isNaN_(d) || isNaN_(e)) {
                return null;
            }
            let j = ViewportUtils.e(0.5, a, b, c);
            let k = ViewportUtils.i(0.5, a, b, c);
            return new PieSliceCollisionGeometry(j, k, i.n.width, i.m.width, d, e);
        }
        adr(a, b, c, d, e, f, g, h, i, j) {
            let k = SliceCoords.a(a, b, c, d, e, f, g, h, i, j);
            if (k == null) {
                return this.ads(a, b, c, d, e, f, g, h);
            }
            let l = new PathFigure();
            l._startPoint = k.d;
            l._isClosed = true;
            let m = ((d + ((e - d) * 0.5)) * 180 / Math.PI) + 90;
            let n = new Size(1, k.l.width * (f / g), k.l.height * (f / g));
            l._segments.add(((() => {
                let $ret = new ArcSegment();
                $ret.e = k.e;
                $ret.f = n;
                $ret.c = m;
                $ret.d = 1;
                $ret.b = false;
                return $ret;
            })()));
            l._segments.add(((() => {
                let $ret = new LineSegment(1);
                $ret.c = k.f;
                return $ret;
            })()));
            l._segments.add(((() => {
                let $ret = new ArcSegment();
                $ret.e = k.g;
                $ret.f = k.l;
                $ret.c = m;
                $ret.d = 1;
                $ret.b = false;
                return $ret;
            })()));
            l._segments.add(((() => {
                let $ret = new ArcSegment();
                $ret.e = k.h;
                $ret.f = k.n;
                $ret.d = 1;
                $ret.b = k.c;
                return $ret;
            })()));
            l._segments.add(((() => {
                let $ret = new ArcSegment();
                $ret.e = k.i;
                $ret.f = k.l;
                $ret.c = m;
                $ret.d = 1;
                $ret.b = false;
                return $ret;
            })()));
            l._segments.add(((() => {
                let $ret = new LineSegment(1);
                $ret.c = k.j;
                return $ret;
            })()));
            l._segments.add(((() => {
                let $ret = new ArcSegment();
                $ret.e = k.k;
                $ret.f = n;
                $ret.c = m;
                $ret.d = 1;
                $ret.b = false;
                return $ret;
            })()));
            l._segments.add(((() => {
                let $ret = new ArcSegment();
                $ret.e = k.d;
                $ret.f = k.m;
                $ret.d = 0;
                $ret.b = k.c;
                return $ret;
            })()));
            let o = new PathGeometry();
            o.c.add(l);
            return o;
        }
        q5(a, b, c, d) {
            super.q5(a, b, c, d);
            switch (b) {
                case RadialPieSeries.$$p[0]:
                case RadialPieSeries.$$p[1]:
                    this.qz();
                    break;
                case "FastItemsSource":
                    if (c != null) {
                        if (this.adf != null) {
                            c.deregisterColumn(this.adf);
                        }
                    }
                    if (d != null) {
                        if (this.adl != null) {
                            this.adf = this.dk(this.adl);
                        }
                    }
                    break;
                case "LegendLabelMemberPath":
                    if (this.dl != null) {
                        this.dl.deregisterColumn(this.adf);
                        this.adf = this.dk(this.adl);
                        this.pc();
                        this.pq();
                    }
                    break;
            }
        }
        wh(a) {
            let b = this.add.by;
            let c = this.add.bx;
            let d = this.getEffectiveViewport1(this.add);
            let e = this.wd(this.add);
            let f = this.yw.k2(c, b, d, e);
            let g = { $type: Point_$type, x: 0.5, y: 0.5 };
            let h = GeometryUtil.i(g, a);
            let i = this.y1.f;
            for (let j = 0; j < i.count; j++) {
                let k = i._inner[j][0];
                let l = Math.min(i._inner[j][2], f.maxLength);
                let m = i._inner[j][3];
                if (h >= k - (m * 0.5) && h <= k + (m * 0.5)) {
                    let n = Math.max(0, 0.5 * this.yw.no);
                    let o = n;
                    o = Math.max(o, f.minLength);
                    let p = SliceCoords.b(b, c, d, k - (m * 0.5), k + (m * 0.5), o, l, g);
                    let q = GeometryUtil.q({ $type: Point_$type, x: ViewportUtils.e(g.x, b, c, d), y: ViewportUtils.i(g.y, b, c, d) }, MathUtil.f(k), p.n.width);
                    let r = 1.7976931348623157E+308;
                    let s = 1.7976931348623157E+308;
                    let t = -1.7976931348623157E+308;
                    let u = -1.7976931348623157E+308;
                    r = Math.min(r, p.d.x);
                    r = Math.min(r, p.f.x);
                    r = Math.min(r, p.h.x);
                    r = Math.min(r, p.j.x);
                    r = Math.min(r, q.x);
                    s = Math.min(s, p.d.y);
                    s = Math.min(s, p.f.y);
                    s = Math.min(s, p.h.y);
                    s = Math.min(s, p.j.y);
                    s = Math.min(s, q.y);
                    t = Math.max(t, p.d.x);
                    t = Math.max(t, p.f.x);
                    t = Math.max(t, p.h.x);
                    t = Math.max(t, p.j.x);
                    t = Math.max(t, q.x);
                    u = Math.max(u, p.d.y);
                    u = Math.max(u, p.f.y);
                    u = Math.max(u, p.h.y);
                    u = Math.max(u, p.j.y);
                    u = Math.max(u, q.y);
                    return new Rect(0, r, s, t - r, u - s);
                }
            }
            return new Rect(0, 0, 0, 0, 0);
        }
        ks(a) {
            if (this.adf != null) {
                return this.adf.item(a);
            }
            return null;
        }
    }
    RadialPieSeries.$t = markType(RadialPieSeries, 'RadialPieSeries', AnchoredRadialSeries.$);
    RadialPieSeries.$$p = markDep(DependencyProperty, PropertyMetadata, RadialPieSeries, 'raisePropertyChanged', ['RadiusX:adh:adp', [1, 2], 'RadiusY:adi:adq', [1, 2]]);
    return RadialPieSeries;
})();
/**
 * @hidden
 */
export let RadialPieSeriesView = /*@__PURE__*/ (() => {
    class RadialPieSeriesView extends AnchoredRadialSeriesView {
        constructor(a) {
            super(a);
            this.c5 = null;
            this.c6 = null;
            this.c7 = null;
            this.dc = new Path();
            this.c5 = a;
            this.c6 = ((() => {
                let $ret = new Pool$1(Path.$);
                $ret.create = runOn(this, this.dd);
                $ret.activate = runOn(this, this.c8);
                $ret.disactivate = runOn(this, this.da);
                $ret.destroy = runOn(this, this.c9);
                return $ret;
            })());
        }
        au() {
            super.au();
            this.c7 = new List$1(Path.$, 0);
            if (!this.q) {
                this.cw.w2 = Defaults.c;
                this.cw.jn = Defaults.i;
            }
        }
        dd() {
            let a = ((() => {
                let $ret = new Path();
                $ret.dataContext = ((() => {
                    let $ret = new DataContext();
                    $ret.series = this.e;
                    return $ret;
                })());
                return $ret;
            })());
            this.c7.add(a);
            a._visibility = 1;
            return a;
        }
        c8(a) {
            a._visibility = 0;
        }
        da(a) {
            a._visibility = 1;
        }
        c9(a) {
            this.c7.remove(a);
        }
        bg(a, b) {
            super.bg(a, b);
            let c = a;
        }
        ac(a) {
            return this.c7._inner[a];
        }
        ab(a) {
            let b = this.c7._inner[a];
            this.dc._visibility = b._visibility;
            this.dc.an = b.an;
            let c = this.bs(a);
            this.dc._fill = c;
            this.dc._stroke = c;
            this.dc.ad = this.e.ic;
            return this.dc;
        }
        a8(a, b) {
            super.a8(a, b);
            if (a.d) {
                for (let c = 0; c < this.c7.count; c++) {
                    let d = this.aa(c, b);
                    a.t(d);
                }
            }
        }
        db() {
            this.as();
        }
        an(a) {
            super.an(a);
            let b = 0;
            for (let c of fromEnum(this.c6.a)) {
                this.e.bb.exportPathData(a, c, "slice" + b, ["Main", "Fill"]);
                b++;
            }
        }
    }
    RadialPieSeriesView.$t = markType(RadialPieSeriesView, 'RadialPieSeriesView', AnchoredRadialSeriesView.$);
    return RadialPieSeriesView;
})();
