import { Component, ChangeDetectionStrategy, EventEmitter, Output, ViewChild, ViewContainerRef, Input } from '@angular/core';
import { AngularRenderer } from "igniteui-angular-core";
import { TypeRegistrar, delegateCombine } from "igniteui-angular-core";
import { DataChartStylingDefaults } from './DataChartStylingDefaults';
import { XamFunnelChart } from './XamFunnelChart';
import { toSpinal, initializePropertiesFromCss, NamePatcher, fromBrushCollection, toBrushCollection, ensureBool, stringToBrush, brushToString, ensureEnum } from "igniteui-angular-core";
import { Visibility_$type } from "igniteui-angular-core";
import { OuterLabelAlignment_$type } from './OuterLabelAlignment';
import { FunnelSliceDisplay_$type } from './FunnelSliceDisplay';
import { IgxFunnelSliceClickedEventArgs } from './igx-funnel-slice-clicked-event-args';
import { IgxFunnelSliceEventArgs } from './igx-funnel-slice-event-args';
import { Style } from "igniteui-angular-core";
import { HighlightedValueDisplayMode_$type } from "igniteui-angular-core";
import * as i0 from "@angular/core";
/**
 * Represents a funnel chart.
*/
export let IgxFunnelChartComponent = /*@__PURE__*/ (() => {
    class IgxFunnelChartComponent {
        constructor(renderer, _elRef, ngZone, injector, componentFactoryResolver) {
            this.renderer = renderer;
            this._elRef = _elRef;
            this.ngZone = ngZone;
            this.injector = injector;
            this.componentFactoryResolver = componentFactoryResolver;
            this._root = null;
            this._dataSource = null;
            this.__p = null;
            this._hasUserValues = new Set();
            this._stylingContainer = null;
            this._stylingParent = null;
            this._inStyling = false;
            this._sliceClicked = null;
            this._sliceEnter = null;
            this._sliceLeave = null;
            this._sliceHover = null;
            this._zoneRunner = null;
            if (this._styling) {
                NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
            }
            this._zoneRunner = (act) => ngZone.run(act);
            this.container = renderer.createElement("div");
            this._implementation = this.createImplementation();
            renderer.appendChild(_elRef.element.nativeElement, this.container);
            renderer.setStyle(this.container, "display", "block");
            renderer.setStyle(this.container, "width", "100%");
            renderer.setStyle(this.container, "height", "100%");
            var root;
            root = this.container;
            if (this.container != null) {
                root = this.container;
            }
            this._root = root;
            var ren = new AngularRenderer(root, this.renderer, window.document, this.ngZone, true, DataChartStylingDefaults);
            this._wrapper = ren;
            var chart = this.i;
            this._chart = chart;
            chart.provideContainer(ren);
            this.bindData();
            chart.notifyResized();
            ren.addSizeWatcher(() => {
                this._chart.notifyResized();
            });
        }
        set height(value) {
            this._height = value;
            this.renderer.setStyle(this._elRef.element.nativeElement, "height", value);
            this._chart.notifyResized();
        }
        get height() {
            return this._height;
        }
        set width(value) {
            this._width = value;
            this.renderer.setStyle(this._elRef.element.nativeElement, "width", value);
            this._chart.notifyResized();
        }
        get width() {
            return this._width;
        }
        ngAfterContentInit() {
            this._styling(this._root, this);
            this.i.notifyResized();
        }
        ngOnDestroy() {
            this._chart.destroy();
            this._wrapper.destroy();
        }
        createImplementation() {
            return new XamFunnelChart();
        }
        createSeriesComponent(type) {
            if (TypeRegistrar.isRegistered(type)) {
                let s = TypeRegistrar.create(type);
                s.owner = this;
                s._provideRenderer(this.renderer);
                return s;
            }
            else {
                //we shouldn't get here, hopefully.
                throw Error("series type not loaded: " + type);
            }
        }
        set dataSource(value) {
            this._dataSource = value;
            this.bindData();
        }
        get dataSource() {
            return this._dataSource;
        }
        bindData() {
            if (this._chart != null && this._chart !== undefined) {
                this._chart.itemsSource = this._dataSource;
            }
        }
        /**
         * Gets or sets the legend used for the current chart.
        */
        get legend() {
            if (this.i.legend != null)
                return this.i.legend.externalObject;
        }
        set legend(v) {
            if (v != undefined && v != null)
                this.i.legend = v.i;
        }
        /**
         * @hidden
         */
        get i() {
            return this._implementation;
        } /**
                                     * @hidden
                                     */
        static _createFromInternal(internal) {
            if (!internal) {
                return null;
            }
            if (!internal.$type) {
                return null;
            }
            let name = internal.$type.name;
            let externalName = "Igx" + name + "Component";
            if (!TypeRegistrar.isRegistered(externalName)) {
                return null;
            }
            return TypeRegistrar.create(externalName);
        }
        /**
     * Gets or sets the value member path for the funnel chart.
    */
        get valueMemberPath() {
            return this.i.dv;
        }
        set valueMemberPath(v) {
            this.i.dv = v;
        }
        /**
         * Gets or sets the highlighted value member path for the funnel chart.
        */
        get highlightedValueMemberPath() {
            return this.i.cr;
        }
        set highlightedValueMemberPath(v) {
            this.i.cr = v;
        }
        /**
         * Gets the actual opacity of the primary needle while highlighting
        */
        get actualHighlightValueOpacity() {
            return this.i.bw;
        }
        set actualHighlightValueOpacity(v) {
            this.i.bw = +v;
        }
        /**
         * Gets or sets the opacity while highlighting
        */
        get highlightValueOpacity() {
            return this.i.b0;
        }
        set highlightValueOpacity(v) {
            this.i.b0 = +v;
        }
        /**
         * Gets whether and how to display the highlighted value.
        */
        get actualHighlightValueDisplayMode() {
            return this.i.a2;
        }
        set actualHighlightValueDisplayMode(v) {
            this.i.a2 = ensureEnum(HighlightedValueDisplayMode_$type, v);
        }
        /**
         * Gets or sets whether and how to display the highlighted value.
        */
        get highlightValueDisplayMode() {
            return this.i.a3;
        }
        set highlightValueDisplayMode(v) {
            this.i.a3 = ensureEnum(HighlightedValueDisplayMode_$type, v);
        }
        /**
         * Gets or sets the palette of brushes to use for coloring the slices.
        */
        get brushes() {
            return fromBrushCollection(this.i.ah);
        }
        set brushes(v) {
            this.i.ah = toBrushCollection(v);
        }
        /**
         * Gets or sets the palette of brushes to use for outlines on the slices.
        */
        get outlines() {
            return fromBrushCollection(this.i.ai);
        }
        set outlines(v) {
            this.i.ai = toBrushCollection(v);
        }
        /**
         * Gets or sets the percentage (from near 0 to 1) of space the bottom edge of the funnel should take.
        */
        get bottomEdgeWidth() {
            return this.i.by;
        }
        set bottomEdgeWidth(v) {
            this.i.by = +v;
        }
        /**
         * Gets or sets the InnerLabel mapping property for the current series object.
        */
        get innerLabelMemberPath() {
            return this.i.cy;
        }
        set innerLabelMemberPath(v) {
            this.i.cy = v;
        }
        /**
         * Gets or sets the OuterLabel mapping property for the current series object.
        */
        get outerLabelMemberPath() {
            return this.i.c9;
        }
        set outerLabelMemberPath(v) {
            this.i.c9 = v;
        }
        /**
         * Gets or sets whether the inner labels are visible.
        */
        get innerLabelVisibility() {
            return this.i.ft;
        }
        set innerLabelVisibility(v) {
            this.i.ft = ensureEnum(Visibility_$type, v);
        }
        /**
         * Gets or sets whether the outer labels are visible.
        */
        get outerLabelVisibility() {
            return this.i.fu;
        }
        set outerLabelVisibility(v) {
            this.i.fu = ensureEnum(Visibility_$type, v);
        }
        /**
         * Gets or sets which side of the chart the outer labels should appear.
        */
        get outerLabelAlignment() {
            return this.i.au;
        }
        set outerLabelAlignment(v) {
            this.i.au = ensureEnum(OuterLabelAlignment_$type, v);
        }
        /**
         * Gets or sets how the heights of the funnel slices should be configured.
        */
        get funnelSliceDisplay() {
            return this.i.ak;
        }
        set funnelSliceDisplay(v) {
            this.i.ak = ensureEnum(FunnelSliceDisplay_$type, v);
        }
        /**
         * Gets or sets the formatter function for inner labels. Function should return string and it takes 3 parameters: 1st-value of item to format, 2nd-index of item within data, 3rd-reference to the funnel chart.
        */
        get formatInnerLabel() {
            return this.i.b8;
        }
        set formatInnerLabel(v) {
            this.i.b8 = v;
        }
        /**
         * Gets or sets the formatter function for outer labels. Function should return string and it takes 3 parameters: 1st-value of item to format, 2nd-index of item within data, 3rd-reference to the funnel chart.
        */
        get formatOuterLabel() {
            return this.i.b9;
        }
        set formatOuterLabel(v) {
            this.i.b9 = v;
        }
        /**
         * Gets or sets how long the animations should take to run.
        */
        get transitionDuration() {
            return this.i.ca;
        }
        set transitionDuration(v) {
            this.i.ca = +v;
        }
        /**
         * Gets or sets if the funnel should be rendered inverted.
        */
        get isInverted() {
            return this.i.bk;
        }
        set isInverted(v) {
            this.i.bk = ensureBool(v);
        }
        /**
         * Gets or sets whether to use a Bezier curve to define the funnel.
        */
        get useBezierCurve() {
            return this.i.bl;
        }
        set useBezierCurve(v) {
            this.i.bl = ensureBool(v);
        }
        /**
         * Gets or sets whether to allow slices to be selected.
        */
        get allowSliceSelection() {
            return this.i.be;
        }
        set allowSliceSelection(v) {
            this.i.be = ensureBool(v);
        }
        /**
         * Gets or sets whether to use the unselected style on unselected slices.
        */
        get useUnselectedStyle() {
            return this.i.bn;
        }
        set useUnselectedStyle(v) {
            this.i.bn = ensureBool(v);
        }
        /**
         * Gets or sets the fill brush.
        */
        get selectedSliceFill() {
            return this.i.fr ? this.i.fr.fill : null;
        }
        set selectedSliceFill(v) {
            this.ensureSelectedSliceStyle();
            this.i.fr.fill = v;
        }
        /**
         * Gets or sets the stroke brush.
        */
        get selectedSliceStroke() {
            return this.i.fr ? this.i.fr.stroke : null;
        }
        set selectedSliceStroke(v) {
            this.ensureSelectedSliceStyle();
            this.i.fr.stroke = v;
        }
        /**
         * Gets or sets the stroke thickness.
        */
        get selectedSliceStrokeThickness() {
            return this.i.fr ? this.i.fr.strokeThickness : NaN;
        }
        set selectedSliceStrokeThickness(v) {
            this.ensureSelectedSliceStyle();
            this.i.fr.strokeThickness = +v;
        }
        /**
         * Gets or sets the opacity.
        */
        get selectedSliceOpacity() {
            return this.i.fr ? this.i.fr.opacity : NaN;
        }
        set selectedSliceOpacity(v) {
            this.ensureSelectedSliceStyle();
            this.i.fr.opacity = +v;
        }
        ensureSelectedSliceStyle() {
            if (this.i.fr) {
                return;
            }
            this.i.fr = new Style();
        }
        /**
         * Gets or sets the fill brush.
        */
        get unselectedSliceFill() {
            return this.i.fs ? this.i.fs.fill : null;
        }
        set unselectedSliceFill(v) {
            this.ensureUnselectedSliceStyle();
            this.i.fs.fill = v;
        }
        /**
         * Gets or sets the stroke brush.
        */
        get unselectedSliceStroke() {
            return this.i.fs ? this.i.fs.stroke : null;
        }
        set unselectedSliceStroke(v) {
            this.ensureUnselectedSliceStyle();
            this.i.fs.stroke = v;
        }
        /**
         * Gets or sets the stroke thickness.
        */
        get unselectedSliceStrokeThickness() {
            return this.i.fs ? this.i.fs.strokeThickness : NaN;
        }
        set unselectedSliceStrokeThickness(v) {
            this.ensureUnselectedSliceStyle();
            this.i.fs.strokeThickness = +v;
        }
        /**
         * Gets or sets the opacity.
        */
        get unselectedSliceOpacity() {
            return this.i.fs ? this.i.fs.opacity : NaN;
        }
        set unselectedSliceOpacity(v) {
            this.ensureUnselectedSliceStyle();
            this.i.fs.opacity = +v;
        }
        ensureUnselectedSliceStyle() {
            if (this.i.fs) {
                return;
            }
            this.i.fs = new Style();
        }
        /**
         * Gets or sets the LegendItemBadgeTemplate to use for the legend items.
        */
        get legendItemBadgeTemplate() {
            return this.i.legendItemBadgeTemplate;
        }
        set legendItemBadgeTemplate(v) {
            this.i.legendItemBadgeTemplate = v;
        }
        /**
         * Gets or sets whether to use the outer labels to identify the legend items.
        */
        get useOuterLabelsForLegend() {
            return this.i.bm;
        }
        set useOuterLabelsForLegend(v) {
            this.i.bm = ensureBool(v);
        }
        /**
         * Gets or sets the text style for inner labels
        */
        get textStyle() {
            return this.i.dk;
        }
        set textStyle(v) {
            this.i.dk = v;
        }
        /**
         * Gets or sets the text style for outer labels
        */
        get outerLabelTextStyle() {
            return this.i.dc;
        }
        set outerLabelTextStyle(v) {
            this.i.dc = v;
        }
        /**
         * Gets or sets the thickness of outline around slices.
        */
        get outlineThickness() {
            return this.i.b1;
        }
        set outlineThickness(v) {
            this.i.b1 = +v;
        }
        /**
         * Gets or sets the scaling value used to affect the pixel density of the control.
         * A higher scaling ratio will produce crisper visuals at the expense of memory.  Lower values will cause the control
         * to appear blurry.
        */
        get pixelScalingRatio() {
            return this.i.b3;
        }
        set pixelScalingRatio(v) {
            this.i.b3 = +v;
        }
        /**
         * Gets or sets the brush used for the outer labels.
        */
        get outerLabelTextColor() {
            return brushToString(this.i.fn);
        }
        set outerLabelTextColor(v) {
            this.i.fn = stringToBrush(v);
        }
        /**
         * Gets or sets the brush used for the inner labels.
        */
        get textColor() {
            return brushToString(this.i.fo);
        }
        set textColor(v) {
            this.i.fo = stringToBrush(v);
        }
        findByName(name) {
            if (this.findEphemera) {
                if (name && name.indexOf("@@e:") == 0) {
                    return this.findEphemera(name);
                }
            }
            return null;
        }
        get hasUserValues() {
            return this._hasUserValues;
        }
        __m(propertyName) {
            if (!this._inStyling) {
                this._hasUserValues.add(propertyName);
            }
        }
        _styling(container, component, parent) {
            if (this._inStyling) {
                return;
            }
            this._inStyling = true;
            this._stylingContainer = container;
            this._stylingParent = component;
            let genericPrefix = "";
            let typeName = this.i.$type.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            genericPrefix = toSpinal("FunnelChartComponent");
            let additionalPrefixes = [];
            let prefix = toSpinal(typeName);
            additionalPrefixes.push(prefix + "-");
            let b = this.i.$type.baseType;
            while (b && b.name != "Object" &&
                b.name != "Base" &&
                b.name != "Control" &&
                b.Name != "DependencyObject" &&
                b.Name != "FrameworkElement") {
                typeName = b.name;
                if (typeName.indexOf("Xam") === 0) {
                    typeName = typeName.substring(3);
                }
                let basePrefix = toSpinal(typeName);
                additionalPrefixes.push(basePrefix + "-");
                b = b.baseType;
            }
            if (parent) {
                let parentTypeName = parent.i.$type.name;
                if (parentTypeName.indexOf("Xam") === 0) {
                    parentTypeName = parentTypeName.substring(3);
                }
                let parentPrefix = toSpinal(parentTypeName);
                additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
                additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
            }
            initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
            if (this._otherStyling) {
                this._otherStyling(container, component, parent);
            }
            this._inStyling = false;
        }
        /**
     * Use to force the funnel chart to finish any deferred work before printing or evaluating its visual.
     * This should only be called if the visual of the funnel chart needs to be synchronously saved or evaluated.
     * Calling this method too often will hinder the performance of the funnel chart.
    
    */
        flush() {
            this.i.dz();
        }
        /**
         * Provides container for funnel chart
        
        */
        provideContainer(container) {
            this.i.provideContainer(container);
        }
        /**
         * Notifies the controller and view about a size change.
        
        */
        notifyResized() {
            this.i.notifyResized();
        }
        notifySetItem(source_, index, oldItem, newItem) {
            this.i.ea(source_, index, oldItem, newItem);
        }
        /**
         * Manually notifies the chart's data source that the data it has bound to has been cleared and needs to be re-examined.
         * This should not be called if the data that the chart is bound to is already observable.
        
        */
        notifyClearItems(source_) {
            this.i.d5(source_);
        }
        notifyInsertItem(source_, index, newItem) {
            this.i.d7(source_, index, newItem);
        }
        notifyRemoveItem(source_, index, oldItem) {
            this.i.d8(source_, index, oldItem);
        }
        /**
         * Toggle selection of item at index.
        
        */
        toggleSelection(index) {
            this.i.em(index);
        }
        /**
         * Exports and serializes the chart visuals.
        
        */
        exportSerializedVisualData() {
            let iv = this.i.cl();
            return (iv);
        }
        /**
         * Event which is raised when a slice is clicked.
         * Function takes first argument null and second argument ui.
         * Use ui.owner to obtain reference to igFunnelChart.
         * Use ui.index to obtain index of clicked slice.
         * Use ui.item to obtain reference to clicked slice item.
         * Use ui.selected to check if slice became selected.
        */
        get sliceClicked() {
            if (this._sliceClicked == null) {
                this._sliceClicked = new EventEmitter();
                this.i.sliceClicked = delegateCombine(this.i.sliceClicked, (o, e) => {
                    this._runInZone(() => {
                        let outerArgs = new IgxFunnelSliceClickedEventArgs();
                        outerArgs._provideImplementation(e);
                        if (this.beforeSliceClicked) {
                            this.beforeSliceClicked(this, outerArgs);
                        }
                        this._sliceClicked.emit({
                            sender: this,
                            args: outerArgs
                        });
                    });
                });
            }
            return this._sliceClicked;
        }
        /**
         * Raised when a funnel slice is entered.
        */
        get sliceEnter() {
            if (this._sliceEnter == null) {
                this._sliceEnter = new EventEmitter();
                this.i.sliceEnter = delegateCombine(this.i.sliceEnter, (o, e) => {
                    this._runInZone(() => {
                        let outerArgs = new IgxFunnelSliceEventArgs();
                        outerArgs._provideImplementation(e);
                        if (this.beforeSliceEnter) {
                            this.beforeSliceEnter(this, outerArgs);
                        }
                        this._sliceEnter.emit({
                            sender: this,
                            args: outerArgs
                        });
                    });
                });
            }
            return this._sliceEnter;
        }
        /**
         * Raised when a funnel slice is left.
        */
        get sliceLeave() {
            if (this._sliceLeave == null) {
                this._sliceLeave = new EventEmitter();
                this.i.sliceLeave = delegateCombine(this.i.sliceLeave, (o, e) => {
                    this._runInZone(() => {
                        let outerArgs = new IgxFunnelSliceEventArgs();
                        outerArgs._provideImplementation(e);
                        if (this.beforeSliceLeave) {
                            this.beforeSliceLeave(this, outerArgs);
                        }
                        this._sliceLeave.emit({
                            sender: this,
                            args: outerArgs
                        });
                    });
                });
            }
            return this._sliceLeave;
        }
        /**
         * Raised when a funnel slice is hovered.
        */
        get sliceHover() {
            if (this._sliceHover == null) {
                this._sliceHover = new EventEmitter();
                this.i.sliceHover = delegateCombine(this.i.sliceHover, (o, e) => {
                    this._runInZone(() => {
                        let outerArgs = new IgxFunnelSliceEventArgs();
                        outerArgs._provideImplementation(e);
                        if (this.beforeSliceHover) {
                            this.beforeSliceHover(this, outerArgs);
                        }
                        this._sliceHover.emit({
                            sender: this,
                            args: outerArgs
                        });
                    });
                });
            }
            return this._sliceHover;
        }
        _runInZone(act) {
            if (this._zoneRunner != null) {
                this._zoneRunner(act);
            }
            else {
                act();
            }
        }
    }
    IgxFunnelChartComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: IgxFunnelChartComponent, deps: [{ token: i0.Renderer2 }, { token: i0.ViewContainerRef }, { token: i0.NgZone }, { token: i0.Injector }, { token: i0.ComponentFactoryResolver }], target: i0.ɵɵFactoryTarget.Component });
    IgxFunnelChartComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: IgxFunnelChartComponent, selector: "igx-funnel-chart", inputs: { height: "height", width: "width", dataSource: "dataSource", legend: "legend", valueMemberPath: "valueMemberPath", highlightedValueMemberPath: "highlightedValueMemberPath", actualHighlightValueOpacity: "actualHighlightValueOpacity", highlightValueOpacity: "highlightValueOpacity", actualHighlightValueDisplayMode: "actualHighlightValueDisplayMode", highlightValueDisplayMode: "highlightValueDisplayMode", brushes: "brushes", outlines: "outlines", bottomEdgeWidth: "bottomEdgeWidth", innerLabelMemberPath: "innerLabelMemberPath", outerLabelMemberPath: "outerLabelMemberPath", innerLabelVisibility: "innerLabelVisibility", outerLabelVisibility: "outerLabelVisibility", outerLabelAlignment: "outerLabelAlignment", funnelSliceDisplay: "funnelSliceDisplay", formatInnerLabel: "formatInnerLabel", formatOuterLabel: "formatOuterLabel", transitionDuration: "transitionDuration", isInverted: "isInverted", useBezierCurve: "useBezierCurve", allowSliceSelection: "allowSliceSelection", useUnselectedStyle: "useUnselectedStyle", selectedSliceFill: "selectedSliceFill", selectedSliceStroke: "selectedSliceStroke", selectedSliceStrokeThickness: "selectedSliceStrokeThickness", selectedSliceOpacity: "selectedSliceOpacity", unselectedSliceFill: "unselectedSliceFill", unselectedSliceStroke: "unselectedSliceStroke", unselectedSliceStrokeThickness: "unselectedSliceStrokeThickness", unselectedSliceOpacity: "unselectedSliceOpacity", legendItemBadgeTemplate: "legendItemBadgeTemplate", useOuterLabelsForLegend: "useOuterLabelsForLegend", textStyle: "textStyle", outerLabelTextStyle: "outerLabelTextStyle", outlineThickness: "outlineThickness", pixelScalingRatio: "pixelScalingRatio", outerLabelTextColor: "outerLabelTextColor", textColor: "textColor" }, outputs: { sliceClicked: "sliceClicked", sliceEnter: "sliceEnter", sliceLeave: "sliceLeave", sliceHover: "sliceHover" }, host: { classAttribute: "ig-funnel-chart igx-funnel-chart" }, providers: [], viewQueries: [{ propertyName: "_dynamicContent", first: true, predicate: ["dynamicContent"], descendants: true, read: ViewContainerRef, static: true }], ngImport: i0, template: `<ng-container #dynamicContent></ng-container>`, isInline: true, styles: ["\n\t\t:host {\n\t\t\tdisplay: block;\n\t\t}\n\t"], changeDetection: i0.ChangeDetectionStrategy.OnPush });
    return IgxFunnelChartComponent;
})();
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: IgxFunnelChartComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'igx-funnel-chart',
                    template: `<ng-container #dynamicContent></ng-container>`,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [],
                    host: { 'class': 'ig-funnel-chart igx-funnel-chart' },
                    styles: [`
		:host {
			display: block;
		}
	`]
                }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }, { type: i0.ViewContainerRef }, { type: i0.NgZone }, { type: i0.Injector }, { type: i0.ComponentFactoryResolver }]; }, propDecorators: { _dynamicContent: [{
                type: ViewChild,
                args: ["dynamicContent", { read: ViewContainerRef, static: true }]
            }], height: [{
                type: Input
            }], width: [{
                type: Input
            }], dataSource: [{
                type: Input
            }], legend: [{
                type: Input
            }], valueMemberPath: [{
                type: Input
            }], highlightedValueMemberPath: [{
                type: Input
            }], actualHighlightValueOpacity: [{
                type: Input
            }], highlightValueOpacity: [{
                type: Input
            }], actualHighlightValueDisplayMode: [{
                type: Input
            }], highlightValueDisplayMode: [{
                type: Input
            }], brushes: [{
                type: Input
            }], outlines: [{
                type: Input
            }], bottomEdgeWidth: [{
                type: Input
            }], innerLabelMemberPath: [{
                type: Input
            }], outerLabelMemberPath: [{
                type: Input
            }], innerLabelVisibility: [{
                type: Input
            }], outerLabelVisibility: [{
                type: Input
            }], outerLabelAlignment: [{
                type: Input
            }], funnelSliceDisplay: [{
                type: Input
            }], formatInnerLabel: [{
                type: Input
            }], formatOuterLabel: [{
                type: Input
            }], transitionDuration: [{
                type: Input
            }], isInverted: [{
                type: Input
            }], useBezierCurve: [{
                type: Input
            }], allowSliceSelection: [{
                type: Input
            }], useUnselectedStyle: [{
                type: Input
            }], selectedSliceFill: [{
                type: Input
            }], selectedSliceStroke: [{
                type: Input
            }], selectedSliceStrokeThickness: [{
                type: Input
            }], selectedSliceOpacity: [{
                type: Input
            }], unselectedSliceFill: [{
                type: Input
            }], unselectedSliceStroke: [{
                type: Input
            }], unselectedSliceStrokeThickness: [{
                type: Input
            }], unselectedSliceOpacity: [{
                type: Input
            }], legendItemBadgeTemplate: [{
                type: Input
            }], useOuterLabelsForLegend: [{
                type: Input
            }], textStyle: [{
                type: Input
            }], outerLabelTextStyle: [{
                type: Input
            }], outlineThickness: [{
                type: Input
            }], pixelScalingRatio: [{
                type: Input
            }], outerLabelTextColor: [{
                type: Input
            }], textColor: [{
                type: Input
            }], sliceClicked: [{
                type: Output
            }], sliceEnter: [{
                type: Output
            }], sliceLeave: [{
                type: Output
            }], sliceHover: [{
                type: Output
            }] } });
