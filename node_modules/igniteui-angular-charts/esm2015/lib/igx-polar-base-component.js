import { EventEmitter, Output, Component, Input } from '@angular/core';
import { delegateCombine } from "igniteui-angular-core";
import { IgxNumericAngleAxisComponent } from "./igx-numeric-angle-axis-component";
import { IgxNumericRadiusAxisComponent } from "./igx-numeric-radius-axis-component";
import { TrendLineType_$type } from "igniteui-angular-core";
import { ScatterItemSearchMode_$type } from "./ScatterItemSearchMode";
import { IgxAssigningPolarStyleEventArgs } from "./igx-assigning-polar-style-event-args";
import { IgxAssigningPolarMarkerStyleEventArgs } from "./igx-assigning-polar-marker-style-event-args";
import { IgxMarkerSeriesComponent } from "./igx-marker-series-component";
import { ensureBool, ensureEnum, brushToString, stringToBrush, toDoubleCollection, fromDoubleCollection, toPoint, fromPoint } from "igniteui-angular-core";
import * as i0 from "@angular/core";
/**
 * Represents the base class from which all IgxDataChartComponent polar series are derived.
*/
export let IgxPolarBaseComponent = /*@__PURE__*/ (() => {
    class IgxPolarBaseComponent extends IgxMarkerSeriesComponent {
        constructor() {
            super();
            this._assigningPolarStyle = null;
            this._assigningPolarMarkerStyle = null;
        }
        /**
                                     * @hidden
                                     */
        get i() {
            return this._implementation;
        }
        /**
         * Checks if this series is a polar series
        */
        get isPolar() {
            return this.i.fn;
        }
        /**
         * Gets or sets the path to use to find the angle values for the series.
        */
        get angleMemberPath() {
            return this.i.aab;
        }
        set angleMemberPath(v) {
            this.i.aab = v;
        }
        /**
         * Gets or sets the path to use to get the radius values for the series.
        */
        get radiusMemberPath() {
            return this.i.aat;
        }
        set radiusMemberPath(v) {
            this.i.aat = v;
        }
        /**
         * Gets or sets the highlighted radius value mapping property for the current series object.
        */
        get highlightedRadiusMemberPath() {
            return this.i.aag;
        }
        set highlightedRadiusMemberPath(v) {
            this.i.aag = v;
        }
        /**
         * Gets or sets the highlighted angle value mapping property for the current series object.
        */
        get highlightedAngleMemberPath() {
            return this.i.aae;
        }
        set highlightedAngleMemberPath(v) {
            this.i.aae = v;
        }
        /**
         * Gets the effective angle axis for the current series object.
        */
        get angleAxis() {
            const r = this.i.yl;
            if (r == null) {
                return null;
            }
            if (!r.externalObject) {
                let e = IgxNumericAngleAxisComponent._createFromInternal(r);
                if (e) {
                    e._implementation = r;
                }
                r.externalObject = e;
            }
            return r.externalObject;
        }
        set angleAxis(v) {
            if (v != null && this._stylingContainer && v._styling)
                v._styling(this._stylingContainer, this, this);
            v == null ? this.i.yl = null : this.i.yl = v.i;
        }
        /**
         * Gets the effective radius axis for the current series object.
        */
        get radiusAxis() {
            const r = this.i.ym;
            if (r == null) {
                return null;
            }
            if (!r.externalObject) {
                let e = IgxNumericRadiusAxisComponent._createFromInternal(r);
                if (e) {
                    e._implementation = r;
                }
                r.externalObject = e;
            }
            return r.externalObject;
        }
        set radiusAxis(v) {
            if (v != null && this._stylingContainer && v._styling)
                v._styling(this._stylingContainer, this, this);
            v == null ? this.i.ym = null : this.i.ym = v.i;
        }
        /**
         * Gets or sets whether Cartesian Interpolation should be used rather than Archimedian
         * spiral based interpolation.
        */
        get useCartesianInterpolation() {
            return this.i.zr;
        }
        set useCartesianInterpolation(v) {
            this.i.zr = ensureBool(v);
        }
        /**
         * Gets or sets the maximum number of markers displayed by the current series.
         * If more than the specified number of markers are visible, the polar series will automatically
         * choose a representative set.
        */
        get maximumMarkers() {
            return this.i.z1;
        }
        set maximumMarkers(v) {
            this.i.z1 = +v;
        }
        /**
         * Gets or sets the trend type for the current series object.
        */
        get trendLineType() {
            return this.i.y3;
        }
        set trendLineType(v) {
            this.i.y3 = ensureEnum(TrendLineType_$type, v);
        }
        /**
         * Gets or sets the brush that specifies how the current series
         * object's trend line is drawn.
        */
        get trendLineBrush() {
            return brushToString(this.i.ab0);
        }
        set trendLineBrush(v) {
            this.i.ab0 = stringToBrush(v);
        }
        /**
         * Gets the effective TrendLineBrush for this series.
        */
        get actualTrendLineBrush() {
            return brushToString(this.i.abz);
        }
        set actualTrendLineBrush(v) {
            this.i.abz = stringToBrush(v);
        }
        /**
         * Gets or sets the thickness of the current series object's trend line.
        */
        get trendLineThickness() {
            return this.i.zz;
        }
        set trendLineThickness(v) {
            this.i.zz = +v;
        }
        /**
         * Gets or sets a collection of double values that indicate the pattern of dashes and gaps that
         * is used to draw the trend line for the current series object.
        */
        get trendLineDashArray() {
            return fromDoubleCollection(this.i.ab1);
        }
        set trendLineDashArray(v) {
            this.i.ab1 = toDoubleCollection(v);
        }
        /**
         * Gets or sets the moving average period for the current series object.
        */
        get trendLinePeriod() {
            return this.i.z2;
        }
        set trendLinePeriod(v) {
            this.i.z2 = +v;
        }
        /**
         * Sets or Gets the Trendline Z index.
        */
        get trendLineZIndex() {
            return this.i.z3;
        }
        set trendLineZIndex(v) {
            this.i.z3 = +v;
        }
        /**
         * Gets or sets whether to clip the series to the bounds.
         * Setting this to true can effect performance.
        */
        get clipSeriesToBounds() {
            return this.i.zh;
        }
        set clipSeriesToBounds(v) {
            this.i.zh = ensureBool(v);
        }
        get actualItemSearchMode() {
            return this.i.yz;
        }
        set actualItemSearchMode(v) {
            this.i.yz = ensureEnum(ScatterItemSearchMode_$type, v);
        }
        /**
         * Gets or sets the mode the series will use to find the closest point to the cursor.
        */
        get itemSearchMode() {
            return this.i.y1;
        }
        set itemSearchMode(v) {
            this.i.y1 = ensureEnum(ScatterItemSearchMode_$type, v);
        }
        /**
         * Gets or sets the threshold to use when searching for items using ItemSearchMode.
        */
        get itemSearchThreshold() {
            return this.i.z0;
        }
        set itemSearchThreshold(v) {
            this.i.z0 = +v;
        }
        /**
         * Gets or sets whether this Polar series should allow custom style overrides of its individual visuals.
        */
        get isCustomPolarStyleAllowed() {
            return this.i.zk;
        }
        set isCustomPolarStyleAllowed(v) {
            this.i.zk = ensureBool(v);
        }
        /**
         * Gets or sets whether this Polar series should allow custom style overrides of its individual marker visuals.
        */
        get isCustomPolarMarkerStyleAllowed() {
            return this.i.zj;
        }
        set isCustomPolarMarkerStyleAllowed(v) {
            this.i.zj = ensureBool(v);
        }
        /**
         * Gets or sets the label displayed before series' radius value in the Data Legend.
        */
        get radiusMemberAsLegendLabel() {
            return this.i.aap;
        }
        set radiusMemberAsLegendLabel(v) {
            this.i.aap = v;
        }
        /**
         * Gets or sets the label displayed before series' angle value in the Data Legend.
        */
        get angleMemberAsLegendLabel() {
            return this.i.z7;
        }
        set angleMemberAsLegendLabel(v) {
            this.i.z7 = v;
        }
        /**
         * Gets or sets the unit displayed after series' radius value in the Data Legend.
        */
        get radiusMemberAsLegendUnit() {
            return this.i.aar;
        }
        set radiusMemberAsLegendUnit(v) {
            this.i.aar = v;
        }
        /**
         * Gets or sets the unit displayed after series' angle value in the Data Legend.
        */
        get angleMemberAsLegendUnit() {
            return this.i.z9;
        }
        set angleMemberAsLegendUnit(v) {
            this.i.z9 = v;
        }
        findByName(name) {
            var baseResult = super.findByName(name);
            if (baseResult) {
                return baseResult;
            }
            if (this.angleAxis && this.angleAxis.name && this.angleAxis.name == name) {
                return this.angleAxis;
            }
            if (this.radiusAxis && this.radiusAxis.name && this.radiusAxis.name == name) {
                return this.radiusAxis;
            }
            return null;
        }
        _styling(container, component, parent) {
            super._styling(container, component, parent);
            this._inStyling = true;
            if (this.angleAxis && this.angleAxis._styling) {
                this.angleAxis._styling(container, component, this);
            }
            if (this.radiusAxis && this.radiusAxis._styling) {
                this.radiusAxis._styling(container, component, this);
            }
            this._inStyling = false;
        }
        /**
         * Scrolls the requested item into view, if possible.
        
        * @param item  * The item to scroll into view.
        */
        scrollIntoView(item) {
            let iv = this.i.gb(item);
            return (iv);
        }
        /**
         * Gets the item that is the best match for the specified world coordinates.
        
        * @param world  * The world coordinates to use.
        */
        getItem(world) {
            let iv = this.i.kl(toPoint(world));
            return (iv);
        }
        /**
         * Gets the index of the item that resides at the provided world coordinates.
        
        * @param world  * The world coordinates of the requested item.
        */
        getItemIndex(world) {
            let iv = this.i.j1(toPoint(world));
            return (iv);
        }
        getExactItemIndex(world) {
            let iv = this.i.ip(toPoint(world));
            return (iv);
        }
        getSeriesValuePosition(world, useInterpolation, skipUnknowns) {
            let iv = this.i.v6(toPoint(world), useInterpolation, skipUnknowns);
            return fromPoint(iv);
        }
        getItemValue(item, memberPathName) {
            let iv = this.i.ko(item, memberPathName);
            return (iv);
        }
        /**
         * Gets the value of a requested member path from the series.
        
        * @param memberPathName  * The property name of a valid member path for the series
        */
        getMemberPathValue(memberPathName) {
            let iv = this.i.mb(memberPathName);
            return (iv);
        }
        /**
         * Determine if object can be used as RadiusAxis
        
        * @param axis  * The object to check
        */
        canUseAsRadiusAxis(axis) {
            let iv = this.i.zg(axis);
            return (iv);
        }
        /**
         * Determine if object can be used as AngleAxis
        
        * @param axis  * The object to check
        */
        canUseAsAngleAxis(axis) {
            let iv = this.i.zf(axis);
            return (iv);
        }
        /**
         * Event raised when Assigning Category Style
        */
        get assigningPolarStyle() {
            if (this._assigningPolarStyle == null) {
                this._assigningPolarStyle = new EventEmitter();
                this.i.assigningPolarStyle = delegateCombine(this.i.assigningPolarStyle, (o, e) => {
                    let outerArgs = new IgxAssigningPolarStyleEventArgs();
                    outerArgs._provideImplementation(e);
                    if (this.beforeAssigningPolarStyle) {
                        this.beforeAssigningPolarStyle(this, outerArgs);
                    }
                    this._assigningPolarStyle.emit({
                        sender: this,
                        args: outerArgs
                    });
                });
            }
            return this._assigningPolarStyle;
        }
        /**
         * Event raised when Assigning Polar Marker Style
        */
        get assigningPolarMarkerStyle() {
            if (this._assigningPolarMarkerStyle == null) {
                this._assigningPolarMarkerStyle = new EventEmitter();
                this.i.assigningPolarMarkerStyle = delegateCombine(this.i.assigningPolarMarkerStyle, (o, e) => {
                    let outerArgs = new IgxAssigningPolarMarkerStyleEventArgs();
                    outerArgs._provideImplementation(e);
                    if (this.beforeAssigningPolarMarkerStyle) {
                        this.beforeAssigningPolarMarkerStyle(this, outerArgs);
                    }
                    this._assigningPolarMarkerStyle.emit({
                        sender: this,
                        args: outerArgs
                    });
                });
            }
            return this._assigningPolarMarkerStyle;
        }
    }
    IgxPolarBaseComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: IgxPolarBaseComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    IgxPolarBaseComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: IgxPolarBaseComponent, selector: "ng-component", inputs: { angleMemberPath: "angleMemberPath", radiusMemberPath: "radiusMemberPath", highlightedRadiusMemberPath: "highlightedRadiusMemberPath", highlightedAngleMemberPath: "highlightedAngleMemberPath", angleAxis: "angleAxis", radiusAxis: "radiusAxis", useCartesianInterpolation: "useCartesianInterpolation", maximumMarkers: "maximumMarkers", trendLineType: "trendLineType", trendLineBrush: "trendLineBrush", actualTrendLineBrush: "actualTrendLineBrush", trendLineThickness: "trendLineThickness", trendLineDashArray: "trendLineDashArray", trendLinePeriod: "trendLinePeriod", trendLineZIndex: "trendLineZIndex", clipSeriesToBounds: "clipSeriesToBounds", actualItemSearchMode: "actualItemSearchMode", itemSearchMode: "itemSearchMode", itemSearchThreshold: "itemSearchThreshold", isCustomPolarStyleAllowed: "isCustomPolarStyleAllowed", isCustomPolarMarkerStyleAllowed: "isCustomPolarMarkerStyleAllowed", radiusMemberAsLegendLabel: "radiusMemberAsLegendLabel", angleMemberAsLegendLabel: "angleMemberAsLegendLabel", radiusMemberAsLegendUnit: "radiusMemberAsLegendUnit", angleMemberAsLegendUnit: "angleMemberAsLegendUnit" }, outputs: { assigningPolarStyle: "assigningPolarStyle", assigningPolarMarkerStyle: "assigningPolarMarkerStyle" }, usesInheritance: true, ngImport: i0, template: ``, isInline: true });
    return IgxPolarBaseComponent;
})();
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: IgxPolarBaseComponent, decorators: [{
            type: Component,
            args: [{
                    template: ``,
                }]
        }], ctorParameters: function () { return []; }, propDecorators: { angleMemberPath: [{
                type: Input
            }], radiusMemberPath: [{
                type: Input
            }], highlightedRadiusMemberPath: [{
                type: Input
            }], highlightedAngleMemberPath: [{
                type: Input
            }], angleAxis: [{
                type: Input
            }], radiusAxis: [{
                type: Input
            }], useCartesianInterpolation: [{
                type: Input
            }], maximumMarkers: [{
                type: Input
            }], trendLineType: [{
                type: Input
            }], trendLineBrush: [{
                type: Input
            }], actualTrendLineBrush: [{
                type: Input
            }], trendLineThickness: [{
                type: Input
            }], trendLineDashArray: [{
                type: Input
            }], trendLinePeriod: [{
                type: Input
            }], trendLineZIndex: [{
                type: Input
            }], clipSeriesToBounds: [{
                type: Input
            }], actualItemSearchMode: [{
                type: Input
            }], itemSearchMode: [{
                type: Input
            }], itemSearchThreshold: [{
                type: Input
            }], isCustomPolarStyleAllowed: [{
                type: Input
            }], isCustomPolarMarkerStyleAllowed: [{
                type: Input
            }], radiusMemberAsLegendLabel: [{
                type: Input
            }], angleMemberAsLegendLabel: [{
                type: Input
            }], radiusMemberAsLegendUnit: [{
                type: Input
            }], angleMemberAsLegendUnit: [{
                type: Input
            }], assigningPolarStyle: [{
                type: Output
            }], assigningPolarMarkerStyle: [{
                type: Output
            }] } });
