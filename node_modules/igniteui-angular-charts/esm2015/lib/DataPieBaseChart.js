/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { RadialBaseChart } from "./RadialBaseChart";
import { ProportionalCategoryAngleAxis } from "./ProportionalCategoryAngleAxis";
import { NumericRadiusAxis } from "./NumericRadiusAxis";
import { typeCast, runOn, delegateCombine, enumGetBox, markType } from "igniteui-angular-core";
import { PieChartSweepDirection_$type } from "./PieChartSweepDirection";
import { CalloutCollisionMode_$type } from "igniteui-angular-core";
import { OthersCategoryType_$type } from "igniteui-angular-core";
import { AxisRangeBufferMode_$type } from "./AxisRangeBufferMode";
import { RadialLabelMode_$type } from "igniteui-angular-core";
import { CollisionAvoidanceType_$type } from "./CollisionAvoidanceType";
import { RadialBase } from "./RadialBase";
import { RadialPieSeries } from "./RadialPieSeries";
import { AnchoredRadialSeries } from "./AnchoredRadialSeries";
import { AxisLabelSettings } from "./AxisLabelSettings";
import { isNaN_ } from "igniteui-angular-core";
/**
 * @hidden
 */
export let DataPieBaseChart = /*@__PURE__*/ (() => {
    class DataPieBaseChart extends RadialBaseChart {
        constructor() {
            super();
            this.aic = null;
            this.agk = null;
            this.ah8 = null;
            this.agi = null;
            this.aia = null;
            this.agj = null;
            this.ah7 = null;
            this.agh = null;
            this.ahj = 0;
            this.agz = 0;
            this.agr = 6;
            this.ajx = null;
            this.ajw = null;
            this.aid = null;
            this.ah6 = null;
            this.agx = 1;
            this.ahk = 3;
            this.ah9 = null;
            this.ah5 = null;
            this.aha = true;
            this.agp = 0;
            this.ahh = 0;
            this.ahi = 0;
            this.ahn = 0;
            this.ahb = false;
            this.ah3 = 10;
            this.ahp = NaN;
            this.aho = NaN;
            this.ahq = 0;
            this.ahl = NaN;
            this.ahm = NaN;
            this.aib = " - ";
            this.ag4 = 0;
            this.ag3 = 0;
            this.ag8 = true;
            this.ag9 = true;
            this.agt = 0;
        }
        ajs(a) {
            this.ajt((b, c) => a(b));
        }
        ajt(a) {
            if (this.dataChart == null) {
                return;
            }
            for (let b = 0; b < this.dataChart.series.count; b++) {
                let c = this.dataChart.series._inner[b];
                if (c.fr) {
                    a(c, b);
                }
            }
        }
        ajq(a) {
            this.ajr((b, c) => a(b));
        }
        ajr(a) {
            if (this.dataChart == null) {
                return;
            }
            for (let b = 0; b < this.dataChart.series.count; b++) {
                let c = this.dataChart.series._inner[b];
                if (c.fr) {
                    a(c, b);
                }
            }
        }
        wg() {
            let a = this.bj.dataSeries != null ? this.bj.dataSeries.count : 0;
            super.wg();
            if (this.aij != null) {
                let b = this.aij;
                this.angleAxis.f1 = b;
            }
            else {
                this.angleAxis.f1 = this.ab2 == null ? RadialBaseChart.adj(this.angleAxis, this.bj.dataSeries) : this.ab2;
            }
            this.angleAxis.itemsSource = this.dataChart != null && this.dataChart.series.count > 0 ? this.dataChart.series._inner[0].itemsSource : null;
            if (this.ajn != null) {
                this.angleAxis.og = this.ajn;
            }
            else {
                this.angleAxis.og = (this.dataChart != null && this.dataChart.series.count > 0 && typeCast(RadialPieSeries.$, this.dataChart.series._inner[0]) !== null) ? this.dataChart.series._inner[0].acm : null;
            }
        }
        c6(a, b) {
            if (this.c9 == null || this.c9.count == 0) {
                return 13;
            }
            let c = super.c6(a, b);
            if (c == 1) {
                return 13;
            }
            return c;
        }
        we(a) {
        }
        hc(a) {
            if (!super.hc(a)) {
                return false;
            }
            return true;
        }
        wh() {
            this.valueAxis.lj = this.ahg;
            this.valueAxis.ma = this.ah4;
        }
        get angleAxis() {
            return this.ag1;
        }
        set angleAxis(a) {
            let b = this.angleAxis;
            if (a != b) {
                this.ag1 = a;
                this.vl("AngleAxis", b, this.angleAxis);
            }
        }
        get valueAxis() {
            return this.agv;
        }
        set valueAxis(a) {
            let b = this.valueAxis;
            if (a != b) {
                this.agv = a;
                this.vl("ValueAxis", b, this.valueAxis);
            }
        }
        get_ahd() {
            return false;
        }
        get ahd() {
            return this.get_ahd();
        }
        dg(a, b) {
            let c = null;
            if (b == 34) {
                c = this.ag7(a, b);
            }
            if (a.index > 0) {
                if (!this.ahd) {
                    if (c != null) {
                        c.o0();
                    }
                    return null;
                }
            }
            return c;
        }
        uy(a, b) {
            super.uy(a, b);
            if (this.g0(a) && this.ci.isCalloutLayer(a)) {
                if (this.ajz != null) {
                    this.ci.setCalloutLightColor(a, this.ajz);
                }
                if (this.ajy != null) {
                    this.ci.setCalloutDarkColor(a, this.ajy);
                }
                let c = this.ak;
                if (this.ags != 0) {
                    c = this.ags;
                }
                this.ci.setCollisionMode(a, c);
            }
        }
        ag7(a, b) {
            let c = null;
            if (b == 34) {
                c = this.di(34);
            }
            else {
                c = this.di(34);
            }
            if (this.ajn != null) {
                c.acm = this.ajn;
            }
            else {
                c.acm = a.getMemberPathFor(0);
            }
            if (this.ail != null) {
                c.adl = this.ail;
            }
            c.yr = this.angleAxis;
            c.yw = this.valueAxis;
            c.g7 = true;
            c.ab6 = true;
            c.aas = this.ai7;
            c.yj = this.ago;
            c.aap = this.ai0;
            c.yi = this.agn;
            c.aai = this.air;
            c.yg = this.agm;
            c.aam = this.ain;
            c.yh = this.agl;
            c.y5 = this.ag6;
            c.y6 = this.ag5;
            c.z4 = this.ai5;
            return c;
        }
        zm() {
            return this.angleAxis;
        }
        zn() {
            return this.valueAxis;
        }
        t9() {
            this.angleAxis = new ProportionalCategoryAngleAxis();
            this.angleAxis.name = "angleAxis";
            let a = this.angleAxis;
            a.propertyChanged = delegateCombine(a.propertyChanged, runOn(this, this.aju));
            this.angleAxis.k2 = 0;
            this.valueAxis = new NumericRadiusAxis();
            this.valueAxis.name = "valueAxis";
            let b = this.valueAxis;
            b.propertyChanged = delegateCombine(b.propertyChanged, runOn(this, this.ajv));
            if (this.angleAxis.az == null) {
                this.angleAxis.az = new AxisLabelSettings();
            }
            if (this.valueAxis.az == null) {
                this.valueAxis.az = new AxisLabelSettings();
            }
        }
        aju(a, b) {
            switch (b.propertyName) {
                case "ActualMinimumValue":
                    this.v2("AngleAxisActualMinimum");
                    break;
                case "ActualMaximumValue":
                    this.v2("AngleAxisActualMaximum");
                    break;
            }
        }
        ajv(a, b) {
            switch (b.propertyName) {
                case "ActualMinimumValue":
                    this.v2("ValueAxisActualMinimum");
                    break;
                case "ActualMaximumValue":
                    this.v2("ValueAxisActualMaximum");
                    break;
            }
        }
        t3(a, b) {
            let c = typeCast(RadialBase.$, a);
            if (c != null) {
                c.w2 = this.c6(a, b);
            }
        }
        aet(a) {
            super.aet(a);
            a.lb = this.ahe;
            a.le = this.ahf;
            a.ny = this.aht;
            if (!isNaN_(this.ahv)) {
                a.nz = this.ahv;
            }
            else {
                a.nz = 0.65;
            }
        }
        aer(a) {
            super.aer(a);
            a.oa = this.aiw;
            a.nu = this.agy;
            a.n7 = this.ahu;
            if (!isNaN_(this.ahw)) {
                a.nb = this.ahw;
            }
            if (this.ag0 != 0) {
                if (this.ag0 == 1) {
                    a.ch = false;
                }
                else {
                    a.ch = true;
                }
            }
        }
        vl(a, b, c) {
            super.vl(a, b, c);
            switch (a) {
                case "SliceLabelPositionMode":
                    this.uk((d) => {
                        if (d.em) {
                            this.ci.setCollisionMode(d, this.ags);
                        }
                    });
                    break;
                case "SliceLabelContentSeparator":
                    this.ajq((d) => d.z4 = this.ai5);
                    break;
                case "SliceLabelContentMode":
                    this.ajq((d) => d.y5 = this.ag6);
                    break;
                case "LegendSliceLabelContentMode":
                    this.ajq((d) => d.y6 = this.ag5);
                    break;
                case "SliceLabelFormat":
                    this.ajq((d) => d.aas = this.ai7);
                    break;
                case "SliceLabelFormatSpecifiers":
                    this.ajq((d) => d.yj = this.ago);
                    break;
                case "OthersSliceLabelFormat":
                    this.ajq((d) => d.aap = this.ai0);
                    break;
                case "OthersSliceLabelFormatSpecifiers":
                    this.ajq((d) => d.yi = this.agn);
                    break;
                case "LegendSliceLabelFormat":
                    this.ajq((d) => d.aai = this.ai7);
                    break;
                case "LegendSliceLabelFormatSpecifiers":
                    this.ajq((d) => d.yg = this.ago);
                    break;
                case "LegendOthersSliceLabelFormat":
                    this.ajq((d) => d.aam = this.ain);
                    break;
                case "LegendOthersSliceLabelFormatSpecifiers":
                    this.ajq((d) => d.yh = this.agl);
                    break;
                case "SweepDirection":
                    if (this.angleAxis != null) {
                        if (this.ag0 != 0) {
                            if (this.ag0 == 1) {
                                this.angleAxis.ch = false;
                            }
                            else {
                                this.angleAxis.ch = true;
                            }
                        }
                        else {
                            this.angleAxis.ch = this.zy;
                        }
                    }
                    break;
                case "StartAngle":
                    if (this.angleAxis != null) {
                        this.angleAxis.nb = isNaN_(this.ahw) ? 0 : this.ahw;
                    }
                    break;
                case "RadiusExtent":
                    if (this.valueAxis != null) {
                        this.valueAxis.nz = isNaN_(this.ahv) ? 0.65 : this.ahv;
                    }
                    break;
                case "OthersCategoryText":
                    if (this.angleAxis != null) {
                        this.angleAxis.oa = this.aiw;
                    }
                    break;
                case "OthersCategoryType":
                    if (this.angleAxis != null) {
                        this.angleAxis.nu = this.agy;
                    }
                    break;
                case "OthersCategoryThreshold":
                    if (this.angleAxis != null) {
                        this.angleAxis.n7 = this.ahu;
                    }
                    break;
                case "InnerExtent":
                    if (this.valueAxis != null) {
                        this.valueAxis.ny = this.aht;
                    }
                    break;
                case "LightSliceLabelColor":
                    this.ui((d) => {
                        if (d.em) {
                            this.ci.setCalloutLightColor(d, this.ajz);
                        }
                    });
                    break;
                case "DarkSliceLabelColor":
                    this.ui((d) => {
                        if (d.em) {
                            this.ci.setCalloutDarkColor(d, this.ajy);
                        }
                    });
                    break;
                case "ValueMemberPath":
                    if (c != null) {
                        this.um((d) => {
                            if (typeCast(AnchoredRadialSeries.$, d) !== null) {
                                let e = d;
                                e.acm = this.ajn;
                            }
                        });
                        this.angleAxis.og = this.ajn;
                    }
                    else {
                        this.vr();
                    }
                    break;
                case "LabelMemberPath":
                    if (c != null) {
                        let d = this.aij;
                        this.angleAxis.f1 = d;
                    }
                    else {
                        this.vr();
                    }
                    break;
                case "AngleAxisInterval":
                    this.angleAxis.m8 = this.ahr;
                    break;
                case "ValueAxisInterval":
                    this.valueAxis.l2 = this.ahz;
                    break;
                case "ValueAxisFavorLabellingScaleEnd":
                    this.valueAxis.le = this.ahf;
                    break;
                case "ValueAxisAutoRangeBufferMode":
                    this.valueAxis.kv = this.agq;
                    break;
                case "AngleAxisMinorInterval":
                    this.angleAxis.m9 = this.ahs;
                    break;
                case "ValueAxisMinorInterval":
                    this.valueAxis.l7 = this.ah2;
                    break;
                case "ValueAxisIsLogarithmic":
                    this.valueAxis.lj = this.ahg;
                    break;
                case "ValueAxisLogarithmBase":
                    this.valueAxis.ma = this.ah4;
                    break;
                case "ValueAxisMinimumValue":
                    this.valueAxis.l6 = this.ah1;
                    break;
                case "ValueAxisMaximumValue":
                    this.valueAxis.l5 = this.ah0;
                    break;
                case "MarkerCollision":
                    this.un((e, f) => this.t3(e, f));
                    break;
                case "ValueAxisAbbreviateLargeNumbers":
                    this.ae0((e) => e.lb = this.ahe);
                    break;
            }
        }
        get ai7() {
            return this.aic;
        }
        set ai7(a) {
            let b = this.ai7;
            if (a != b) {
                this.aic = a;
                this.vl("SliceLabelFormat", b, this.ai7);
            }
        }
        get ago() {
            return this.agk;
        }
        set ago(a) {
            let b = this.ago;
            if (a != b) {
                this.agk = a;
                this.vl("SliceLabelFormatSpecifiers", b, this.ago);
            }
        }
        get air() {
            return this.ah8;
        }
        set air(a) {
            let b = this.air;
            if (a != b) {
                this.ah8 = a;
                this.vl("LegendSliceLabelFormat", b, this.air);
            }
        }
        get agm() {
            return this.agi;
        }
        set agm(a) {
            let b = this.agm;
            if (a != b) {
                this.agi = a;
                this.vl("LegendSliceLabelFormatSpecifiers", b, this.agm);
            }
        }
        get ai0() {
            return this.aia;
        }
        set ai0(a) {
            let b = this.ai0;
            if (a != b) {
                this.aia = a;
                this.vl("OthersSliceLabelFormat", b, this.ai0);
            }
        }
        get agn() {
            return this.agj;
        }
        set agn(a) {
            let b = this.agn;
            if (a != b) {
                this.agj = a;
                this.vl("OthersSliceLabelFormatSpecifiers", b, this.agn);
            }
        }
        get ain() {
            return this.ah7;
        }
        set ain(a) {
            let b = this.ain;
            if (a != b) {
                this.ah7 = a;
                this.vl("LegendOthersSliceLabelFormat", b, this.ain);
            }
        }
        get agl() {
            return this.agh;
        }
        set agl(a) {
            let b = this.agl;
            if (a != b) {
                this.agh = a;
                this.vl("LegendOthersSliceLabelFormatSpecifiers", b, this.agl);
            }
        }
        get aht() {
            return this.ahj;
        }
        set aht(a) {
            let b = this.aht;
            if (a != b) {
                this.ahj = a;
                this.vl("InnerExtent", b, this.aht);
            }
        }
        get ag0() {
            return this.agz;
        }
        set ag0(a) {
            let b = this.ag0;
            if (a != b) {
                this.agz = a;
                this.vl("SweepDirection", enumGetBox(PieChartSweepDirection_$type, b), enumGetBox(PieChartSweepDirection_$type, this.ag0));
            }
        }
        get ags() {
            return this.agr;
        }
        set ags(a) {
            let b = this.ags;
            if (a != b) {
                this.agr = a;
                this.vl("SliceLabelPositionMode", enumGetBox(CalloutCollisionMode_$type, b), enumGetBox(CalloutCollisionMode_$type, this.ags));
            }
        }
        get ajz() {
            return this.ajx;
        }
        set ajz(a) {
            let b = this.ajz;
            if (a != b) {
                this.ajx = a;
                this.vl("LightSliceLabelColor", b, this.ajz);
            }
        }
        get ajy() {
            return this.ajw;
        }
        set ajy(a) {
            let b = this.ajy;
            if (a != b) {
                this.ajw = a;
                this.vl("DarkSliceLabelColor", b, this.ajy);
            }
        }
        get ajn() {
            return this.aid;
        }
        set ajn(a) {
            let b = this.ajn;
            if (a != b) {
                this.aid = a;
                this.vl("ValueMemberPath", b, this.ajn);
            }
        }
        get ail() {
            return this.ah6;
        }
        set ail(a) {
            let b = this.ah6;
            if (a != b) {
                this.ah6 = a;
                this.vl("LegendLabelMemberPath", b, this.ah6);
            }
        }
        get agy() {
            return this.agx;
        }
        set agy(a) {
            let b = this.agy;
            if (a != b) {
                this.agx = a;
                this.vl("OthersCategoryType", enumGetBox(OthersCategoryType_$type, b), enumGetBox(OthersCategoryType_$type, this.agy));
            }
        }
        get ahu() {
            return this.ahk;
        }
        set ahu(a) {
            let b = this.ahu;
            if (a != b) {
                this.ahk = a;
                this.vl("OthersCategoryThreshold", b, this.ahu);
            }
        }
        get aiw() {
            return this.ah9;
        }
        set aiw(a) {
            let b = this.aiw;
            if (a != b) {
                this.ah9 = a;
                this.vl("OthersCategoryText", b, this.aiw);
            }
        }
        get aij() {
            return this.ah5;
        }
        set aij(a) {
            let b = this.aij;
            if (a != b) {
                this.ah5 = a;
                this.vl("LabelMemberPath", b, this.aij);
            }
        }
        get ahf() {
            return this.aha;
        }
        set ahf(a) {
            let b = this.ahf;
            if (a != b) {
                this.aha = a;
                this.vl("ValueAxisFavorLabellingScaleEnd", b, this.ahf);
            }
        }
        get agq() {
            return this.agp;
        }
        set agq(a) {
            let b = this.agq;
            if (a != b) {
                this.agp = a;
                this.vl("ValueAxisAutoRangeBufferMode", enumGetBox(AxisRangeBufferMode_$type, b), enumGetBox(AxisRangeBufferMode_$type, this.agq));
            }
        }
        get ahr() {
            return this.ahh;
        }
        set ahr(a) {
            let b = this.ahr;
            if (a != b) {
                this.ahh = a;
                this.vl("AngleAxisInterval", b, this.ahr);
            }
        }
        get ahs() {
            return this.ahi;
        }
        set ahs(a) {
            let b = this.ahs;
            if (a != b) {
                this.ahi = a;
                this.vl("AngleAxisMinorInterval", b, this.ahs);
            }
        }
        get ahz() {
            return this.ahn;
        }
        set ahz(a) {
            let b = this.ahz;
            if (a != b) {
                this.ahn = a;
                this.vl("ValueAxisInterval", b, this.ahz);
            }
        }
        get ahg() {
            return this.ahb;
        }
        set ahg(a) {
            let b = this.ahg;
            if (a != b) {
                this.ahb = a;
                this.vl("ValueAxisIsLogarithmic", b, this.ahg);
            }
        }
        get ah4() {
            return this.ah3;
        }
        set ah4(a) {
            let b = this.ah4;
            if (a != b) {
                this.ah3 = a;
                this.vl("ValueAxisLogarithmBase", b, this.ah4);
            }
        }
        get ah1() {
            return this.ahp;
        }
        set ah1(a) {
            let b = this.ah1;
            if (a != b) {
                this.ahp = a;
                this.vl("ValueAxisMinimumValue", b, this.ah1);
            }
        }
        get ah0() {
            return this.aho;
        }
        set ah0(a) {
            let b = this.ah0;
            if (a != b) {
                this.aho = a;
                this.vl("ValueAxisMaximumValue", b, this.ah0);
            }
        }
        get ah2() {
            return this.ahq;
        }
        set ah2(a) {
            let b = this.ah2;
            if (a != b) {
                this.ahq = a;
                this.vl("ValueAxisMinorInterval", b, this.ah2);
            }
        }
        get ahy() {
            return this.valueAxis.ly;
        }
        get ahx() {
            return this.valueAxis.lx;
        }
        get ahv() {
            return this.ahl;
        }
        set ahv(a) {
            let b = this.ahv;
            if (a != b) {
                this.ahl = a;
                this.vl("RadiusExtent", b, this.ahv);
            }
        }
        get ahw() {
            return this.ahm;
        }
        set ahw(a) {
            let b = this.ahw;
            if (a != b) {
                this.ahm = a;
                this.vl("StartAngle", b, this.ahw);
            }
        }
        get ai5() {
            return this.aib;
        }
        set ai5(a) {
            let b = this.ai5;
            if (a != b) {
                this.aib = a;
                this.vl("SliceLabelContentSeparator", b, this.ai5);
            }
        }
        get ag6() {
            return this.ag4;
        }
        set ag6(a) {
            let b = this.ag6;
            if (a != b) {
                this.ag4 = a;
                this.vl("SliceLabelContentMode", enumGetBox(RadialLabelMode_$type, b), enumGetBox(RadialLabelMode_$type, this.ag6));
            }
        }
        get ag5() {
            return this.ag3;
        }
        set ag5(a) {
            let b = this.ag5;
            if (a != b) {
                this.ag3 = a;
                this.vl("LegendSliceLabelContentMode", enumGetBox(RadialLabelMode_$type, b), enumGetBox(RadialLabelMode_$type, this.ag5));
            }
        }
        get ahc() {
            return this.ag8;
        }
        set ahc(a) {
            let b = this.ahc;
            if (a != b) {
                this.ag8 = a;
                this.vl("AngleAxisFavorLabellingScaleEnd", b, this.ahc);
            }
        }
        get ahe() {
            return this.ag9;
        }
        set ahe(a) {
            let b = this.ahe;
            if (a != b) {
                this.ag9 = a;
                this.vl("ValueAxisAbbreviateLargeNumbers", b, this.ahe);
            }
        }
        get agu() {
            return this.agt;
        }
        set agu(a) {
            let b = this.agt;
            if (a != b) {
                this.agt = a;
                this.vl("MarkerCollision", enumGetBox(CollisionAvoidanceType_$type, b), enumGetBox(CollisionAvoidanceType_$type, this.agt));
            }
        }
    }
    DataPieBaseChart.$t = markType(DataPieBaseChart, 'DataPieBaseChart', RadialBaseChart.$);
    return DataPieBaseChart;
})();
