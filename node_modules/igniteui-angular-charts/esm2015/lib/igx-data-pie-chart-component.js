import { Component, ViewContainerRef, ViewChild, Input, ChangeDetectionStrategy } from '@angular/core';
import { AngularRenderer, AngularWrapper } from "igniteui-angular-core";
import { TypeRegistrar } from "igniteui-angular-core";
import { DataPieChart } from './DataPieChart';
import { DataPieChartType_$type } from './DataPieChartType';
import { CategoryTransitionInMode_$type } from './CategoryTransitionInMode';
import { TransitionInSpeedType_$type } from './TransitionInSpeedType';
import { ensureEnum, ensureBool, NamePatcher } from "igniteui-angular-core";
import { DataChartStylingDefaults } from './DataChartStylingDefaults';
import { DataSeriesType } from "igniteui-angular-core";
import { IgxDataContext } from "igniteui-angular-core";
import { IgxProportionalCategoryAngleAxisComponent } from './igx-proportional-category-angle-axis-component';
import { IgxNumericRadiusAxisComponent } from './igx-numeric-radius-axis-component';
import { IgxDataPieBaseChartComponent } from './igx-data-pie-base-chart-component';
import * as i0 from "@angular/core";
/**
 * Represents a DataPie chart control that can plot DataPie data
*/
export let IgxDataPieChartComponent = /*@__PURE__*/ (() => {
    class IgxDataPieChartComponent extends IgxDataPieBaseChartComponent {
        constructor(renderer, _elRef, ngZone, injector, componentFactoryResolver) {
            super();
            this.renderer = renderer;
            this._elRef = _elRef;
            this.ngZone = ngZone;
            this.injector = injector;
            this.componentFactoryResolver = componentFactoryResolver;
            this._dataSource = null;
            this._defaultTooltips = null;
            if (this._styling) {
                NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
            }
            this._zoneRunner = (act) => ngZone.run(act);
            this.container = renderer.createElement("div");
            renderer.appendChild(_elRef.element.nativeElement, this.container);
            renderer.setStyle(this.container, "display", "block");
            renderer.setStyle(this.container, "width", "100%");
            renderer.setStyle(this.container, "height", "100%");
            var root;
            root = this.container;
            if (this.container != null) {
                root = this.container;
            }
            var ren = new AngularRenderer(root, this.renderer, window.document, this.ngZone, true, DataChartStylingDefaults);
            this._wrapper = ren;
            var chart = this.i;
            this._chart = chart;
            if (chart.angleAxis) {
                let x = new IgxProportionalCategoryAngleAxisComponent();
                x._provideRenderer(ren);
                x._implementation = chart.angleAxis;
                chart.angleAxis.externalObject = x;
            }
            if (chart.valueAxis) {
                let y = new IgxNumericRadiusAxisComponent();
                y._provideRenderer(ren);
                y._implementation = chart.valueAxis;
                chart.valueAxis.externalObject = y;
            }
            chart.provideContainer(ren);
            this.bindData();
            chart.notifyResized();
            ren.addSizeWatcher(() => {
                this._chart.notifyResized();
            });
        }
        set height(value) {
            this._height = value;
            this.renderer.setStyle(this._elRef.element.nativeElement, "height", value);
            this._chart.notifyResized();
        }
        get height() {
            return this._height;
        }
        set width(value) {
            this._width = value;
            this.renderer.setStyle(this._elRef.element.nativeElement, "width", value);
            this._chart.notifyResized();
        }
        get width() {
            return this._width;
        }
        ngOnDestroy() {
            this._chart.destroy();
            this._wrapper.destroy();
        }
        createImplementation() {
            return new DataPieChart();
        }
        get i() {
            return this._implementation;
        }
        createSeriesComponent(type) {
            if (TypeRegistrar.isRegistered(type)) {
                let s = TypeRegistrar.create(type);
                s.owner = this;
                s._provideRenderer(this.renderer);
                return s;
            }
            else {
                //we shouldn't get here, hopefully.
                throw Error("series type not loaded: " + type);
            }
        }
        createSeries(type) {
            switch (type) {
                case DataSeriesType.Pie:
                    return this.createSeriesComponent('IgxRadialPieSeriesComponent');
                case DataSeriesType.ItemToolTipLayer:
                    return this.createSeriesComponent('IgxItemToolTipLayerComponent');
                case DataSeriesType.CategoryToolTipLayer:
                    return this.createSeriesComponent('IgxCategoryToolTipLayerComponent');
                case DataSeriesType.CrosshairLayer:
                    return this.createSeriesComponent('IgxCrosshairLayerComponent');
                case DataSeriesType.FinalValueLayer:
                    return this.createSeriesComponent('IgxFinalValueLayerComponent');
                case DataSeriesType.CalloutLayer:
                    return this.createSeriesComponent('IgxCalloutLayerComponent');
                case DataSeriesType.CategoryHighlightLayer:
                    return this.createSeriesComponent('IgxCategoryHighlightLayerComponent');
                case DataSeriesType.CategoryItemHighlightLayer:
                    return this.createSeriesComponent('IgxCategoryItemHighlightLayerComponent');
                case DataSeriesType.DataToolTipLayer:
                    return this.createSeriesComponent('IgxDataToolTipLayerComponent');
                case DataSeriesType.ValueLayer:
                    return this.createSeriesComponent('IgxValueLayerComponent');
                default:
                    return this.createSeriesComponent('IgxRadialPieSeriesComponent');
            }
        }
        set dataSource(value) {
            this._dataSource = value;
            this.bindData();
        }
        get dataSource() {
            return this._dataSource;
        }
        bindData() {
            if (this._chart != null && this._chart !== undefined) {
                this._chart.itemsSource = this._dataSource;
            }
        }
        ngAfterContentInit() {
            if (TypeRegistrar.isRegistered("IgxDataChartDefaultTooltipsComponent")) {
                let c = TypeRegistrar.get("IgxDataChartDefaultTooltipsComponent");
                let cf = this.componentFactoryResolver.resolveComponentFactory(c);
                //let cr = cf.create(this.injector);
                let cr = this._dynamicContent.createComponent(cf);
                this._defaultTooltips = cr;
                cr.instance.onContentReady.subscribe(() => {
                    this._onDefaultTooltipsReady(cr);
                });
                this.container.appendChild(cr.location.nativeElement);
            }
            this._styling(this.container, this);
        }
        createTooltip() {
            if (!TypeRegistrar.isRegistered("IgxTooltipContainerComponent")) {
                return null;
            }
            let t = TypeRegistrar.get("IgxTooltipContainerComponent");
            let cf = this.componentFactoryResolver.resolveComponentFactory(t);
            //let cr = cf.create(this.injector);
            let cr = this._dynamicContent.createComponent(cf);
            let ele = cr.location.nativeElement;
            let self = this;
            ele.updateToolTip = function (c, isSubContent) {
                if (c.externalObject) {
                    c = c.externalObject;
                }
                else {
                    let ext = new IgxDataContext();
                    ext._implementation = c;
                    c = ext;
                }
                if (!isSubContent) {
                    if (ele.parentElement != self.container) {
                        if (ele.parentElement != null) {
                            ele.parentElement.removeChild(ele);
                        }
                        self.container.appendChild(ele);
                    }
                }
                else {
                    c.isSubContent = true;
                }
                cr.instance.context = c;
                ele.style.display = "block";
                return true;
            };
            ele.hideToolTip = function () {
                ele.style.display = "none";
            };
            ele.style.display = "none";
            return cr;
        }
        _ensureTooltipCreated(series) {
            series._ensureTooltipCreated(() => this.createTooltip(), (ele) => {
                let wrapper = new AngularWrapper(ele, this.renderer, this.ngZone);
                wrapper.updateToolTip = ele.updateToolTip;
                wrapper.hideToolTip = ele.hideToolTip;
                return wrapper;
            });
        }
        _createAngleAxis() {
            let x = new IgxProportionalCategoryAngleAxisComponent();
            x._provideRenderer(this.renderer);
            return x.i;
        }
        _createValueAxis() {
            let y = new IgxNumericRadiusAxisComponent();
            y.provideRenderer(this.renderer);
            return y.i;
        }
        _ensureDefaultTooltip(series) {
            if (this._defaultTooltips == null) {
                return;
            }
            this._defaultTooltips.instance["ensureDefaultTooltip"](series);
        }
        _onDefaultTooltipsReady(cr) {
            if (this.i.dataChart) {
                var currSeries = this.i.dataChart.series;
                for (var i = 0; i < currSeries.count; i++) {
                    if (currSeries.item(i).externalObject.showDefaultTooltip) {
                        this._ensureDefaultTooltip(currSeries.item(i).externalObject);
                    }
                }
            }
        }
        /**
     * Gets or sets the duration used for animating series plots when the chart is loading into view
    */
        get transitionInDuration() {
            return this.i.ake;
        }
        set transitionInDuration(v) {
            this.i.ake = +v;
        }
        /**
         * Gets or sets the duration used for animating series plots when the series is leaving view
        */
        get transitionOutDuration() {
            return this.i.akf;
        }
        set transitionOutDuration(v) {
            this.i.akf = +v;
        }
        /**
         * Gets or sets the easing function used for animating series plots when the chart is loading into view
         * This can be set to one of the known values "linear" or "cubic," or it can be set to an easing function which takes a single numeric parameter and returns a number.
        */
        get transitionInEasingFunction() {
            return this.i.aj8;
        }
        set transitionInEasingFunction(v) {
            this.i.aj8 = v;
        }
        /**
         * Gets or sets the easing function used for animating series plots when the chart is loading into view
         * This can be set to one of the known values "linear" or "cubic," or it can be set to an easing function which takes a single numeric parameter and returns a number.
        */
        get transitionOutEasingFunction() {
            return this.i.aj9;
        }
        set transitionOutEasingFunction(v) {
            this.i.aj9 = v;
        }
        /**
         * Gets the domain type of this chart
        */
        get domainType() {
            return this.i.cf;
        }
        /**
         * Gets or sets the type of chart series to generate from the data.
        */
        get chartType() {
            return this.i.aj3;
        }
        set chartType(v) {
            this.i.aj3 = ensureEnum(DataPieChartType_$type, v);
        }
        /**
         * Gets or sets whether animation of series plots is enabled when the chart is loading into view
        */
        get isTransitionInEnabled() {
            return this.i.akb;
        }
        set isTransitionInEnabled(v) {
            this.i.akb = ensureBool(v);
        }
        /**
         * Gets or sets the method that determines how to animate series plots when the chart is loading into view
        */
        get transitionInMode() {
            return this.i.aj1;
        }
        set transitionInMode(v) {
            this.i.aj1 = ensureEnum(CategoryTransitionInMode_$type, v);
        }
        /**
         * Gets or sets the arrival speed used for animating series plots when the chart is loading into view
        */
        get transitionInSpeedType() {
            return this.i.aj5;
        }
        set transitionInSpeedType(v) {
            this.i.aj5 = ensureEnum(TransitionInSpeedType_$type, v);
        }
        /**
     * Export serialized visual data.
    
    */
        exportSerializedVisualData() {
            let iv = this.i.akh();
            return (iv);
        }
    }
    IgxDataPieChartComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: IgxDataPieChartComponent, deps: [{ token: i0.Renderer2 }, { token: i0.ViewContainerRef }, { token: i0.NgZone }, { token: i0.Injector }, { token: i0.ComponentFactoryResolver }], target: i0.ɵɵFactoryTarget.Component });
    IgxDataPieChartComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: IgxDataPieChartComponent, selector: "igx-data-pie-chart", inputs: { height: "height", width: "width", dataSource: "dataSource", transitionInDuration: "transitionInDuration", transitionOutDuration: "transitionOutDuration", transitionInEasingFunction: "transitionInEasingFunction", transitionOutEasingFunction: "transitionOutEasingFunction", chartType: "chartType", isTransitionInEnabled: "isTransitionInEnabled", transitionInMode: "transitionInMode", transitionInSpeedType: "transitionInSpeedType" }, host: { classAttribute: "ig-data-pie-chart igx-data-pie-chart" }, providers: [], viewQueries: [{ propertyName: "_dynamicContent", first: true, predicate: ["dynamicContent"], descendants: true, read: ViewContainerRef, static: true }], usesInheritance: true, ngImport: i0, template: `<ng-container #dynamicContent></ng-container>`, isInline: true, styles: ["\n\t\t:host {\n\t\t\tdisplay: block;\n\t\t}\n\t"], changeDetection: i0.ChangeDetectionStrategy.OnPush });
    return IgxDataPieChartComponent;
})();
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: IgxDataPieChartComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'igx-data-pie-chart',
                    template: `<ng-container #dynamicContent></ng-container>`,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [],
                    host: { 'class': 'ig-data-pie-chart igx-data-pie-chart' },
                    styles: [`
		:host {
			display: block;
		}
	`]
                }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }, { type: i0.ViewContainerRef }, { type: i0.NgZone }, { type: i0.Injector }, { type: i0.ComponentFactoryResolver }]; }, propDecorators: { _dynamicContent: [{
                type: ViewChild,
                args: ["dynamicContent", { read: ViewContainerRef, static: true }]
            }], height: [{
                type: Input
            }], width: [{
                type: Input
            }], dataSource: [{
                type: Input
            }], transitionInDuration: [{
                type: Input
            }], transitionOutDuration: [{
                type: Input
            }], transitionInEasingFunction: [{
                type: Input
            }], transitionOutEasingFunction: [{
                type: Input
            }], chartType: [{
                type: Input
            }], isTransitionInEnabled: [{
                type: Input
            }], transitionInMode: [{
                type: Input
            }], transitionInSpeedType: [{
                type: Input
            }] } });
