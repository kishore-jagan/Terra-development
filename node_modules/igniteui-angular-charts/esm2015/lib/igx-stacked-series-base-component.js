import { EventEmitter, Output, Component, Input } from '@angular/core';
import { delegateCombine } from "igniteui-angular-core";
import { toPoint, ensureBool } from "igniteui-angular-core";
import { TypeRegistrar } from "igniteui-angular-core";
import { IgxStackedSeriesCreatedEventArgs } from './igx-stacked-series-created-event-args';
import { IgxCategorySeriesComponent } from "./igx-category-series-component";
import { ContentChildren } from '@angular/core';
import { NotifyCollectionChangedAction } from "igniteui-angular-core";
import { IgxStackedFragmentSeriesComponent } from './igx-stacked-fragment-series-component';
import { CollectionAdapter } from "igniteui-angular-core";
import { IgxStackedSeriesCollection } from './igx-stacked-series-collection';
import * as i0 from "@angular/core";
/**
 * Represents a base class for stacked series.
*/
export let IgxStackedSeriesBaseComponent = /*@__PURE__*/ (() => {
    class IgxStackedSeriesBaseComponent extends IgxCategorySeriesComponent {
        constructor() {
            super();
            this._seriesAdapter = null;
            /**
             * The series actually present in the chart. Do not directly modify this array.
             * This array's contents can be modified by causing Angular to reproject the child content.
             * Or adding and removing series from the manual series collection on the series property.
             */
            this.actualSeries = [];
            this._series = null;
            this._seriesCreated = null;
            //=============================
            this._seriesAdapter = new CollectionAdapter([], this.i.series, this.actualSeries, (c) => c.i, (i) => {
                i.owner = this;
                //(<any>i)._provideRenderer(this._dataSource);
                //i.provideData(this._dataSource);
                //this._ensureDefaultTooltip(i);
                //this._ensureTooltipCreated(i);
            }, (i) => {
                //(<any>i)._provideRenderer(null);
                //i.provideData(null); 
            });
            //=============================
        }
        createImplementation() {
            return null;
        }
        ngOnInit() {
        }
        get i() {
            return this._implementation;
        }
        //=============================
        ngAfterContentInit() {
            this._seriesAdapter.updateQuery(this.fragments);
        }
        /**
         * A collection or manually added series for the chart.
        */
        get series() {
            if (this._series === null) {
                let coll = new IgxStackedSeriesCollection();
                let inner = coll._innerColl;
                inner.addListener((sender, e) => {
                    switch (e.action) {
                        case NotifyCollectionChangedAction.Add:
                            this._seriesAdapter.insertManualItem(e.newStartingIndex, e.newItems.item(0));
                            break;
                        case NotifyCollectionChangedAction.Remove:
                            this._seriesAdapter.removeManualItemAt(e.oldStartingIndex);
                            break;
                        case NotifyCollectionChangedAction.Replace:
                            this._seriesAdapter.removeManualItemAt(e.oldStartingIndex);
                            this._seriesAdapter.insertManualItem(e.newStartingIndex, e.newItems.item(0));
                            break;
                        case NotifyCollectionChangedAction.Reset:
                            this._seriesAdapter.clearManualItems();
                            break;
                    }
                });
                this._series = coll;
            }
            return this._series;
        }
        //=============================
        static _createFromInternal(internal) {
            if (!internal) {
                return null;
            }
            if (!internal.$type) {
                return null;
            }
            let name = internal.$type.name;
            let externalName = "Igx" + name + "Component";
            if (!TypeRegistrar.isRegistered(externalName)) {
                return null;
            }
            return TypeRegistrar.create(externalName);
        }
        /**
     * Gets or sets whether series should be automatically generated. Reqiures the use of GroupBy as the ItemsSource.
    */
        get autoGenerateSeries() {
            return this.i.aam;
        }
        set autoGenerateSeries(v) {
            this.i.aam = ensureBool(v);
        }
        /**
         * Gets or sets whether the order of the fragment series should be reversed in the legend.
        */
        get reverseLegendOrder() {
            return this.i.aao;
        }
        set reverseLegendOrder(v) {
            this.i.aao = ensureBool(v);
        }
        /**
         * Checks if this series is a stacked series
        */
        get isStacked() {
            return this.i.isStacked;
        }
        get isPercentBased() {
            return this.i.aan;
        }
        findByName(name) {
            var baseResult = super.findByName(name);
            if (baseResult) {
                return baseResult;
            }
            if (this.series != null && this.series.findByName && this.series.findByName(name)) {
                return this.series.findByName(name);
            }
            return null;
        }
        /**
     * Called to notify about changes to indexed-based properties, e.g. Brushes, Outlines, MarkerBrushes, MarkerOutlines and refresh series
    
    */
        notifyIndexedPropertiesChanged() {
            this.i.qc();
        }
        /**
         * Simulates a pointer hover over the series surface.
        
        * @param point  * The pointer position relative to the series viewport over which to hover.
        */
        simulateHover(point) {
            this.i.r0(toPoint(point));
        }
        /**
         * Scrolls the series to display the item for the specified data item.
         * The series is scrolled by the minimum amount required to place the specified data item within
         * the central 80% of the visible axis.
        
        * @param item  * The data item (item) to scroll to.
        */
        scrollIntoView(item) {
            let iv = this.i.gb(item);
            return (iv);
        }
        replayTransitionIn() {
            this.i.rr();
        }
        /**
         * Event raised when a new fragment series is automatically generated.
        */
        get seriesCreated() {
            if (this._seriesCreated == null) {
                this._seriesCreated = new EventEmitter();
                this.i.seriesCreated = delegateCombine(this.i.seriesCreated, (o, e) => {
                    this._runInZone(() => {
                        let outerArgs = new IgxStackedSeriesCreatedEventArgs();
                        outerArgs._provideImplementation(e);
                        if (this.beforeSeriesCreated) {
                            this.beforeSeriesCreated(this, outerArgs);
                        }
                        this._seriesCreated.emit({
                            sender: this,
                            args: outerArgs
                        });
                    });
                });
            }
            return this._seriesCreated;
        }
    }
    IgxStackedSeriesBaseComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: IgxStackedSeriesBaseComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    IgxStackedSeriesBaseComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: IgxStackedSeriesBaseComponent, selector: "ng-component", inputs: { autoGenerateSeries: "autoGenerateSeries", reverseLegendOrder: "reverseLegendOrder" }, outputs: { seriesCreated: "seriesCreated" }, queries: [{ propertyName: "fragments", predicate: IgxStackedFragmentSeriesComponent }], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
    return IgxStackedSeriesBaseComponent;
})();
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: IgxStackedSeriesBaseComponent, decorators: [{
            type: Component,
            args: [{
                    template: ``,
                }]
        }], ctorParameters: function () { return []; }, propDecorators: { fragments: [{
                type: ContentChildren,
                args: [IgxStackedFragmentSeriesComponent]
            }], autoGenerateSeries: [{
                type: Input
            }], reverseLegendOrder: [{
                type: Input
            }], seriesCreated: [{
                type: Output
            }] } });
