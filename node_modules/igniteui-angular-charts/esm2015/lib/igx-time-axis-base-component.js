import { EventEmitter, Output, Component, Input } from '@angular/core';
import { delegateCombine } from "igniteui-angular-core";
import { IgxCategoryAxisBaseComponent } from "./igx-category-axis-base-component";
import { ensureBool } from "igniteui-angular-core";
import * as i0 from "@angular/core";
/**
 * Represents an category-based horizontal X axis that uses a DateTime scale.
*
* Represents horizontal axis that uses a DateTime scale.
*
* ```html
* <igx-data-chart
*     [dataSource]="data">
*     <igx-time-x-axis
* 		dateTimeMemberPath="date"
* 		#xAxis>
*     </igx-time-x-axis>
* </igx-data-chart>
* ```
*
* ```ts
* let xAxis = new IgxTimeXAxisComponent();
* xAxis.dataTimeMemberPath="date";
* this.chart.axes.add(xAxis);
* ```
*/
export let IgxTimeAxisBaseComponent = /*@__PURE__*/ (() => {
    class IgxTimeAxisBaseComponent extends IgxCategoryAxisBaseComponent {
        constructor() {
            super();
            this._actualMinimumValueChange = null;
            this._actualMaximumValueChange = null;
        }
        /**
                                     * @hidden
                                     */
        get i() {
            return this._implementation;
        }
        /**
         * Gets or sets the DateTime mapping property for the axis.
        *
        * Use `DateTimeMemberPath` property for DateTime mapping with the axis.
        *
        * ```html
        * <igx-data-chart
        *     [dataSource]="data">
        *     <igx-time-x-axis
        * 		dateTimeMemberPath="date"
        * 		#xAxis>
        *     </igx-time-x-axis>
        * </igx-data-chart>
        * ```
        *
        * ```ts
        * let xAxis = new IgxTimeXAxisComponent();
        * xAxis.dataTimeMemberPath="date";
        * this.chart.axes.add(xAxis);
        * ```
        */
        get dateTimeMemberPath() {
            return this.i.dateTimeMemberPath;
        }
        set dateTimeMemberPath(v) {
            this.i.dateTimeMemberPath = v;
        }
        /**
         * Gets or sets whether the data assigned to the date time axis should be considered pre-sorted by date/time.
        *
        * Use `IsDataPreSorted` property to decide if the data assigned to the date time axis should be considered pre-sorted by date/time.
        */
        get isDataPreSorted() {
            return this.i.mo;
        }
        set isDataPreSorted(v) {
            this.i.mo = ensureBool(v);
        }
        /**
         * Gets the coerced minimum value.
        *
        * Use `ActualMinimumValue` to get the coerced maximum value.
        */
        get actualMinimumValue() {
            return this.i.actualMinimumValue;
        }
        set actualMinimumValue(v) {
            this.i.actualMinimumValue = v;
        }
        /**
         * Gets the coerced maximum value.
        *
        * Use `ActualMaximumValue` to get the  coerced maximum value
        */
        get actualMaximumValue() {
            return this.i.actualMaximumValue;
        }
        set actualMaximumValue(v) {
            this.i.actualMaximumValue = v;
        }
        /**
         * Gets or sets the axis MinimumValue.
        *
        * Use `MinimumValue` property for axis minimum value.
        *
        * ```ts
        * this.timeXAxis.maximumValue="2019-12-26";
        * ```
        */
        get minimumValue() {
            return this.i.minimumValue;
        }
        set minimumValue(v) {
            this.i.minimumValue = v;
        }
        /**
         * Gets or sets the axis MaximumValue.
        *
        * Use `MaximumValue` property for axis maximum value.
        *
        * ```ts
        * this.timeXAxis.maximumValue="2019-12-26";
        * ```
        */
        get maximumValue() {
            return this.i.maximumValue;
        }
        set maximumValue(v) {
            this.i.maximumValue = v;
        }
        /**
         * Checks if the axis is of date time axis type
        *
        * Use `IsDateTime` property to Checks if the axis is of date time axis type.
        *
        * ```ts
        * const isDT = this.timeXAxis.isDateTime;
        * ```
        */
        get isDateTime() {
            return this.i.ce;
        }
        /**
         * Checks if axis requires sorting of items
        *
        * Use `IsSorting` property to Checks if axis requires sorting of items.
        *
        * ```ts
        * const isDT = this.timeXAxis.isDateTime;
        * ```
        */
        get isSorting() {
            return this.i.cn;
        }
        getFullRange() {
            let iv = this.i.ag();
            return (iv);
        }
        getItemValue(item, memberPathName) {
            let iv = this.i.fy(item, memberPathName);
            return (iv);
        }
        /**
         * Gets the index of the data item with the value nearest the given value.
        
        * @param unscaledValue  * The value to find a value close to.
        */
        getIndexClosestToUnscaledValue(unscaledValue) {
            let iv = this.i.i$f(unscaledValue);
            return (iv);
        }
        /**
         * Updates the axis when the data has been changed.
        
        */
        notifyDataChanged() {
            this.i.i$i();
        }
        get actualMinimumValueChange() {
            if (this._actualMinimumValueChange == null) {
                this._actualMinimumValueChange = new EventEmitter();
                this.i.propertyChanged = delegateCombine(this.i.propertyChanged, (o, e) => {
                    let iv = e;
                    let ext = this.actualMinimumValue;
                    if (this.beforeActualMinimumValueChange) {
                        this.beforeActualMinimumValueChange(this, ext);
                    }
                    this._actualMinimumValueChange.emit(ext);
                });
            }
            return this._actualMinimumValueChange;
        }
        get actualMaximumValueChange() {
            if (this._actualMaximumValueChange == null) {
                this._actualMaximumValueChange = new EventEmitter();
                this.i.propertyChanged = delegateCombine(this.i.propertyChanged, (o, e) => {
                    let iv = e;
                    let ext = this.actualMaximumValue;
                    if (this.beforeActualMaximumValueChange) {
                        this.beforeActualMaximumValueChange(this, ext);
                    }
                    this._actualMaximumValueChange.emit(ext);
                });
            }
            return this._actualMaximumValueChange;
        }
    }
    IgxTimeAxisBaseComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: IgxTimeAxisBaseComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    IgxTimeAxisBaseComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: IgxTimeAxisBaseComponent, selector: "ng-component", inputs: { dateTimeMemberPath: "dateTimeMemberPath", isDataPreSorted: "isDataPreSorted", actualMinimumValue: "actualMinimumValue", actualMaximumValue: "actualMaximumValue", minimumValue: "minimumValue", maximumValue: "maximumValue" }, outputs: { actualMinimumValueChange: "actualMinimumValueChange", actualMaximumValueChange: "actualMaximumValueChange" }, usesInheritance: true, ngImport: i0, template: ``, isInline: true });
    return IgxTimeAxisBaseComponent;
})();
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: IgxTimeAxisBaseComponent, decorators: [{
            type: Component,
            args: [{
                    template: ``,
                }]
        }], ctorParameters: function () { return []; }, propDecorators: { dateTimeMemberPath: [{
                type: Input
            }], isDataPreSorted: [{
                type: Input
            }], actualMinimumValue: [{
                type: Input
            }], actualMaximumValue: [{
                type: Input
            }], minimumValue: [{
                type: Input
            }], maximumValue: [{
                type: Input
            }], actualMinimumValueChange: [{
                type: Output
            }], actualMaximumValueChange: [{
                type: Output
            }] } });
