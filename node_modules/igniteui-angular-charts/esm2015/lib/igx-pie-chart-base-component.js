import { EventEmitter, Output, Component, Input } from '@angular/core';
import { delegateCombine } from "igniteui-angular-core";
import { LabelsPosition_$type } from "./LabelsPosition";
import { Visibility_$type } from "igniteui-angular-core";
import { LeaderLineType_$type } from "./LeaderLineType";
import { OthersCategoryType_$type } from "igniteui-angular-core";
import { IgxIndexCollection } from "./igx-index-collection";
import { SweepDirection_$type } from "igniteui-angular-core";
import { LegendEmptyValuesMode_$type } from "./LegendEmptyValuesMode";
import { SliceSelectionMode_$type } from "./SliceSelectionMode";
import { IgxObjectCollection } from "igniteui-angular-core";
import { IgxLabelClickEventArgs } from "./igx-label-click-event-args";
import { IgxSelectedItemChangingEventArgs } from "./igx-selected-item-changing-event-args";
import { IgxSelectedItemsChangingEventArgs } from "./igx-selected-items-changing-event-args";
import { IgxSelectedItemChangedEventArgs } from "./igx-selected-item-changed-event-args";
import { IgxSelectedItemsChangedEventArgs } from "./igx-selected-items-changed-event-args";
import { IgxSliceClickEventArgs } from "./igx-slice-click-event-args";
import { IgxSliceEventArgs } from "./igx-slice-event-args";
import { TypeRegistrar, Number_$type, Base } from "igniteui-angular-core";
import { NamePatcher, ensureEnum, brushToString, stringToBrush, ensureBool, toBrushCollection, fromBrushCollection, arrayFindByName, toSpinal, initializePropertiesFromCss, toPoint } from "igniteui-angular-core";
import { IndexCollection as IndexCollection_internal } from "./IndexCollection";
import { SyncableObservableCollection$1 } from "igniteui-angular-core";
import { Style } from "igniteui-angular-core";
import { ObjectCollection as ObjectCollection_internal } from "igniteui-angular-core";
import * as i0 from "@angular/core";
/**
 * Represents the base class for the pie chart.
*/
export let IgxPieChartBaseComponent = /*@__PURE__*/ (() => {
    class IgxPieChartBaseComponent {
        constructor() {
            this._explodedSlices = null;
            this._selectedItems = null;
            this.__p = null;
            this._hasUserValues = new Set();
            this._stylingContainer = null;
            this._stylingParent = null;
            this._inStyling = false;
            this._labelClick = null;
            this._selectedItemChanging = null;
            this._selectedItemsChanging = null;
            this._selectedItemChanged = null;
            this._selectedItemsChanged = null;
            this._sliceClick = null;
            this._sliceEnter = null;
            this._sliceLeave = null;
            this._sliceHover = null;
            this._zoneRunner = null;
            if (this._styling) {
                NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
            }
            this._implementation = this.createImplementation();
            this._implementation.externalObject = this;
            this.onImplementationCreated();
            if (this._initializeAdapters) {
                this._initializeAdapters();
            }
        }
        createImplementation() {
            return null;
        }
        ngOnInit() {
        }
        /**
         * @hidden
         */
        get i() {
            return this._implementation;
        } /**
                                     * @hidden
                                     */
        static _createFromInternal(internal) {
            if (!internal) {
                return null;
            }
            if (!internal.$type) {
                return null;
            }
            let name = internal.$type.name;
            let externalName = "Igx" + name + "Component";
            if (!TypeRegistrar.isRegistered(externalName)) {
                return null;
            }
            return TypeRegistrar.create(externalName);
        }
        onImplementationCreated() {
        }
        /**
         * Gets or sets the amount of space between the center and the start of the arc. This property should be set between 0 and 1.
         * If InnerExtent is set to a value greater than 1, it will be interpreted as a percentage, effectively divided by 100.
        */
        get innerExtent() {
            return this.i.da;
        }
        set innerExtent(v) {
            this.i.da = +v;
        }
        /**
         * Gets or Sets the property name that contains the values.
        */
        get valueMemberPath() {
            return this.i.fv;
        }
        set valueMemberPath(v) {
            this.i.fv = v;
        }
        /**
         * Gets or sets the property name that contains the labels.
        */
        get labelMemberPath() {
            return this.i.ej;
        }
        set labelMemberPath(v) {
            this.i.ej = v;
        }
        /**
         * Gets or sets the property name that contains the legend labels.
        */
        get legendLabelMemberPath() {
            return this.i.ez;
        }
        set legendLabelMemberPath(v) {
            this.i.ez = v;
        }
        /**
         * Gets or sets the position of chart labels.
        */
        get labelsPosition() {
            return this.i.az;
        }
        set labelsPosition(v) {
            this.i.az = ensureEnum(LabelsPosition_$type, v);
        }
        /**
         * Gets or sets the color for labels rendered outside of the pie chart.
        */
        get labelOuterColor() {
            return brushToString(this.i.i1);
        }
        set labelOuterColor(v) {
            this.i.i1 = stringToBrush(v);
        }
        /**
         * Gets or sets the color for labels rendered inside of the pie chart.
        */
        get labelInnerColor() {
            return brushToString(this.i.i0);
        }
        set labelInnerColor(v) {
            this.i.i0 = stringToBrush(v);
        }
        /**
         * Gets the actual color for labels rendered outside of the pie chart.
        */
        get actualLabelOuterColor() {
            return brushToString(this.i.iz);
        }
        set actualLabelOuterColor(v) {
            this.i.iz = stringToBrush(v);
        }
        /**
         * Gets the actual color for labels rendered inside of the pie chart.
        */
        get actualLabelInnerColor() {
            return brushToString(this.i.iy);
        }
        set actualLabelInnerColor(v) {
            this.i.iy = stringToBrush(v);
        }
        /**
         * Gets or sets whether the leader lines are visible.
        */
        get leaderLineVisibility() {
            return this.i.je;
        }
        set leaderLineVisibility(v) {
            this.i.je = ensureEnum(Visibility_$type, v);
        }
        /**
         * Gets or sets what type of leader lines will be used for the outside end labels.
        */
        get leaderLineType() {
            return this.i.a0;
        }
        set leaderLineType(v) {
            this.i.a0 = ensureEnum(LeaderLineType_$type, v);
        }
        /**
         * Gets or sets the margin between a label and the end of its leader line. The default is 6 pixels.
        */
        get leaderLineMargin() {
            return this.i.dc;
        }
        set leaderLineMargin(v) {
            this.i.dc = +v;
        }
        /**
         * Gets or sets the ToolTip for the chart.
        */
        get toolTip() {
            return this.i.dr;
        }
        set toolTip(v) {
            this.i.dr = v;
        }
        /**
         * Gets or sets the threshold value that determines if slices are grouped into the Others slice.
        */
        get othersCategoryThreshold() {
            return this.i.dd;
        }
        set othersCategoryThreshold(v) {
            this.i.dd = +v;
        }
        /**
         * Gets or sets whether to use numeric or percent-based threshold value.
        */
        get othersCategoryType() {
            return this.i.a2;
        }
        set othersCategoryType(v) {
            this.i.a2 = ensureEnum(OthersCategoryType_$type, v);
        }
        /**
         * Gets or sets the label of the Others slice.
        */
        get othersCategoryText() {
            return this.i.e6;
        }
        set othersCategoryText(v) {
            this.i.e6 = v;
        }
        /**
         * Determines how much the exploded slice is offset from the center. Value between 0 and 1.
        */
        get explodedRadius() {
            return this.i.c5;
        }
        set explodedRadius(v) {
            this.i.c5 = +v;
        }
        /**
         * Gets or sets the scaling factor of the chart's radius. Value between 0 and 1.
        */
        get radiusFactor() {
            return this.i.dg;
        }
        set radiusFactor(v) {
            this.i.dg = +v;
        }
        /**
         * Gets or sets whether the slices can be selected.
        */
        get allowSliceSelection() {
            return this.i.b9;
        }
        set allowSliceSelection(v) {
            this.i.b9 = ensureBool(v);
        }
        /**
         * Gets or sets whether the slices can be exploded.
        */
        get allowSliceExplosion() {
            return this.i.b8;
        }
        set allowSliceExplosion(v) {
            this.i.b8 = ensureBool(v);
        }
        /**
         * Gets or sets the collection of exploded slice indices.
        */
        get explodedSlices() {
            if (this._explodedSlices === null) {
                let coll = new IgxIndexCollection();
                let innerColl = this.i.explodedSlices;
                if (!innerColl) {
                    innerColl = new IndexCollection_internal();
                }
                this._explodedSlices = coll._fromInner(innerColl);
                this.i.explodedSlices = innerColl;
            }
            return this._explodedSlices;
        }
        set explodedSlices(v) {
            if (this._explodedSlices !== null) {
                this._explodedSlices._setSyncTarget(null);
                this._explodedSlices = null;
            }
            let coll = new IgxIndexCollection();
            this._explodedSlices = coll._fromOuter(v);
            let syncColl = new SyncableObservableCollection$1(Number_$type);
            let innerColl = this.i.explodedSlices;
            if (!innerColl) {
                innerColl = new IndexCollection_internal();
            }
            syncColl._inner = innerColl;
            syncColl.clear();
            this._explodedSlices._setSyncTarget(syncColl);
            this.i.explodedSlices = innerColl;
        }
        /**
         * Gets or sets the pixel amount by which the labels are offset from the edge of the slices.
        */
        get labelExtent() {
            return this.i.db;
        }
        set labelExtent(v) {
            this.i.db = +v;
        }
        /**
         * Gets or sets the starting angle of the chart.
         * The default zero value is equivalent to 3 o'clock.
        */
        get startAngle() {
            return this.i.di;
        }
        set startAngle(v) {
            this.i.di = +v;
        }
        /**
         * Gets or sets the rotational direction of the chart.
        */
        get sweepDirection() {
            return this.i.i3;
        }
        set sweepDirection(v) {
            this.i.i3 = ensureEnum(SweepDirection_$type, v);
        }
        /**
         * Gets or sets the fill brush.
        */
        get othersCategoryFill() {
            return this.i.jb ? this.i.jb.fill : null;
        }
        set othersCategoryFill(v) {
            this.ensureOthersCategoryStyle();
            this.i.jb.fill = v;
        }
        /**
         * Gets or sets the stroke brush.
        */
        get othersCategoryStroke() {
            return this.i.jb ? this.i.jb.stroke : null;
        }
        set othersCategoryStroke(v) {
            this.ensureOthersCategoryStyle();
            this.i.jb.stroke = v;
        }
        /**
         * Gets or sets the stroke thickness.
        */
        get othersCategoryStrokeThickness() {
            return this.i.jb ? this.i.jb.strokeThickness : NaN;
        }
        set othersCategoryStrokeThickness(v) {
            this.ensureOthersCategoryStyle();
            this.i.jb.strokeThickness = +v;
        }
        /**
         * Gets or sets the opacity.
        */
        get othersCategoryOpacity() {
            return this.i.jb ? this.i.jb.opacity : NaN;
        }
        set othersCategoryOpacity(v) {
            this.ensureOthersCategoryStyle();
            this.i.jb.opacity = +v;
        }
        ensureOthersCategoryStyle() {
            if (this.i.jb) {
                return;
            }
            this.i.jb = new Style();
        }
        /**
         * Gets or sets the fill brush.
        */
        get selectedSliceFill() {
            return this.i.jc ? this.i.jc.fill : null;
        }
        set selectedSliceFill(v) {
            this.ensureSelectedStyle();
            this.i.jc.fill = v;
        }
        /**
         * Gets or sets the stroke brush.
        */
        get selectedSliceStroke() {
            return this.i.jc ? this.i.jc.stroke : null;
        }
        set selectedSliceStroke(v) {
            this.ensureSelectedStyle();
            this.i.jc.stroke = v;
        }
        /**
         * Gets or sets the stroke thickness.
        */
        get selectedSliceStrokeThickness() {
            return this.i.jc ? this.i.jc.strokeThickness : NaN;
        }
        set selectedSliceStrokeThickness(v) {
            this.ensureSelectedStyle();
            this.i.jc.strokeThickness = +v;
        }
        /**
         * Gets or sets the opacity.
        */
        get selectedSliceOpacity() {
            return this.i.jc ? this.i.jc.opacity : NaN;
        }
        set selectedSliceOpacity(v) {
            this.ensureSelectedStyle();
            this.i.jc.opacity = +v;
        }
        ensureSelectedStyle() {
            if (this.i.jc) {
                return;
            }
            this.i.jc = new Style();
        }
        /**
         * Gets or sets the palette of brushes to use for coloring the slices.
        */
        get brushes() {
            return fromBrushCollection(this.i.am);
        }
        set brushes(v) {
            this.i.am = toBrushCollection(v);
        }
        /**
         * Gets the actual palette of brushes to use for coloring the slices.
        */
        get actualBrushes() {
            return fromBrushCollection(this.i.ak);
        }
        set actualBrushes(v) {
            this.i.ak = toBrushCollection(v);
        }
        /**
         * Gets or sets the palette of brushes to use for outlines on the slices.
        */
        get outlines() {
            return fromBrushCollection(this.i.an);
        }
        set outlines(v) {
            this.i.an = toBrushCollection(v);
        }
        /**
         * Gets the actual palette of brushes to use for outlines on the slices.
        */
        get actualOutlines() {
            return fromBrushCollection(this.i.al);
        }
        set actualOutlines(v) {
            this.i.al = toBrushCollection(v);
        }
        /**
         * Gets or sets the label format string to use for the label.
        */
        get labelFormat() {
            return this.i.ef;
        }
        set labelFormat(v) {
            this.i.ef = v;
        }
        /**
         * Gets or sets the format specifiers to use with the LabelFormat string.
        */
        get labelFormatSpecifiers() {
            return this.i.ag;
        }
        set labelFormatSpecifiers(v) {
            if (v && !Array.isArray(v) && typeof (v) == "string") {
                const re = /\s*(?:,|\s|$)\s*/gm;
                v = v.split(re);
            }
            this.i.ag = v;
        }
        /**
         * Gets or sets the label format string to use for the label.
        */
        get othersLabelFormat() {
            return this.i.fa;
        }
        set othersLabelFormat(v) {
            this.i.fa = v;
        }
        /**
         * Gets or sets the format specifiers to use with the OthersLabelFormat string.
        */
        get othersLabelFormatSpecifiers() {
            return this.i.aj;
        }
        set othersLabelFormatSpecifiers(v) {
            if (v && !Array.isArray(v) && typeof (v) == "string") {
                const re = /\s*(?:,|\s|$)\s*/gm;
                v = v.split(re);
            }
            this.i.aj = v;
        }
        /**
         * Gets or sets the label format string to use for the label.
        */
        get legendLabelFormat() {
            return this.i.ew;
        }
        set legendLabelFormat(v) {
            this.i.ew = v;
        }
        /**
         * Gets or sets the format specifiers to use with the LegendLabelFormat string.
        */
        get legendLabelFormatSpecifiers() {
            return this.i.ah;
        }
        set legendLabelFormatSpecifiers(v) {
            if (v && !Array.isArray(v) && typeof (v) == "string") {
                const re = /\s*(?:,|\s|$)\s*/gm;
                v = v.split(re);
            }
            this.i.ah = v;
        }
        /**
         * Gets or sets the label format string to use for the label.
        */
        get legendOthersLabelFormat() {
            return this.i.e1;
        }
        set legendOthersLabelFormat(v) {
            this.i.e1 = v;
        }
        /**
         * Gets or sets the format specifiers to use with the LegendOthersLabelFormat string.
        */
        get legendOthersLabelFormatSpecifiers() {
            return this.i.ai;
        }
        set legendOthersLabelFormatSpecifiers(v) {
            if (v && !Array.isArray(v) && typeof (v) == "string") {
                const re = /\s*(?:,|\s|$)\s*/gm;
                v = v.split(re);
            }
            this.i.ai = v;
        }
        /**
         * Gets or sets the LegendItemTemplate property.
         * The legend item control content is created according to the LegendItemTemplate on-demand by
         * the chart object itself.
        */
        get legendItemTemplate() {
            return this.i.legendItemTemplate;
        }
        set legendItemTemplate(v) {
            this.i.legendItemTemplate = v;
        }
        /**
         * Gets or sets the LegendItemBadgeTemplate property.
         * The legend item badge is created according to the LegendItemBadgeTemplate on-demand by
         * the chart object itself.
        */
        get legendItemBadgeTemplate() {
            return this.i.legendItemBadgeTemplate;
        }
        set legendItemBadgeTemplate(v) {
            this.i.legendItemBadgeTemplate = v;
        }
        /**
         * Gets or sets whether the pie chart will handle drag interaction and make them avaiilable in its events.
        */
        get isDragInteractionEnabled() {
            return this.i.ce;
        }
        set isDragInteractionEnabled(v) {
            this.i.ce = ensureBool(v);
        }
        /**
         * Gets or sets whether all surface interactions with the plot area should be disabled.
        */
        get isSurfaceInteractionDisabled() {
            return this.i.cf;
        }
        set isSurfaceInteractionDisabled(v) {
            this.i.cf = ensureBool(v);
        }
        /**
         * Gets or sets whether the pie chart should display mock data when data isn't present.
        */
        get shouldDisplayMockData() {
            return this.i.ch;
        }
        set shouldDisplayMockData(v) {
            this.i.ch = ensureBool(v);
        }
        /**
         * Gets or sets whether the pie chart should use a skeleton style for mock data.
        */
        get shouldUseSkeletonStyleForMockData() {
            return this.i.ci;
        }
        set shouldUseSkeletonStyleForMockData(v) {
            this.i.ci = ensureBool(v);
        }
        /**
         * Determines display mode for zero values in the legend.
         * For example, handling zero values as valid slices and providing them with proper appearance settings.
        */
        get legendEmptyValuesMode() {
            return this.i.a1;
        }
        set legendEmptyValuesMode(v) {
            this.i.a1 = ensureEnum(LegendEmptyValuesMode_$type, v);
        }
        /**
         * Sets or gets a function which takes an object that produces a formatted label for displaying in the chart.
        */
        get formatLabel() {
            return this.i.a5;
        }
        set formatLabel(v) {
            this.i.a5 = v;
        }
        /**
         * Sets or gets a function which takes an object that produces a formatted label for displaying in the chart's legend.
        */
        get formatLegendLabel() {
            return this.i.a6;
        }
        set formatLegendLabel(v) {
            this.i.a6 = v;
        }
        /**
         * Gets or sets the scaling value used to affect the pixel density of the control.
         * A higher scaling ratio will produce crisper visuals at the expense of memory.  Lower values will cause the control
         * to appear blurry.
        */
        get pixelScalingRatio() {
            return this.i.df;
        }
        set pixelScalingRatio(v) {
            this.i.df = +v;
        }
        /**
         * Resolved pixel scaling ratio. Unless explicitly overridden by the
         * PieChartBase.PixelScalingRatio property,
         * this one returns the default ratio enforced by device. High resolution devices will initialize this property
         * to a higher value.
        */
        get actualPixelScalingRatio() {
            return this.i.c2;
        }
        set actualPixelScalingRatio(v) {
            this.i.c2 = +v;
        }
        /**
         * Gets or sets which mode to use for selecting slices.
        */
        get selectionMode() {
            return this.i.bk;
        }
        set selectionMode(v) {
            this.i.bk = ensureEnum(SliceSelectionMode_$type, v);
        }
        /**
         * Gets or sets the currently selected data item.  If a different data item is provided the pie chart
         * will select the slice associated with the new item.
        */
        get selectedItem() {
            return this.i.selectedItem;
        }
        set selectedItem(v) {
            this.i.selectedItem = v;
        }
        /**
         * Gets the currently selected data items.  Adding or removing data items from this collection will
         * select or deselect the slices associated with those items.
        */
        get selectedItems() {
            if (this._selectedItems === null) {
                let coll = new IgxObjectCollection();
                let innerColl = this.i.selectedItems;
                if (!innerColl) {
                    innerColl = new ObjectCollection_internal(0);
                }
                this._selectedItems = coll._fromInner(innerColl);
                this.i.selectedItems = innerColl;
            }
            return this._selectedItems;
        }
        set selectedItems(v) {
            if (this._selectedItems !== null) {
                this._selectedItems._setSyncTarget(null);
                this._selectedItems = null;
            }
            let coll = new IgxObjectCollection();
            this._selectedItems = coll._fromOuter(v);
            let syncColl = new SyncableObservableCollection$1(Base.$type);
            let innerColl = this.i.selectedItems;
            if (!innerColl) {
                innerColl = new ObjectCollection_internal(0);
            }
            syncColl._inner = innerColl;
            syncColl.clear();
            this._selectedItems._setSyncTarget(syncColl);
            this.i.selectedItems = innerColl;
        }
        /**
         * Manually overrides the style to use for the labels.
        */
        get textStyle() {
            return this.i.fq;
        }
        set textStyle(v) {
            this.i.fq = v;
        }
        findByName(name) {
            if (this.findEphemera) {
                if (name && name.indexOf("@@e:") == 0) {
                    return this.findEphemera(name);
                }
            }
            if (this.legend && this.legend.name && this.legend.name == name) {
                return this.legend;
            }
            if (this.labelFormatSpecifiers != null && arrayFindByName(this.labelFormatSpecifiers, name)) {
                return arrayFindByName(this.labelFormatSpecifiers, name);
            }
            if (this.othersLabelFormatSpecifiers != null && arrayFindByName(this.othersLabelFormatSpecifiers, name)) {
                return arrayFindByName(this.othersLabelFormatSpecifiers, name);
            }
            if (this.legendLabelFormatSpecifiers != null && arrayFindByName(this.legendLabelFormatSpecifiers, name)) {
                return arrayFindByName(this.legendLabelFormatSpecifiers, name);
            }
            if (this.legendOthersLabelFormatSpecifiers != null && arrayFindByName(this.legendOthersLabelFormatSpecifiers, name)) {
                return arrayFindByName(this.legendOthersLabelFormatSpecifiers, name);
            }
            return null;
        }
        get hasUserValues() {
            return this._hasUserValues;
        }
        __m(propertyName) {
            if (!this._inStyling) {
                this._hasUserValues.add(propertyName);
            }
        }
        _styling(container, component, parent) {
            if (this._inStyling) {
                return;
            }
            this._inStyling = true;
            this._stylingContainer = container;
            this._stylingParent = component;
            let genericPrefix = "";
            let typeName = this.i.$type.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            genericPrefix = toSpinal("PieChartBaseComponent");
            let additionalPrefixes = [];
            let prefix = toSpinal(typeName);
            additionalPrefixes.push(prefix + "-");
            let b = this.i.$type.baseType;
            while (b && b.name != "Object" &&
                b.name != "Base" &&
                b.name != "Control" &&
                b.Name != "DependencyObject" &&
                b.Name != "FrameworkElement") {
                typeName = b.name;
                if (typeName.indexOf("Xam") === 0) {
                    typeName = typeName.substring(3);
                }
                let basePrefix = toSpinal(typeName);
                additionalPrefixes.push(basePrefix + "-");
                b = b.baseType;
            }
            if (parent) {
                let parentTypeName = parent.i.$type.name;
                if (parentTypeName.indexOf("Xam") === 0) {
                    parentTypeName = parentTypeName.substring(3);
                }
                let parentPrefix = toSpinal(parentTypeName);
                additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
                additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
            }
            initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
            if (this._otherStyling) {
                this._otherStyling(container, component, parent);
            }
            this._inStyling = false;
        }
        /**
         * Use to force the pie chart to finish any deferred work before printing or evaluating its visual.
         * This should only be called if the visual of the pie chart needs to be synchronously saved or evaluated.
         * Calling this method too often will hinder the performance of the pie chart.
        
        */
        flush() {
            this.i.f0();
        }
        /**
         * Returns the chart visuals expressed as a serialized string.
        
        */
        exportSerializedVisualData() {
            let iv = this.i.d4();
            return (iv);
        }
        /**
         * Simulates a mouse click action at the specified point.
        
        * @param point  * The point to click at.
        */
        simulateLeftClick(point) {
            this.i.g5(toPoint(point));
        }
        /**
         * Invoked by the containing object to provide reference to the container.
        
        * @param container  * Reference to the container.
        */
        provideContainer(container) {
            this.i.provideContainer(container);
        }
        /**
         * Notification from the containing object that the container has been resized.
        
        */
        notifyContainerResized() {
            this.i.notifyContainerResized();
        }
        /**
         * Invoked when the instance is being destroyed.
        
        */
        destroy() {
            this.i.destroy();
        }
        notifySetItem(source_, index, oldItem, newItem) {
            this.i.f9(source_, index, oldItem, newItem);
        }
        /**
         * Manually notifies the pie chart's data source that the data it has bound to has been cleared and needs to be re-examined.
         * This should not be called if the data that the pie chart is bound to is already observable.
        
        * @param source_  * The data source.
        */
        notifyClearItems(source_) {
            this.i.f5(source_);
        }
        notifyInsertItem(source_, index, newItem) {
            this.i.f7(source_, index, newItem);
        }
        notifyRemoveItem(source_, index, oldItem) {
            this.i.f8(source_, index, oldItem);
        }
        /**
         * Assigns data source for the items.
        
        * @param source_  * Array of the data source items.
        */
        setWidgetLevelDataSource(source_) {
            this.i.g4(source_);
        }
        /**
         * Resets items data source.
        
        */
        removeWidgetLevelDataSource() {
            this.i.gv();
        }
        /**
         * Invoked when style is updated.
        
        */
        styleUpdated() {
            this.i.g9();
        }
        /**
         * Raised when the slice's label is clicked.
        */
        get labelClick() {
            if (this._labelClick == null) {
                this._labelClick = new EventEmitter();
                this.i.labelClick = delegateCombine(this.i.labelClick, (o, e) => {
                    this._runInZone(() => {
                        let outerArgs = new IgxLabelClickEventArgs();
                        outerArgs._provideImplementation(e);
                        if (this.beforeLabelClick) {
                            this.beforeLabelClick(this, outerArgs);
                        }
                        this._labelClick.emit({
                            sender: this,
                            args: outerArgs
                        });
                    });
                });
            }
            return this._labelClick;
        }
        /**
         * Raised when the SelectedItem property is changing.  This event is cancelable.
        */
        get selectedItemChanging() {
            if (this._selectedItemChanging == null) {
                this._selectedItemChanging = new EventEmitter();
                this.i.selectedItemChanging = delegateCombine(this.i.selectedItemChanging, (o, e) => {
                    this._runInZone(() => {
                        let outerArgs = new IgxSelectedItemChangingEventArgs();
                        outerArgs._provideImplementation(e);
                        if (this.beforeSelectedItemChanging) {
                            this.beforeSelectedItemChanging(this, outerArgs);
                        }
                        this._selectedItemChanging.emit({
                            sender: this,
                            args: outerArgs
                        });
                    });
                });
            }
            return this._selectedItemChanging;
        }
        /**
         * Raised when the SelectedItems collection is changing.  This event is cancelable.
        */
        get selectedItemsChanging() {
            if (this._selectedItemsChanging == null) {
                this._selectedItemsChanging = new EventEmitter();
                this.i.selectedItemsChanging = delegateCombine(this.i.selectedItemsChanging, (o, e) => {
                    this._runInZone(() => {
                        let outerArgs = new IgxSelectedItemsChangingEventArgs();
                        outerArgs._provideImplementation(e);
                        if (this.beforeSelectedItemsChanging) {
                            this.beforeSelectedItemsChanging(this, outerArgs);
                        }
                        this._selectedItemsChanging.emit({
                            sender: this,
                            args: outerArgs
                        });
                    });
                });
            }
            return this._selectedItemsChanging;
        }
        /**
         * Raised when the SelectedItem property has changed.
        */
        get selectedItemChanged() {
            if (this._selectedItemChanged == null) {
                this._selectedItemChanged = new EventEmitter();
                this.i.selectedItemChanged = delegateCombine(this.i.selectedItemChanged, (o, e) => {
                    this._runInZone(() => {
                        let outerArgs = new IgxSelectedItemChangedEventArgs();
                        outerArgs._provideImplementation(e);
                        if (this.beforeSelectedItemChanged) {
                            this.beforeSelectedItemChanged(this, outerArgs);
                        }
                        this._selectedItemChanged.emit({
                            sender: this,
                            args: outerArgs
                        });
                    });
                });
            }
            return this._selectedItemChanged;
        }
        /**
         * Raised when the SelectedItems collection has changed.
        */
        get selectedItemsChanged() {
            if (this._selectedItemsChanged == null) {
                this._selectedItemsChanged = new EventEmitter();
                this.i.selectedItemsChanged = delegateCombine(this.i.selectedItemsChanged, (o, e) => {
                    this._runInZone(() => {
                        let outerArgs = new IgxSelectedItemsChangedEventArgs();
                        outerArgs._provideImplementation(e);
                        if (this.beforeSelectedItemsChanged) {
                            this.beforeSelectedItemsChanged(this, outerArgs);
                        }
                        this._selectedItemsChanged.emit({
                            sender: this,
                            args: outerArgs
                        });
                    });
                });
            }
            return this._selectedItemsChanged;
        }
        /**
         * Raised when the slice is clicked.
        */
        get sliceClick() {
            if (this._sliceClick == null) {
                this._sliceClick = new EventEmitter();
                this.i.sliceClick = delegateCombine(this.i.sliceClick, (o, e) => {
                    this._runInZone(() => {
                        let outerArgs = new IgxSliceClickEventArgs();
                        outerArgs._provideImplementation(e);
                        if (this.beforeSliceClick) {
                            this.beforeSliceClick(this, outerArgs);
                        }
                        this._sliceClick.emit({
                            sender: this,
                            args: outerArgs
                        });
                    });
                });
            }
            return this._sliceClick;
        }
        /**
         * Raised when a slice is entered by the pointer.
        */
        get sliceEnter() {
            if (this._sliceEnter == null) {
                this._sliceEnter = new EventEmitter();
                this.i.sliceEnter = delegateCombine(this.i.sliceEnter, (o, e) => {
                    this._runInZone(() => {
                        let outerArgs = new IgxSliceEventArgs();
                        outerArgs._provideImplementation(e);
                        if (this.beforeSliceEnter) {
                            this.beforeSliceEnter(this, outerArgs);
                        }
                        this._sliceEnter.emit({
                            sender: this,
                            args: outerArgs
                        });
                    });
                });
            }
            return this._sliceEnter;
        }
        /**
         * Raised when a slice is left by the pointer;
        */
        get sliceLeave() {
            if (this._sliceLeave == null) {
                this._sliceLeave = new EventEmitter();
                this.i.sliceLeave = delegateCombine(this.i.sliceLeave, (o, e) => {
                    this._runInZone(() => {
                        let outerArgs = new IgxSliceEventArgs();
                        outerArgs._provideImplementation(e);
                        if (this.beforeSliceLeave) {
                            this.beforeSliceLeave(this, outerArgs);
                        }
                        this._sliceLeave.emit({
                            sender: this,
                            args: outerArgs
                        });
                    });
                });
            }
            return this._sliceLeave;
        }
        /**
         * Raised when a pointer moves over a slice.
        */
        get sliceHover() {
            if (this._sliceHover == null) {
                this._sliceHover = new EventEmitter();
                this.i.sliceHover = delegateCombine(this.i.sliceHover, (o, e) => {
                    this._runInZone(() => {
                        let outerArgs = new IgxSliceEventArgs();
                        outerArgs._provideImplementation(e);
                        if (this.beforeSliceHover) {
                            this.beforeSliceHover(this, outerArgs);
                        }
                        this._sliceHover.emit({
                            sender: this,
                            args: outerArgs
                        });
                    });
                });
            }
            return this._sliceHover;
        }
        _runInZone(act) {
            if (this._zoneRunner != null) {
                this._zoneRunner(act);
            }
            else {
                act();
            }
        }
    }
    IgxPieChartBaseComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: IgxPieChartBaseComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    IgxPieChartBaseComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: IgxPieChartBaseComponent, selector: "ng-component", inputs: { innerExtent: "innerExtent", valueMemberPath: "valueMemberPath", labelMemberPath: "labelMemberPath", legendLabelMemberPath: "legendLabelMemberPath", labelsPosition: "labelsPosition", labelOuterColor: "labelOuterColor", labelInnerColor: "labelInnerColor", actualLabelOuterColor: "actualLabelOuterColor", actualLabelInnerColor: "actualLabelInnerColor", leaderLineVisibility: "leaderLineVisibility", leaderLineType: "leaderLineType", leaderLineMargin: "leaderLineMargin", toolTip: "toolTip", othersCategoryThreshold: "othersCategoryThreshold", othersCategoryType: "othersCategoryType", othersCategoryText: "othersCategoryText", explodedRadius: "explodedRadius", radiusFactor: "radiusFactor", allowSliceSelection: "allowSliceSelection", allowSliceExplosion: "allowSliceExplosion", explodedSlices: "explodedSlices", labelExtent: "labelExtent", startAngle: "startAngle", sweepDirection: "sweepDirection", othersCategoryFill: "othersCategoryFill", othersCategoryStroke: "othersCategoryStroke", othersCategoryStrokeThickness: "othersCategoryStrokeThickness", othersCategoryOpacity: "othersCategoryOpacity", selectedSliceFill: "selectedSliceFill", selectedSliceStroke: "selectedSliceStroke", selectedSliceStrokeThickness: "selectedSliceStrokeThickness", selectedSliceOpacity: "selectedSliceOpacity", brushes: "brushes", actualBrushes: "actualBrushes", outlines: "outlines", actualOutlines: "actualOutlines", labelFormat: "labelFormat", labelFormatSpecifiers: "labelFormatSpecifiers", othersLabelFormat: "othersLabelFormat", othersLabelFormatSpecifiers: "othersLabelFormatSpecifiers", legendLabelFormat: "legendLabelFormat", legendLabelFormatSpecifiers: "legendLabelFormatSpecifiers", legendOthersLabelFormat: "legendOthersLabelFormat", legendOthersLabelFormatSpecifiers: "legendOthersLabelFormatSpecifiers", legendItemTemplate: "legendItemTemplate", legendItemBadgeTemplate: "legendItemBadgeTemplate", isDragInteractionEnabled: "isDragInteractionEnabled", isSurfaceInteractionDisabled: "isSurfaceInteractionDisabled", shouldDisplayMockData: "shouldDisplayMockData", shouldUseSkeletonStyleForMockData: "shouldUseSkeletonStyleForMockData", legendEmptyValuesMode: "legendEmptyValuesMode", formatLabel: "formatLabel", formatLegendLabel: "formatLegendLabel", pixelScalingRatio: "pixelScalingRatio", actualPixelScalingRatio: "actualPixelScalingRatio", selectionMode: "selectionMode", selectedItem: "selectedItem", selectedItems: "selectedItems", textStyle: "textStyle" }, outputs: { labelClick: "labelClick", selectedItemChanging: "selectedItemChanging", selectedItemsChanging: "selectedItemsChanging", selectedItemChanged: "selectedItemChanged", selectedItemsChanged: "selectedItemsChanged", sliceClick: "sliceClick", sliceEnter: "sliceEnter", sliceLeave: "sliceLeave", sliceHover: "sliceHover" }, ngImport: i0, template: ``, isInline: true });
    return IgxPieChartBaseComponent;
})();
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: IgxPieChartBaseComponent, decorators: [{
            type: Component,
            args: [{
                    template: ``,
                }]
        }], ctorParameters: function () { return []; }, propDecorators: { innerExtent: [{
                type: Input
            }], valueMemberPath: [{
                type: Input
            }], labelMemberPath: [{
                type: Input
            }], legendLabelMemberPath: [{
                type: Input
            }], labelsPosition: [{
                type: Input
            }], labelOuterColor: [{
                type: Input
            }], labelInnerColor: [{
                type: Input
            }], actualLabelOuterColor: [{
                type: Input
            }], actualLabelInnerColor: [{
                type: Input
            }], leaderLineVisibility: [{
                type: Input
            }], leaderLineType: [{
                type: Input
            }], leaderLineMargin: [{
                type: Input
            }], toolTip: [{
                type: Input
            }], othersCategoryThreshold: [{
                type: Input
            }], othersCategoryType: [{
                type: Input
            }], othersCategoryText: [{
                type: Input
            }], explodedRadius: [{
                type: Input
            }], radiusFactor: [{
                type: Input
            }], allowSliceSelection: [{
                type: Input
            }], allowSliceExplosion: [{
                type: Input
            }], explodedSlices: [{
                type: Input
            }], labelExtent: [{
                type: Input
            }], startAngle: [{
                type: Input
            }], sweepDirection: [{
                type: Input
            }], othersCategoryFill: [{
                type: Input
            }], othersCategoryStroke: [{
                type: Input
            }], othersCategoryStrokeThickness: [{
                type: Input
            }], othersCategoryOpacity: [{
                type: Input
            }], selectedSliceFill: [{
                type: Input
            }], selectedSliceStroke: [{
                type: Input
            }], selectedSliceStrokeThickness: [{
                type: Input
            }], selectedSliceOpacity: [{
                type: Input
            }], brushes: [{
                type: Input
            }], actualBrushes: [{
                type: Input
            }], outlines: [{
                type: Input
            }], actualOutlines: [{
                type: Input
            }], labelFormat: [{
                type: Input
            }], labelFormatSpecifiers: [{
                type: Input
            }], othersLabelFormat: [{
                type: Input
            }], othersLabelFormatSpecifiers: [{
                type: Input
            }], legendLabelFormat: [{
                type: Input
            }], legendLabelFormatSpecifiers: [{
                type: Input
            }], legendOthersLabelFormat: [{
                type: Input
            }], legendOthersLabelFormatSpecifiers: [{
                type: Input
            }], legendItemTemplate: [{
                type: Input
            }], legendItemBadgeTemplate: [{
                type: Input
            }], isDragInteractionEnabled: [{
                type: Input
            }], isSurfaceInteractionDisabled: [{
                type: Input
            }], shouldDisplayMockData: [{
                type: Input
            }], shouldUseSkeletonStyleForMockData: [{
                type: Input
            }], legendEmptyValuesMode: [{
                type: Input
            }], formatLabel: [{
                type: Input
            }], formatLegendLabel: [{
                type: Input
            }], pixelScalingRatio: [{
                type: Input
            }], actualPixelScalingRatio: [{
                type: Input
            }], selectionMode: [{
                type: Input
            }], selectedItem: [{
                type: Input
            }], selectedItems: [{
                type: Input
            }], textStyle: [{
                type: Input
            }], labelClick: [{
                type: Output
            }], selectedItemChanging: [{
                type: Output
            }], selectedItemsChanging: [{
                type: Output
            }], selectedItemChanged: [{
                type: Output
            }], selectedItemsChanged: [{
                type: Output
            }], sliceClick: [{
                type: Output
            }], sliceEnter: [{
                type: Output
            }], sliceLeave: [{
                type: Output
            }], sliceHover: [{
                type: Output
            }] } });
