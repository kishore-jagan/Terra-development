/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, BaseError, fromEnum, typeCast, runOn, delegateCombine, delegateRemove, markType, TypeRegistrar } from "igniteui-angular-core";
import { IDataChartToolbarProvider_$type } from "./IDataChartToolbarProvider";
import { ToolActionIconButtonInfo } from "igniteui-angular-core";
import { ToolActionIconMenuInfo } from "igniteui-angular-core";
import { ToolActionGroupHeaderInfo } from "igniteui-angular-core";
import { ToolActionSeparatorInfo } from "igniteui-angular-core";
import { ToolActionLabelInfo } from "igniteui-angular-core";
import { ToolActionCheckboxInfo } from "igniteui-angular-core";
import { DeviceUtils } from "igniteui-angular-core";
import { ToolActionRadioInfo } from "igniteui-angular-core";
import { ToolCommandArgument } from "igniteui-angular-core";
import { AutomaticSeriesRequest } from "./AutomaticSeriesRequest";
import { Axis } from "./Axis";
import { XamDataChart } from "./XamDataChart";
import { FastIterationDictionary$2 } from "igniteui-angular-core";
import { Brush } from "igniteui-angular-core";
import { BrushUtil } from "igniteui-angular-core";
import { CaptureImageSettings } from "igniteui-angular-core";
/**
 * @hidden
 */
export let DataChartToolbarProvider = /*@__PURE__*/ (() => {
    class DataChartToolbarProvider extends Base {
        constructor() {
            super(...arguments);
            this._container = null;
            this.j = null;
            this.h = null;
            this.f = null;
            this.p = null;
            this.q = new FastIterationDictionary$2(Axis.$, Brush.$, 0);
        }
        get container() {
            return this._container;
        }
        set container(a) {
            this._container = a;
        }
        get k() {
            if (TypeRegistrar.isRegistered("HorizontalAnchoredCategorySeriesProxy")) {
                return TypeRegistrar.create("HorizontalAnchoredCategorySeriesProxy");
            }
            else {
                throw new BaseError(1, "category series module is not loaded, but is required.");
            }
        }
        get t() {
            return (TypeRegistrar.isRegistered("HorizontalAnchoredCategorySeriesProxy"));
        }
        get i() {
            if (TypeRegistrar.isRegistered("FinancialPriceSeriesProxy")) {
                return TypeRegistrar.create("FinancialPriceSeriesProxy");
            }
            else {
                throw new BaseError(1, "category series module is not loaded, but is required.");
            }
        }
        get s() {
            return (TypeRegistrar.isRegistered("HorizontalAnchoredCategorySeriesProxy"));
        }
        get g() {
            if (this.f == null) {
                if (TypeRegistrar.isRegistered("AnnotationLayerProxy")) {
                    this.f = TypeRegistrar.create("AnnotationLayerProxy");
                    this.f.container = this.container;
                }
                else {
                    throw new BaseError(1, "annotation layer module is not loaded, but is required.");
                }
            }
            return this.f;
        }
        get r() {
            return (TypeRegistrar.isRegistered("AnnotationLayerProxy"));
        }
        getDesiredToolbarActions(a) {
            let b = new ToolActionIconButtonInfo();
            b.name = "ZoomReset";
            b.iconName = "reset";
            b.iconCollectionName = "ChartToolbarIcons";
            b.iconWidth = 24;
            b.iconHeight = 24;
            b.title = "Reset";
            let c = new ToolActionIconMenuInfo();
            c.name = "ZoomMenu";
            c.iconName = "zoomin";
            c.iconCollectionName = "ChartToolbarIcons";
            c.iconWidth = 24;
            c.iconHeight = 25;
            c.actions = this.e();
            let d = new ToolActionGroupHeaderInfo();
            d.name = "AnalyzeHeader";
            d.title = "Analyze";
            let e = new ToolActionSeparatorInfo();
            e.name = "AnalyzeHeaderSeparator";
            e.isGroupHeaderSeparator = true;
            let f = new ToolActionLabelInfo();
            f.name = "LinesMenu";
            f.title = "Lines";
            f.iconName = "analyze-lines";
            f.iconCollectionName = "ChartToolbarIcons";
            f.iconWidth = 24;
            f.iconHeight = 25;
            f.actions = this.a();
            let g = new ToolActionSeparatorInfo();
            g.name = "LinesMenuSeparator";
            let h = new ToolActionLabelInfo();
            h.name = "TrendsMenu";
            h.title = "Trends";
            h.iconName = "analyze-trends";
            h.iconCollectionName = "ChartToolbarIcons";
            h.iconWidth = 24;
            h.iconHeight = 25;
            h.actions = this.c();
            let i = new ToolActionGroupHeaderInfo();
            i.name = "HelpersHeader";
            i.title = "Helpers";
            let j = new ToolActionSeparatorInfo();
            j.name = "HelpersHeaderSeparator";
            j.isGroupHeaderSeparator = true;
            let k = new ToolActionCheckboxInfo();
            k.name = "SeriesAvg";
            k.title = "Series Average";
            k.iconName = "analyze-seriesavg";
            k.iconCollectionName = "ChartToolbarIcons";
            k.iconWidth = 24;
            k.iconHeight = 25;
            let l = new ToolActionSeparatorInfo();
            l.name = "SeriesAvgSeparator";
            let m = new ToolActionLabelInfo();
            m.name = "ValueLabelsMenu";
            m.title = "Value Labels";
            m.iconName = "analyze-valuelabels";
            m.iconCollectionName = "ChartToolbarIcons";
            m.actions = this.d(a);
            m.iconWidth = 24;
            m.iconHeight = 24;
            let n = new ToolActionSeparatorInfo();
            n.name = "HelpersSectionSeparator";
            n.size = DeviceUtils.g(10);
            let o = new ToolActionCheckboxInfo();
            o.name = "ShowGridlines";
            o.title = "Grid";
            o.iconName = "analyze-grid";
            o.iconCollectionName = "ChartToolbarIcons";
            o.iconWidth = 24;
            o.iconHeight = 25;
            let p = new ToolActionSeparatorInfo();
            p.name = "GridSeparator";
            let q = new ToolActionCheckboxInfo();
            q.name = "ShowCrosshairs";
            q.title = "Crosshairs";
            q.iconName = "analyze-crosshairs";
            q.iconCollectionName = "ChartToolbarIcons";
            q.iconWidth = 24;
            q.iconHeight = 25;
            let r = new ToolActionIconMenuInfo();
            r.name = "AnalyzeMenu";
            r.iconName = "analyze";
            r.iconCollectionName = "ChartToolbarIcons";
            r.iconWidth = 24;
            r.iconHeight = 25;
            r.actions = [d, e, f, g, h, i, j, k, l, m, n, o, p, q];
            let s = new ToolActionGroupHeaderInfo();
            s.name = "CopyHeader";
            s.title = "Copy...";
            let t = new ToolActionLabelInfo();
            t.name = "CopyAsImage";
            t.title = "As Image";
            t.iconName = "copy-image";
            t.iconCollectionName = "ChartToolbarIcons";
            t.closeOnExecute = true;
            let u = new ToolActionLabelInfo();
            u.name = "CopyAsTable";
            u.title = "Table Data";
            u.iconName = "copy-table";
            u.iconCollectionName = "ChartToolbarIcons";
            let v = new ToolActionIconMenuInfo();
            v.name = "CopyMenu";
            v.iconName = "copy";
            v.iconCollectionName = "ChartToolbarIcons";
            v.iconWidth = 24;
            v.iconHeight = 24;
            v.actions = [s, t];
            let w = [b, c, ((() => {
                    let $ret = new ToolActionSeparatorInfo();
                    $ret.name = "ZoomMenuSeparator";
                    return $ret;
                })()), r, ((() => {
                    let $ret = new ToolActionSeparatorInfo();
                    $ret.name = "AnalyzeMenuSeparator";
                    return $ret;
                })()), v];
            for (let x = 0; x < w.length; x++) {
                this.a7(a, w[x]);
            }
            return w;
        }
        a7(a, b) {
            if (b.actions != null && b.actions.length > 0) {
                for (let c = 0; c < b.actions.length; c++) {
                    this.a7(a, b.actions[c]);
                }
            }
            switch (b.name) {
                case "ShowValueLabels":
                    {
                        let d = b;
                        let e = this.l(a);
                        d.isChecked = e != null && e._visibility == 0;
                    }
                    break;
                case "ShowLastValueLabel":
                    {
                        let f = b;
                        let g = this.n(a);
                        f.isChecked = g != null && g._visibility == 0;
                    }
                    break;
                case "Linear":
                    {
                        let h = b;
                        for (let i of fromEnum(a.series)) {
                            if (i.ew) {
                                if (this.t && this.k.matchesType(i)) {
                                    h.isChecked = this.k.getTrendLineType(i) == 1;
                                }
                            }
                            else if (i.e7) {
                                if (this.s && this.i.matchesType(i)) {
                                    h.isChecked = this.i.getTrendLineType(i) == 1;
                                }
                            }
                        }
                    }
                    break;
                case "Exponential":
                    {
                        let j = b;
                        for (let k of fromEnum(a.series)) {
                            if (k.ew) {
                                if (this.t && this.k.matchesType(k)) {
                                    j.isChecked = this.k.getTrendLineType(k) == 7;
                                }
                            }
                            else if (k.e7) {
                                if (this.s && this.i.matchesType(k)) {
                                    j.isChecked = this.i.getTrendLineType(k) == 7;
                                }
                            }
                        }
                    }
                    break;
                case "Logarithmic":
                    {
                        let l = b;
                        for (let m of fromEnum(a.series)) {
                            if (m.ew) {
                                if (this.t && this.k.matchesType(m)) {
                                    l.isChecked = this.k.getTrendLineType(m) == 6;
                                }
                            }
                            else if (m.e7) {
                                if (this.s && this.i.matchesType(m)) {
                                    l.isChecked = this.i.getTrendLineType(m) == 6;
                                }
                            }
                        }
                    }
                    break;
                case "NoTrends":
                    {
                        let n = b;
                        let o = 0;
                        let p = a.series.count;
                        for (let q of fromEnum(a.series)) {
                            if (q.ew) {
                                if (this.t && this.k.matchesType(q) && this.k.getTrendLineType(q) == 0) {
                                    o = o + 1;
                                }
                            }
                            else if (q.e7) {
                                if (this.s && this.i.matchesType(q) && this.i.getTrendLineType(q) == 0) {
                                    o = o + 1;
                                }
                            }
                            else if (q.eq) {
                                p = p - 1;
                            }
                        }
                        n.isChecked = o == p;
                    }
                    break;
                case "MinValue":
                    {
                        let r = b;
                        let s = this.o(a, 4);
                        r.isChecked = s != null && s._visibility == 0;
                    }
                    break;
                case "MaxValue":
                    {
                        let t = b;
                        let u = this.o(a, 5);
                        t.isChecked = u != null && u._visibility == 0;
                    }
                    break;
                case "Average":
                    {
                        let v = b;
                        let w = this.o(a, 6);
                        v.isChecked = w != null && w._visibility == 0;
                    }
                    break;
                case "ShowCrosshairs":
                    {
                        let x = b;
                        let y = this.m(a);
                        x.isChecked = y != null && y._visibility == 0;
                    }
                    break;
                case "SeriesAvg":
                    {
                        let z = b;
                        let aa = this.o(a, 3);
                        z.isChecked = aa != null && aa._visibility == 0;
                    }
                    break;
            }
        }
        e() {
            let a = new ToolActionGroupHeaderInfo();
            a.name = "ZoomHeader";
            a.title = "Zoom";
            let b = new ToolActionLabelInfo();
            b.name = "ZoomIn";
            b.iconName = "zoomin";
            b.iconCollectionName = "ChartToolbarIcons";
            b.iconWidth = 24;
            b.iconHeight = 25;
            b.title = "Zoom In";
            let c = new ToolActionLabelInfo();
            c.name = "ZoomOut";
            c.iconName = "zoomout";
            c.iconCollectionName = "ChartToolbarIcons";
            c.iconWidth = 24;
            c.iconHeight = 25;
            c.title = "Zoom Out";
            return [a, b, c];
        }
        a() {
            let a = new ToolActionGroupHeaderInfo();
            a.name = "LinesHeader";
            a.title = "Lines";
            let b = new ToolActionSeparatorInfo();
            b.isGroupHeaderSeparator = true;
            let c = new ToolActionCheckboxInfo();
            c.name = "MaxValue";
            c.title = "Max value";
            c.iconName = "analyze-lines-maxvalue";
            c.iconCollectionName = "ChartToolbarIcons";
            c.iconWidth = 24;
            c.iconHeight = 25;
            let d = new ToolActionCheckboxInfo();
            d.name = "MinValue";
            d.title = "Min value";
            d.iconName = "analyze-lines-minvalue";
            d.iconCollectionName = "ChartToolbarIcons";
            d.iconWidth = 24;
            d.iconHeight = 25;
            let e = new ToolActionCheckboxInfo();
            e.name = "Average";
            e.title = "Average";
            e.iconName = "analyze-seriesavg";
            e.iconCollectionName = "ChartToolbarIcons";
            e.iconWidth = 24;
            e.iconHeight = 25;
            return [a, b, c, d, e];
        }
        c() {
            let a = new ToolActionGroupHeaderInfo();
            a.name = "TrendsHeader";
            a.title = "Trends";
            let b = new ToolActionSeparatorInfo();
            b.name = "TrendsHeaderSeparator";
            b.isGroupHeaderSeparator = true;
            let c = new ToolActionRadioInfo();
            c.name = "Exponential";
            c.title = "Exponential";
            c.iconName = "analyze-trends-exp";
            c.iconCollectionName = "ChartToolbarIcons";
            c.channel = "trends";
            c.iconWidth = 24;
            c.iconHeight = 25;
            let d = new ToolActionRadioInfo();
            d.name = "Linear";
            d.title = "Linear";
            d.iconName = "analyze-trends-trendline";
            d.iconCollectionName = "ChartToolbarIcons";
            d.channel = "trends";
            d.iconWidth = 24;
            d.iconHeight = 25;
            let e = new ToolActionRadioInfo();
            e.name = "Logarithmic";
            e.title = "Logarithmic";
            e.iconName = "analyze-trends-log";
            e.iconCollectionName = "ChartToolbarIcons";
            e.channel = "trends";
            e.iconWidth = 24;
            e.iconHeight = 25;
            let f = new ToolActionRadioInfo();
            f.name = "NoTrends";
            f.title = "None";
            f.channel = "trends";
            f.iconName = "ig-NoIcon";
            return [a, b, c, d, e, f];
        }
        b() {
            let a = new ToolActionGroupHeaderInfo();
            a.name = "TimePeriodHighlightHeader";
            a.title = "TIME HIGHLIGHT";
            let b = new ToolActionSeparatorInfo();
            b.isGroupHeaderSeparator = true;
            let c = new ToolActionRadioInfo();
            c.name = "Quarters";
            c.title = "Quarters";
            c.channel = "time";
            let d = new ToolActionRadioInfo();
            d.name = "Seasons";
            d.title = "Seasons";
            d.channel = "time";
            let e = new ToolActionRadioInfo();
            e.name = "Weekends";
            e.title = "Weekends";
            e.channel = "time";
            let f = new ToolActionRadioInfo();
            f.name = "WorkDays";
            f.title = "Work days";
            f.channel = "time";
            return [a, b, c, d, e, f];
        }
        d(a) {
            let b = new ToolActionGroupHeaderInfo();
            b.name = "ValueLabelsHeader";
            b.title = "Value Labels";
            let c = new ToolActionSeparatorInfo();
            c.isGroupHeaderSeparator = true;
            let d = new ToolActionCheckboxInfo();
            d.name = "ShowValueLabels";
            d.title = "Show Value Labels";
            d.iconName = "analyze-valuelabels";
            d.iconCollectionName = "ChartToolbarIcons";
            d.iconWidth = 24;
            d.iconHeight = 24;
            let e = new ToolActionCheckboxInfo();
            e.name = "ShowLastValueLabel";
            e.title = "Show Last Value Label";
            e.iconName = "analyze-valuelabels-showlast";
            e.iconCollectionName = "ChartToolbarIcons";
            return [b, c, d, e];
        }
        l(a) {
            for (let b of fromEnum(a.series)) {
                if (this.g.isCalloutLayer(b) && this.g.getIsAutoCalloutBehaviorEnabled(b)) {
                    return b;
                }
            }
            return null;
        }
        n(a) {
            for (let b of fromEnum(a.series)) {
                if (this.g.isFinalValueLayer(b)) {
                    return b;
                }
            }
            return null;
        }
        o(a, b) {
            for (let c of fromEnum(a.series)) {
                if (this.g.isValueLayer(c) && this.g.getValueMode(c) == b) {
                    return c;
                }
            }
            return null;
        }
        m(a) {
            for (let b of fromEnum(a.series)) {
                if (this.g.isCrosshairLayer(b)) {
                    return b;
                }
            }
            return null;
        }
        onToolCommandExecuting(a, b) {
            switch (b.commandId) {
                case "ZoomReset":
                    this.bo(a, b);
                    break;
                case "ZoomIn":
                    this.bm(a, b);
                    break;
                case "ZoomOut":
                    this.bn(a, b);
                    break;
                case "ShowCrosshairs":
                    this.ba(a, b);
                    break;
                case "ShowGridlines":
                    this.bc(a, b);
                    break;
                case "MaxValue":
                    this.bg(a, b);
                    break;
                case "MinValue":
                    this.bh(a, b);
                    break;
                case "Average":
                    this.a8(a, b);
                    break;
                case "Exponential":
                    this.bb(a, b);
                    break;
                case "Linear":
                    this.be(a, b);
                    break;
                case "Logarithmic":
                    this.bf(a, b);
                    break;
                case "NoTrends":
                    this.bi(a, b);
                    break;
                case "SeriesAvg":
                    this.bj(a, b);
                    break;
                case "ShowValueLabels":
                    this.bl(a, b);
                    break;
                case "ShowLastValueLabel":
                    this.bk(a, b);
                    break;
                case "CopyAsImage":
                    this.a9(a, b);
                    return 2;
            }
            return 0;
        }
        u(a, b) {
            if (a.commandId == b) {
                let e = a.argumentsList;
                for (let d = 0; d < e.length; d++) {
                    let c = e[d];
                    if (c.argumentName == "IsChecked") {
                        return c.value;
                    }
                }
            }
            return false;
        }
        ba(a, b) {
            let c = this.m(a);
            if (this.v(a, c)) {
                return;
            }
            this.bp(a, b, "ShowCrosshairs", 0, () => {
                let d = this.g.createCrosshairLayer();
                this.g.setCrosshairOnAxesEnabled(d, true);
                let e = new AutomaticSeriesRequest();
                e.a = 0;
                e.e = true;
                e.d = d;
                return e;
            });
        }
        bc(a, b) {
            let c = this.u(b, "ShowGridlines");
            if (!c) {
                for (let d = 0; d < this.q.o.count; d++) {
                    let e = this.q.o._inner[d];
                    if (e.ju != null) {
                        e.jx = BrushUtil.h(0, 0, 0, 0);
                    }
                }
            }
            else {
                let f = typeCast(XamDataChart.$, a);
                if (f != null) {
                    for (let g = 0; g < f.axes.count; g++) {
                        let h = f.axes._inner[g];
                        if (this.q.d(h)) {
                            h.jx = this.q.item(h);
                        }
                        else {
                            if (h.cb) {
                                if (h.jx == null) {
                                    h.jx = f.z6;
                                    this.q.s(h, f.z6);
                                }
                                else {
                                    this.q.s(h, h.jx);
                                }
                            }
                        }
                    }
                }
            }
        }
        bb(a, b) {
            if (!this.t) {
                return;
            }
            let c = this.u(b, "Exponential");
            if (c) {
                for (let d of fromEnum(a.series)) {
                    if (d.ew) {
                        if (this.t && this.k.matchesType(d)) {
                            this.k.setTrendLineType(d, 7);
                        }
                    }
                    else if (d.e7) {
                        if (this.s && this.i.matchesType(d)) {
                            this.i.setTrendLineType(d, 7);
                        }
                    }
                }
            }
        }
        be(a, b) {
            if (!this.t) {
                return;
            }
            let c = this.u(b, "Linear");
            if (c) {
                for (let d of fromEnum(a.series)) {
                    if (d.ew) {
                        if (this.t && this.k.matchesType(d)) {
                            this.k.setTrendLineType(d, 1);
                        }
                    }
                    else if (d.e7) {
                        if (this.s && this.i.matchesType(d)) {
                            this.i.setTrendLineType(d, 1);
                        }
                    }
                }
            }
        }
        bf(a, b) {
            let c = this.u(b, "Logarithmic");
            if (c) {
                for (let d of fromEnum(a.series)) {
                    if (d.ew) {
                        if (this.t && this.k.matchesType(d)) {
                            this.k.setTrendLineType(d, 6);
                        }
                    }
                    else if (d.e7) {
                        if (this.s && this.i.matchesType(d)) {
                            this.i.setTrendLineType(d, 6);
                        }
                    }
                }
            }
        }
        bi(a, b) {
            let c = this.u(b, "NoTrends");
            if (c) {
                for (let d of fromEnum(a.series)) {
                    if (d.ew) {
                        if (this.t && this.k.matchesType(d)) {
                            this.k.setTrendLineType(d, 0);
                        }
                    }
                    else if (d.e7) {
                        if (this.s && this.i.matchesType(d)) {
                            this.i.setTrendLineType(d, 0);
                        }
                    }
                }
            }
        }
        bp(a, b, c, d, e) {
            let f = this.u(b, c);
            let g = a.ao(a);
            if (f && !g.e(d)) {
                if (this.r && e != null) {
                    g.b.add(e());
                }
            }
            if (!f && g.e(d)) {
                g.l(d);
            }
        }
        bg(a, b) {
            let c = this.o(a, 5);
            if (c != null && this.g.getValueMode(c) == 5 && this.v(a, c)) {
                return;
            }
            this.bp(a, b, "MaxValue", 1, () => {
                let d = this.g.createValueLayer();
                this.g.setValueMode(d, 5);
                this.g.setValueAxisAnnotationEnabled(d, true);
                this.g.setBrush(d, BrushUtil.h(255, 99, 208, 0));
                let e = new AutomaticSeriesRequest();
                e.a = 1;
                e.e = true;
                e.d = d;
                return e;
            });
        }
        bh(a, b) {
            let c = this.o(a, 4);
            if (c != null && this.v(a, c)) {
                return;
            }
            this.bp(a, b, "MinValue", 2, () => {
                let d = this.g.createValueLayer();
                this.g.setValueMode(d, 4);
                this.g.setValueAxisAnnotationEnabled(d, true);
                this.g.setBrush(d, BrushUtil.h(255, 246, 93, 80));
                let e = new AutomaticSeriesRequest();
                e.a = 2;
                e.e = true;
                e.d = d;
                return e;
            });
        }
        a8(a, b) {
            let c = this.o(a, 6);
            if (c != null && this.v(a, c)) {
                return;
            }
            this.bp(a, b, "Average", 3, () => {
                let d = this.g.createValueLayer();
                this.g.setValueMode(d, 6);
                this.g.setValueAxisAnnotationEnabled(d, true);
                this.g.setBrush(d, BrushUtil.h(255, 248, 173, 118));
                let e = new AutomaticSeriesRequest();
                e.a = 3;
                e.e = true;
                e.d = d;
                return e;
            });
        }
        bj(a, b) {
            let c = this.o(a, 3);
            if (c != null && this.v(a, c)) {
                return;
            }
            this.bp(a, b, "SeriesAvg", 4, () => {
                let d = this.g.createValueLayer();
                this.g.setValueMode(d, 3);
                this.g.setValueAxisAnnotationEnabled(d, true);
                let e = new AutomaticSeriesRequest();
                e.a = 4;
                e.e = true;
                e.d = d;
                return e;
            });
        }
        v(a, b) {
            if (b != null) {
                let c = false;
                let d = a.ao(a);
                for (let e of fromEnum(d.b)) {
                    if (e.d == b) {
                        c = true;
                        break;
                    }
                }
                if (!c) {
                    if (b._visibility == 0) {
                        let cl_ = b;
                        let v_ = 1;
                        cl_.visibility = v_;
                        return true;
                    }
                    else if (b._visibility == 1) {
                        let cl_ = b;
                        let v_ = 0;
                        cl_.visibility = v_;
                        return true;
                    }
                }
            }
            return false;
        }
        bl(a, b) {
            let c = this.l(a);
            if (this.v(a, c)) {
                return;
            }
            this.bp(a, b, "ShowValueLabels", 5, () => {
                for (let d of fromEnum(a.series)) {
                    if (d.ew) {
                        if (this.t && this.k.matchesType(d)) {
                            let e = this.k.getMarkerType(d);
                            if (e == 1) {
                                this.k.setMarkerType(d, 13);
                            }
                        }
                    }
                }
                let f = this.g.createCalloutLayer();
                this.g.setIsAutoCalloutBehaviorEnabled(f, true);
                let g = new AutomaticSeriesRequest();
                g.a = 5;
                g.e = true;
                g.d = f;
                return g;
            });
        }
        bk(a, b) {
            let c = this.n(a);
            if (this.v(a, c)) {
                return;
            }
            this.bp(a, b, "ShowLastValueLabel", 6, () => {
                for (let d of fromEnum(a.series)) {
                    let e = d.ai();
                    if (e != null) {
                        for (let g = 0; g < e.length; g++) {
                            let f = e[g];
                            if (f.cj) {
                                f.cu = true;
                            }
                        }
                    }
                }
                let h = this.g.createFinalValueLayer();
                let i = new AutomaticSeriesRequest();
                i.a = 6;
                i.e = true;
                i.d = h;
                return i;
            });
        }
        a9(a, b) {
            this.p = b;
            let c = new CaptureImageSettings();
            c.b = true;
            c.a = 0;
            a.imageCaptured = delegateCombine(a.imageCaptured, runOn(this, this.bd));
            a.mz(c);
            a.al.q();
        }
        bd(a, b) {
            this.p.argumentsList = [((() => {
                    let $ret = new ToolCommandArgument();
                    $ret.argumentName = "Image";
                    $ret.value = b.base64Data;
                    return $ret;
                })())];
            let c = a;
            c.imageCaptured = delegateRemove(c.imageCaptured, runOn(this, this.bd));
            if (c.commandCompleted != null) {
                c.commandCompleted(this.p);
            }
        }
        bm(a, b) {
            a.rl(0.05);
        }
        bn(a, b) {
            a.rm(0.05);
        }
        bo(a, b) {
            a.qu();
        }
    }
    DataChartToolbarProvider.$t = markType(DataChartToolbarProvider, 'DataChartToolbarProvider', Base.$, [IDataChartToolbarProvider_$type]);
    return DataChartToolbarProvider;
})();
