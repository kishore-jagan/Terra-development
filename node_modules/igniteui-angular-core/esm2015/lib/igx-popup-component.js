import { Output, TemplateRef, EventEmitter, Component, ViewContainerRef, ViewChild, ElementRef, Input, ChangeDetectionStrategy } from '@angular/core';
import { toRect, ensureEnum, brushToString, stringToBrush, ensureBool, toSpinal, initializePropertiesFromCss, NamePatcher } from "./componentUtil";
import { AngularRenderer, PortalManager } from "./angular-renderer";
import { delegateCombine } from "./type";
import { Popup } from './Popup';
import { IgxOnPopupEventArgs } from './igx-on-popup-event-args';
import { IgxOnClosedEventArgs } from './igx-on-closed-event-args';
import { IgxFocusEventArgs } from './igx-focus-event-args';
import { PopupAnimationType_$type } from "./PopupAnimationType";
import { PopupPointerPosition_$type } from "./PopupPointerPosition";
import * as i0 from "@angular/core";
export let IgxPopupComponent = /*@__PURE__*/ (() => {
    class IgxPopupComponent {
        constructor(renderer, _elRef, ngZone, injector, componentFactoryResolver) {
            this.renderer = renderer;
            this._elRef = _elRef;
            this.ngZone = ngZone;
            this.injector = injector;
            this.componentFactoryResolver = componentFactoryResolver;
            this._angularRenderer = null;
            this._implementation = null;
            this._componentFactoryResolver = null;
            this._portalManager = null;
            this.__p = null;
            this._hasUserValues = new Set();
            this._stylingContainer = null;
            this._stylingParent = null;
            this._inStyling = false;
            this._onClosed = null;
            this._onPopup = null;
            this._popupGotFocus = null;
            this._popupLostFocus = null;
            this._zoneRunner = null;
            this._componentFactoryResolver = componentFactoryResolver;
            this._implementation = this.createImplementation();
            if (this._styling) {
                NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
            }
        }
        set height(value) {
            this._height = value;
            this.i.notifySizeChanged();
        }
        get height() {
            return this._height;
        }
        set width(value) {
            this._width = value;
            this.renderer.setStyle(this._elRef.element.nativeElement, "width", value);
            this.i.notifySizeChanged();
        }
        get width() {
            return this._width;
        }
        // supports angular themes or custom properties set in CSS
        updateStyle() {
            this._styling(this._mainDiv, this);
        }
        ngOnDestroy() {
            this.i.destroy();
            this._angularRenderer.destroy();
        }
        ngAfterViewInit() {
            this._mainDiv = this._mainDivRef.nativeElement;
            if (this.renderer) {
                this._portalManager = new PortalManager("popupContent", this._componentFactoryResolver);
                this._angularRenderer = new AngularRenderer(this._mainDiv, this.renderer, window.document, this.ngZone, true, {}, this._portalManager);
                this.i.provideRenderer(this._angularRenderer);
                this._portalManager.dynamicContent = this._dynamicContent;
                this._portalManager.onChildContentChanged(this._childTemplateRef);
            }
            this.updateStyle();
        }
        ngAfterContentInit() {
        }
        createImplementation() {
            return new Popup();
        }
        get i() {
            return this._implementation;
        }
        get isFocusable() {
            return this.i.ar;
        }
        set isFocusable(v) {
            this.i.ar = ensureBool(v);
        }
        /**
         * Gets or sets the duration of the Popup and Closeup animations in milliseconds.
        */
        get animationDuration() {
            return this.i.a8;
        }
        set animationDuration(v) {
            this.i.a8 = +v;
        }
        /**
         * Gets or sets whether the popup and closeup animations are animated.
        */
        get animationEnabled() {
            return this.i.al;
        }
        set animationEnabled(v) {
            this.i.al = ensureBool(v);
        }
        /**
         * Gets or sets the type of animation to use when the popup opens and closes.
        */
        get animationType() {
            return this.i.p;
        }
        set animationType(v) {
            this.i.p = ensureEnum(PopupAnimationType_$type, v);
        }
        /**
         * Gets or sets the elevation to use for the button regardless of type.
        */
        get elevation() {
            return this.i.ba;
        }
        set elevation(v) {
            this.i.ba = +v;
        }
        /**
         * Gets or sets the elevation of the border shadow
        */
        get actualElevation() {
            return this.i.a6;
        }
        set actualElevation(v) {
            this.i.a6 = +v;
        }
        /**
         * Gets / sets the isShown state of the panel.
        */
        get isShown() {
            return this.i.aw;
        }
        /**
         * Gets or sets the color to use for the check mark when the checkbox is checked.
        */
        get actualUmbraShadowColor() {
            return brushToString(this.i.cx);
        }
        set actualUmbraShadowColor(v) {
            this.i.cx = stringToBrush(v);
        }
        /**
         * Gets or sets the color to use for the check mark when the checkbox is checked.
        */
        get actualPenumbraShadowColor() {
            return brushToString(this.i.cw);
        }
        set actualPenumbraShadowColor(v) {
            this.i.cw = stringToBrush(v);
        }
        /**
         * Gets or sets the color to use for the check mark when the checkbox is checked.
        */
        get actualAmbientShadowColor() {
            return brushToString(this.i.cv);
        }
        set actualAmbientShadowColor(v) {
            this.i.cv = stringToBrush(v);
        }
        /**
         * Gets or sets the background color of the popup.
        */
        get background() {
            return brushToString(this.i.cy);
        }
        set background(v) {
            this.i.cy = stringToBrush(v);
        }
        get cornerRadius() {
            return this.i.a0;
        }
        set cornerRadius(v) {
            this.i.a0 = +v;
        }
        /**
         * Gets or sets whether to disable hit testing on the popup.
        */
        get isHitTestVisible() {
            return this.i.as;
        }
        set isHitTestVisible(v) {
            this.i.as = ensureBool(v);
        }
        /**
         * Gets or sets whether to disable hit testing during the open and close animations.
        */
        get disableHitTestDuringAnimation() {
            return this.i.an;
        }
        set disableHitTestDuringAnimation(v) {
            this.i.an = ensureBool(v);
        }
        /**
         * Gets or sets whether to show a pointer off the side of the popup towards the popup target.
        */
        get isPointerEnabled() {
            return this.i.at;
        }
        set isPointerEnabled(v) {
            this.i.at = ensureBool(v);
        }
        /**
         * Gets or sets the pointer position.
        */
        get pointerPosition() {
            return this.i.u;
        }
        set pointerPosition(v) {
            this.i.u = ensureEnum(PopupPointerPosition_$type, v);
        }
        /**
         * Gets or sets the pointer background color.
        */
        get pointerBackground() {
            return brushToString(this.i.c2);
        }
        set pointerBackground(v) {
            this.i.c2 = stringToBrush(v);
        }
        /**
         * Gets or sets the pointer size.
        */
        get pointerSize() {
            return this.i.a3;
        }
        set pointerSize(v) {
            this.i.a3 = +v;
        }
        /**
         * Gets whether the popup is in the middle of opening or not.
        */
        get isShowing() {
            return this.i.au;
        }
        set isShowing(v) {
            this.i.au = ensureBool(v);
        }
        /**
         * Gets whether the popup is in the middle of closing or not.
        */
        get isClosing() {
            return this.i.ap;
        }
        set isClosing(v) {
            this.i.ap = ensureBool(v);
        }
        /**
         * Indicates that the popup will position itself relative to the window instead of the document.
        */
        get isFixed() {
            return this.i.aq;
        }
        set isFixed(v) {
            this.i.aq = ensureBool(v);
        }
        /**
         * Indicates that the popup will place itself into the browser top layer.
        */
        get useTopLayer() {
            return this.i.ax;
        }
        set useTopLayer(v) {
            this.i.ax = ensureBool(v);
        }
        findByName(name) {
            if (this.findEphemera) {
                if (name && name.indexOf("@@e:") == 0) {
                    return this.findEphemera(name);
                }
            }
            return null;
        }
        get hasUserValues() {
            return this._hasUserValues;
        }
        __m(propertyName) {
            if (!this._inStyling) {
                this._hasUserValues.add(propertyName);
            }
        }
        _styling(container, component, parent) {
            if (this._inStyling) {
                return;
            }
            this._inStyling = true;
            this._stylingContainer = container;
            this._stylingParent = component;
            let genericPrefix = "";
            let typeName = this.i.$type.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            genericPrefix = toSpinal("PopupComponent");
            let additionalPrefixes = [];
            let prefix = toSpinal(typeName);
            additionalPrefixes.push(prefix + "-");
            let b = this.i.$type.baseType;
            while (b && b.name != "Object" &&
                b.name != "Base" &&
                b.name != "Control" &&
                b.Name != "DependencyObject" &&
                b.Name != "FrameworkElement") {
                typeName = b.name;
                if (typeName.indexOf("Xam") === 0) {
                    typeName = typeName.substring(3);
                }
                let basePrefix = toSpinal(typeName);
                additionalPrefixes.push(basePrefix + "-");
                b = b.baseType;
            }
            if (parent) {
                let parentTypeName = parent.i.$type.name;
                if (parentTypeName.indexOf("Xam") === 0) {
                    parentTypeName = parentTypeName.substring(3);
                }
                let parentPrefix = toSpinal(parentTypeName);
                additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
                additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
            }
            initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
            if (this._otherStyling) {
                this._otherStyling(container, component, parent);
            }
            this._inStyling = false;
        }
        /**
     * Closes the popup.
    
    */
        close() {
            this.i.b5();
        }
        showRelativeToExclusionRect(exclusionRect, popupDirection, popupAlignment) {
            this.i.showRelativeToExclusionRect(toRect(exclusionRect), (popupDirection == null ? null : popupDirection), (popupAlignment == null ? null : popupAlignment));
        }
        /**
         * Exports visual information about the current state of the grid.
        
        */
        exportVisualModel() {
            let iv = this.i.bc();
            return (iv);
        }
        /**
         * Returns a serialized copy of the exported visual model
        
        */
        exportSerializedVisualModel() {
            let iv = this.i.bp();
            return (iv);
        }
        get onClosed() {
            if (this._onClosed == null) {
                this._onClosed = new EventEmitter();
                this.i.onClosed = delegateCombine(this.i.onClosed, (o, e) => {
                    this._runInZone(() => {
                        let outerArgs = new IgxOnClosedEventArgs();
                        outerArgs._provideImplementation(e);
                        if (this.beforeOnClosed) {
                            this.beforeOnClosed(this, outerArgs);
                        }
                        this._onClosed.emit({
                            sender: this,
                            args: outerArgs
                        });
                    });
                });
            }
            return this._onClosed;
        }
        /**
         * Fires when the popup is shown
        */
        get onPopup() {
            if (this._onPopup == null) {
                this._onPopup = new EventEmitter();
                this.i.onPopup = delegateCombine(this.i.onPopup, (o, e) => {
                    this._runInZone(() => {
                        let outerArgs = new IgxOnPopupEventArgs();
                        outerArgs._provideImplementation(e);
                        if (this.beforeOnPopup) {
                            this.beforeOnPopup(this, outerArgs);
                        }
                        this._onPopup.emit({
                            sender: this,
                            args: outerArgs
                        });
                    });
                });
            }
            return this._onPopup;
        }
        /**
         * Fired when the open popup gains focus.
        */
        get popupGotFocus() {
            if (this._popupGotFocus == null) {
                this._popupGotFocus = new EventEmitter();
                this.i.popupGotFocus = delegateCombine(this.i.popupGotFocus, (o, e) => {
                    this._runInZone(() => {
                        let outerArgs = new IgxFocusEventArgs();
                        outerArgs._provideImplementation(e);
                        if (this.beforePopupGotFocus) {
                            this.beforePopupGotFocus(this, outerArgs);
                        }
                        this._popupGotFocus.emit({
                            sender: this,
                            args: outerArgs
                        });
                    });
                });
            }
            return this._popupGotFocus;
        }
        /**
         * Fired when the open popup loses focus.
        */
        get popupLostFocus() {
            if (this._popupLostFocus == null) {
                this._popupLostFocus = new EventEmitter();
                this.i.popupLostFocus = delegateCombine(this.i.popupLostFocus, (o, e) => {
                    this._runInZone(() => {
                        let outerArgs = new IgxFocusEventArgs();
                        outerArgs._provideImplementation(e);
                        if (this.beforePopupLostFocus) {
                            this.beforePopupLostFocus(this, outerArgs);
                        }
                        this._popupLostFocus.emit({
                            sender: this,
                            args: outerArgs
                        });
                    });
                });
            }
            return this._popupLostFocus;
        }
        _runInZone(act) {
            if (this._zoneRunner != null) {
                this._zoneRunner(act);
            }
            else {
                act();
            }
        }
    }
    IgxPopupComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: IgxPopupComponent, deps: [{ token: i0.Renderer2 }, { token: i0.ViewContainerRef }, { token: i0.NgZone }, { token: i0.Injector }, { token: i0.ComponentFactoryResolver }], target: i0.ɵɵFactoryTarget.Component });
    IgxPopupComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: IgxPopupComponent, selector: "igx-popup", inputs: { height: "height", width: "width", isFocusable: "isFocusable", animationDuration: "animationDuration", animationEnabled: "animationEnabled", animationType: "animationType", elevation: "elevation", actualElevation: "actualElevation", actualUmbraShadowColor: "actualUmbraShadowColor", actualPenumbraShadowColor: "actualPenumbraShadowColor", actualAmbientShadowColor: "actualAmbientShadowColor", background: "background", cornerRadius: "cornerRadius", isHitTestVisible: "isHitTestVisible", disableHitTestDuringAnimation: "disableHitTestDuringAnimation", isPointerEnabled: "isPointerEnabled", pointerPosition: "pointerPosition", pointerBackground: "pointerBackground", pointerSize: "pointerSize", isShowing: "isShowing", isClosing: "isClosing", isFixed: "isFixed", useTopLayer: "useTopLayer" }, outputs: { onClosed: "onClosed", onPopup: "onPopup", popupGotFocus: "popupGotFocus", popupLostFocus: "popupLostFocus" }, host: { classAttribute: "ig-popup igx-popup" }, providers: [], viewQueries: [{ propertyName: "_mainDivRef", first: true, predicate: ["mainDivRef"], descendants: true, read: ElementRef, static: true }, { propertyName: "_dynamicContent", first: true, predicate: ["dynamicContent"], descendants: true, read: ViewContainerRef, static: true }, { propertyName: "_childTemplateRef", first: true, predicate: ["childContent"], descendants: true, read: TemplateRef }], ngImport: i0, template: `
    <ng-template #childContent>
        <ng-content></ng-content>
    </ng-template>
    <ng-container #dynamicContent></ng-container>
    <div #mainDivRef>       
	</div>  
    `, isInline: true, styles: ["\n\t\t:host {\n\t\t\tdisplay: block;\n\t\t}\n\t"], changeDetection: i0.ChangeDetectionStrategy.OnPush });
    return IgxPopupComponent;
})();
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: IgxPopupComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'igx-popup',
                    template: `
    <ng-template #childContent>
        <ng-content></ng-content>
    </ng-template>
    <ng-container #dynamicContent></ng-container>
    <div #mainDivRef>       
	</div>  
    `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [],
                    host: { 'class': 'ig-popup igx-popup' },
                    styles: [`
		:host {
			display: block;
		}
	`]
                }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }, { type: i0.ViewContainerRef }, { type: i0.NgZone }, { type: i0.Injector }, { type: i0.ComponentFactoryResolver }]; }, propDecorators: { _mainDivRef: [{
                type: ViewChild,
                args: ['mainDivRef', { read: ElementRef, static: true }]
            }], _dynamicContent: [{
                type: ViewChild,
                args: ["dynamicContent", { read: ViewContainerRef, static: true }]
            }], _childTemplateRef: [{
                type: ViewChild,
                args: ["childContent", { read: TemplateRef, static: false }]
            }], height: [{
                type: Input
            }], width: [{
                type: Input
            }], isFocusable: [{
                type: Input
            }], animationDuration: [{
                type: Input
            }], animationEnabled: [{
                type: Input
            }], animationType: [{
                type: Input
            }], elevation: [{
                type: Input
            }], actualElevation: [{
                type: Input
            }], actualUmbraShadowColor: [{
                type: Input
            }], actualPenumbraShadowColor: [{
                type: Input
            }], actualAmbientShadowColor: [{
                type: Input
            }], background: [{
                type: Input
            }], cornerRadius: [{
                type: Input
            }], isHitTestVisible: [{
                type: Input
            }], disableHitTestDuringAnimation: [{
                type: Input
            }], isPointerEnabled: [{
                type: Input
            }], pointerPosition: [{
                type: Input
            }], pointerBackground: [{
                type: Input
            }], pointerSize: [{
                type: Input
            }], isShowing: [{
                type: Input
            }], isClosing: [{
                type: Input
            }], isFixed: [{
                type: Input
            }], useTopLayer: [{
                type: Input
            }], onClosed: [{
                type: Output
            }], onPopup: [{
                type: Output
            }], popupGotFocus: [{
                type: Output
            }], popupLostFocus: [{
                type: Output
            }] } });
